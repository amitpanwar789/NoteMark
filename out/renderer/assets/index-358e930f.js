var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$6 = Symbol.for("react.element"), n$a = Symbol.for("react.portal"), p$b = Symbol.for("react.fragment"), q$a = Symbol.for("react.strict_mode"), r$b = Symbol.for("react.profiler"), t$9 = Symbol.for("react.provider"), u$b = Symbol.for("react.context"), v$a = Symbol.for("react.forward_ref"), w$8 = Symbol.for("react.suspense"), x$5 = Symbol.for("react.memo"), y$7 = Symbol.for("react.lazy"), z$9 = Symbol.iterator;
function A$4(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$9 && a2[z$9] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$a = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$9 = Object.assign, D$7 = {};
function E$8(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$7;
  this.updater = e2 || B$a;
}
E$8.prototype.isReactComponent = {};
E$8.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$8.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$7() {
}
F$7.prototype = E$8.prototype;
function G$8(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$7;
  this.updater = e2 || B$a;
}
var H$8 = G$8.prototype = new F$7();
H$8.constructor = G$8;
C$9(H$8, E$8.prototype);
H$8.isPureReactComponent = true;
var I$7 = Array.isArray, J$5 = Object.prototype.hasOwnProperty, K$6 = { current: null }, L$6 = { key: true, ref: true, __self: true, __source: true };
function M$4(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$5.call(b2, d2) && !L$6.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$6, type: a2, key: k2, ref: h2, props: c2, _owner: K$6.current };
}
function N$5(a2, b2) {
  return { $$typeof: l$6, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$5(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$6;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$4 = /\/+/g;
function Q$4(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
}
function R$5(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$6:
          case n$a:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$4(h2, 0) : d2, I$7(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$4, "$&/") + "/"), R$5(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$5(c2) && (c2 = N$5(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$4, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$7(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$4(k2, g2);
      h2 += R$5(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$4(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$4(k2, g2++), h2 += R$5(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$5(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$5(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$5(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$5 = { current: null }, V$3 = { transition: null }, W$4 = { ReactCurrentDispatcher: U$5, ReactCurrentBatchConfig: V$3, ReactCurrentOwner: K$6 };
react_production_min.Children = { map: S$5, forEach: function(a2, b2, e2) {
  S$5(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$5(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$5(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$5(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$8;
react_production_min.Fragment = p$b;
react_production_min.Profiler = r$b;
react_production_min.PureComponent = G$8;
react_production_min.StrictMode = q$a;
react_production_min.Suspense = w$8;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$4;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$9({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$6.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$5.call(b2, f2) && !L$6.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$6, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$b, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$9, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$4;
react_production_min.createFactory = function(a2) {
  var b2 = M$4.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$a, render: a2 };
};
react_production_min.isValidElement = O$5;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$7, _payload: { _status: -1, _result: a2 }, _init: T$5 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$5, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$3.transition;
  V$3.transition = {};
  try {
    a2();
  } finally {
    V$3.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$5.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$5.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$5.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$5.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$5.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$5.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$5.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$5.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$5.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$5.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$5.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$5.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$5.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$5.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React__default = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$8 = reactExports, k$a = Symbol.for("react.element"), l$5 = Symbol.for("react.fragment"), m$a = Object.prototype.hasOwnProperty, n$9 = f$8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$a = { key: true, ref: true, __self: true, __source: true };
function q$9(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$a.call(a2, b2) && !p$a.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$a, type: c2, key: e2, ref: h2, props: d2, _owner: n$9.current };
}
reactJsxRuntime_production_min.Fragment = l$5;
reactJsxRuntime_production_min.jsx = q$9;
reactJsxRuntime_production_min.jsxs = q$9;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x3 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x3, C2) ? (a2[d2] = x3, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x3, c2))
            a2[d2] = x3, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t3 = [], u2 = 1, v3 = null, y2 = 3, z2 = false, A2 = false, B3 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t3); null !== b2; ) {
      if (null === b2.callback)
        k2(t3);
      else if (b2.startTime <= a2)
        k2(t3), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t3);
    }
  }
  function H3(a2) {
    B3 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t3);
        null !== b2 && K2(H3, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B3 && (B3 = false, E2(L4), L4 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v3 = h2(r2); null !== v3 && (!(v3.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v3.callback;
        if ("function" === typeof d2) {
          v3.callback = null;
          y2 = v3.priorityLevel;
          var e2 = d2(v3.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v3.callback = e2 : v3 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v3 = h2(r2);
      }
      if (null !== v3)
        var w2 = true;
      else {
        var m2 = h2(t3);
        null !== m2 && K2(H3, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v3 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L4 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L4 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t3, a2), null === h2(r2) && a2 === h2(t3) && (B3 ? (E2(L4), L4 = -1) : B3 = true, K2(H3, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa$2 = reactExports, ca$3 = schedulerExports;
function p$9(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da$2 = /* @__PURE__ */ new Set(), ea$3 = {};
function fa$3(a2, b2) {
  ha$3(a2, b2);
  ha$3(a2 + "Capture", b2);
}
function ha$3(a2, b2) {
  ea$3[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da$2.add(b2[a2]);
}
var ia$1 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja$1 = Object.prototype.hasOwnProperty, ka$1 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la$2 = {}, ma$2 = {};
function oa$1(a2) {
  if (ja$1.call(ma$2, a2))
    return true;
  if (ja$1.call(la$2, a2))
    return false;
  if (ka$1.test(a2))
    return ma$2[a2] = true;
  la$2[a2] = true;
  return false;
}
function pa$2(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa$2(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa$2(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$9(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$8 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$8[a2] = new v$9(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$8[b2] = new v$9(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$8[a2] = new v$9(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$8[a2] = new v$9(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$8[a2] = new v$9(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$8[a2] = new v$9(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$8[a2] = new v$9(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$8[a2] = new v$9(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$8[a2] = new v$9(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra$2 = /[\-:]([a-z])/g;
function sa$2(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra$2,
    sa$2
  );
  z$8[b2] = new v$9(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra$2, sa$2);
  z$8[b2] = new v$9(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra$2, sa$2);
  z$8[b2] = new v$9(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$8[a2] = new v$9(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$8.xlinkHref = new v$9("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$8[a2] = new v$9(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta$2(a2, b2, c2, d2) {
  var e2 = z$8.hasOwnProperty(b2) ? z$8[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa$2(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa$1(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua$1 = aa$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va$2 = Symbol.for("react.element"), wa$2 = Symbol.for("react.portal"), ya$1 = Symbol.for("react.fragment"), za$2 = Symbol.for("react.strict_mode"), Aa$2 = Symbol.for("react.profiler"), Ba$2 = Symbol.for("react.provider"), Ca$2 = Symbol.for("react.context"), Da$2 = Symbol.for("react.forward_ref"), Ea$1 = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga$1 = Symbol.for("react.memo"), Ha$1 = Symbol.for("react.lazy");
var Ia$1 = Symbol.for("react.offscreen");
var Ja$1 = Symbol.iterator;
function Ka$1(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja$1 && a2[Ja$1] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$3 = Object.assign, La$1;
function Ma$1(a2) {
  if (void 0 === La$1)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La$1 = b2 && b2[1] || "";
    }
  return "\n" + La$1 + a2;
}
var Na$1 = false;
function Oa$1(a2, b2) {
  if (!a2 || Na$1)
    return "";
  Na$1 = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na$1 = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma$1(a2) : "";
}
function Pa$1(a2) {
  switch (a2.tag) {
    case 5:
      return Ma$1(a2.type);
    case 16:
      return Ma$1("Lazy");
    case 13:
      return Ma$1("Suspense");
    case 19:
      return Ma$1("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa$1(a2.type, false), a2;
    case 11:
      return a2 = Oa$1(a2.type.render, false), a2;
    case 1:
      return a2 = Oa$1(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa$1(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya$1:
      return "Fragment";
    case wa$2:
      return "Portal";
    case Aa$2:
      return "Profiler";
    case za$2:
      return "StrictMode";
    case Ea$1:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca$2:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba$2:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da$2:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga$1:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa$1(a2.type) || "Memo";
      case Ha$1:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa$1(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra$1(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa$1(b2);
    case 8:
      return b2 === za$2 ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa$1(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta$1(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua$1(a2) {
  var b2 = Ta$1(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua$1(a2));
}
function Wa$1(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta$1(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa$1(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya$1(a2, b2) {
  var c2 = b2.checked;
  return A$3({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za$1(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa$1(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab$1(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta$2(a2, "checked", b2, false);
}
function bb$1(a2, b2) {
  ab$1(a2, b2);
  var c2 = Sa$1(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb$1(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb$1(a2, b2.type, Sa$1(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db$1(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb$1(a2, b2, c2) {
  if ("number" !== b2 || Xa$1(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb$1 = Array.isArray;
function fb$1(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa$1(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb$1(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$9(91));
  return A$3({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb$1(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$9(92));
      if (eb$1(c2)) {
        if (1 < c2.length)
          throw Error(p$9(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa$1(c2) };
}
function ib$1(a2, b2) {
  var c2 = Sa$1(b2.value), d2 = Sa$1(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb$1(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb$1(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb$1(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb$1(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb$1 = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb$1 = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb$1).forEach(function(a2) {
  qb$1.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb$1[b2] = pb$1[a2];
  });
});
function rb$1(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb$1.hasOwnProperty(a2) && pb$1[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb$1(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb$1(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb$1 = A$3({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub$1(a2, b2) {
  if (b2) {
    if (tb$1[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$9(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$9(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$9(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$9(62));
  }
}
function vb$1(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb$1 = null;
function xb$1(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb$1 = null, zb$1 = null, Ab$1 = null;
function Bb$1(a2) {
  if (a2 = Cb$1(a2)) {
    if ("function" !== typeof yb$1)
      throw Error(p$9(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db$1(b2), yb$1(a2.stateNode, a2.type, b2));
  }
}
function Eb$1(a2) {
  zb$1 ? Ab$1 ? Ab$1.push(a2) : Ab$1 = [a2] : zb$1 = a2;
}
function Fb$1() {
  if (zb$1) {
    var a2 = zb$1, b2 = Ab$1;
    Ab$1 = zb$1 = null;
    Bb$1(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb$1(b2[a2]);
  }
}
function Gb$1(a2, b2) {
  return a2(b2);
}
function Hb$1() {
}
var Ib$1 = false;
function Jb$1(a2, b2, c2) {
  if (Ib$1)
    return a2(b2, c2);
  Ib$1 = true;
  try {
    return Gb$1(a2, b2, c2);
  } finally {
    if (Ib$1 = false, null !== zb$1 || null !== Ab$1)
      Hb$1(), Fb$1();
  }
}
function Kb$1(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db$1(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$9(231, b2, typeof c2));
  return c2;
}
var Lb$1 = false;
if (ia$1)
  try {
    var Mb$1 = {};
    Object.defineProperty(Mb$1, "passive", { get: function() {
      Lb$1 = true;
    } });
    window.addEventListener("test", Mb$1, Mb$1);
    window.removeEventListener("test", Mb$1, Mb$1);
  } catch (a2) {
    Lb$1 = false;
  }
function Nb$1(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob$1 = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob$1 = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob$1 = false;
  Pb = null;
  Nb$1.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob$1) {
    if (Ob$1) {
      var l2 = Pb;
      Ob$1 = false;
      Pb = null;
    } else
      throw Error(p$9(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb$1(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb$1(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb$1(a2) {
  if (Vb$1(a2) !== a2)
    throw Error(p$9(188));
}
function Yb$1(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb$1(a2);
    if (null === b2)
      throw Error(p$9(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb$1(e2), a2;
        if (f2 === d2)
          return Xb$1(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$9(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$9(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$9(190));
  }
  if (3 !== c2.tag)
    throw Error(p$9(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb$1(a2) {
  a2 = Yb$1(a2);
  return null !== a2 ? $b$1(a2) : null;
}
function $b$1(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b$1(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac$1 = ca$3.unstable_scheduleCallback, bc$1 = ca$3.unstable_cancelCallback, cc$1 = ca$3.unstable_shouldYield, dc$1 = ca$3.unstable_requestPaint, B$9 = ca$3.unstable_now, ec$1 = ca$3.unstable_getCurrentPriorityLevel, fc$1 = ca$3.unstable_ImmediatePriority, gc$1 = ca$3.unstable_UserBlockingPriority, hc$1 = ca$3.unstable_NormalPriority, ic$1 = ca$3.unstable_LowPriority, jc$1 = ca$3.unstable_IdlePriority, kc$1 = null, lc$1 = null;
function mc$1(a2) {
  if (lc$1 && "function" === typeof lc$1.onCommitFiberRoot)
    try {
      lc$1.onCommitFiberRoot(kc$1, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc$1 = Math.clz32 ? Math.clz32 : nc$1, pc$1 = Math.log, qc$1 = Math.LN2;
function nc$1(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc$1(a2) / qc$1 | 0) | 0;
}
var rc$1 = 64, sc$1 = 4194304;
function tc$1(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc$1(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc$1(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc$1(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc$1(g2) : 0 !== f2 && (d2 = tc$1(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc$1(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc$1(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc$1(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc$1(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc$1(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc$1(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc$1() {
  var a2 = rc$1;
  rc$1 <<= 1;
  0 === (rc$1 & 4194240) && (rc$1 = 64);
  return a2;
}
function zc$1(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac$1(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc$1(b2);
  a2[b2] = c2;
}
function Bc$1(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc$1(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc$1(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc$1(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C$8 = 0;
function Dc$1(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec$1, Fc$1, Gc$1, Hc$1, Ic$1, Jc$1 = false, Kc$1 = [], Lc$1 = null, Mc$1 = null, Nc$1 = null, Oc$1 = /* @__PURE__ */ new Map(), Pc$1 = /* @__PURE__ */ new Map(), Qc$1 = [], Rc$1 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc$1(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc$1 = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc$1 = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc$1 = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc$1.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc$1.delete(b2.pointerId);
  }
}
function Tc$1(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb$1(b2), null !== b2 && Fc$1(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc$1(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc$1 = Tc$1(Lc$1, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc$1 = Tc$1(Mc$1, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc$1 = Tc$1(Nc$1, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc$1.set(f2, Tc$1(Oc$1.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc$1.set(f2, Tc$1(Pc$1.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc$1(a2) {
  var b2 = Wc$1(a2.target);
  if (null !== b2) {
    var c2 = Vb$1(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb$1(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic$1(a2.priority, function() {
            Gc$1(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc$1(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc$1(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb$1 = d2;
      c2.target.dispatchEvent(d2);
      wb$1 = null;
    } else
      return b2 = Cb$1(c2), null !== b2 && Fc$1(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc$1(a2, b2, c2) {
  Xc$1(a2) && c2.delete(b2);
}
function $c() {
  Jc$1 = false;
  null !== Lc$1 && Xc$1(Lc$1) && (Lc$1 = null);
  null !== Mc$1 && Xc$1(Mc$1) && (Mc$1 = null);
  null !== Nc$1 && Xc$1(Nc$1) && (Nc$1 = null);
  Oc$1.forEach(Zc$1);
  Pc$1.forEach(Zc$1);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc$1 || (Jc$1 = true, ca$3.unstable_scheduleCallback(ca$3.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc$1.length) {
    ad(Kc$1[0], a2);
    for (var c2 = 1; c2 < Kc$1.length; c2++) {
      var d2 = Kc$1[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc$1 && ad(Lc$1, a2);
  null !== Mc$1 && ad(Mc$1, a2);
  null !== Nc$1 && ad(Nc$1, a2);
  Oc$1.forEach(b2);
  Pc$1.forEach(b2);
  for (c2 = 0; c2 < Qc$1.length; c2++)
    d2 = Qc$1[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc$1.length && (c2 = Qc$1[0], null === c2.blockedOn); )
    Vc$1(c2), null === c2.blockedOn && Qc$1.shift();
}
var cd = ua$1.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C$8, f2 = cd.transition;
  cd.transition = null;
  try {
    C$8 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$8 = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C$8, f2 = cd.transition;
  cd.transition = null;
  try {
    C$8 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$8 = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc$1(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id$1, c2), Sc$1(a2, d2);
    else if (Uc$1(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc$1(a2, d2), b2 & 4 && -1 < Rc$1.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb$1(e2);
        null !== f2 && Ec$1(f2);
        f2 = Yc$1(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id$1, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id$1 = null;
function Yc$1(a2, b2, c2, d2) {
  id$1 = null;
  a2 = xb$1(d2);
  a2 = Wc$1(a2);
  if (null !== a2)
    if (b2 = Vb$1(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb$1(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id$1 = a2;
  return null;
}
function jd$1(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec$1()) {
        case fc$1:
          return 1;
        case gc$1:
          return 4;
        case hc$1:
        case ic$1:
          return 16;
        case jc$1:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd$1 = null, ld$1 = null, md$1 = null;
function nd$1() {
  if (md$1)
    return md$1;
  var a2, b2 = ld$1, c2 = b2.length, d2, e2 = "value" in kd$1 ? kd$1.value : kd$1.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md$1 = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od$1(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd$1() {
  return true;
}
function qd$1() {
  return false;
}
function rd$1(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd$1 : qd$1;
    this.isPropagationStopped = qd$1;
    return this;
  }
  A$3(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd$1);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd$1);
  }, persist: function() {
  }, isPersistent: pd$1 });
  return b2;
}
var sd$1 = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td$1 = rd$1(sd$1), ud$1 = A$3({}, sd$1, { view: 0, detail: 0 }), vd$1 = rd$1(ud$1), wd$1, xd$1, yd$1, Ad$1 = A$3({}, ud$1, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd$1, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd$1 && (yd$1 && "mousemove" === a2.type ? (wd$1 = a2.screenX - yd$1.screenX, xd$1 = a2.screenY - yd$1.screenY) : xd$1 = wd$1 = 0, yd$1 = a2);
  return wd$1;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd$1;
} }), Bd$1 = rd$1(Ad$1), Cd$1 = A$3({}, Ad$1, { dataTransfer: 0 }), Dd$1 = rd$1(Cd$1), Ed$1 = A$3({}, ud$1, { relatedTarget: 0 }), Fd$1 = rd$1(Ed$1), Gd$1 = A$3({}, sd$1, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd$1 = rd$1(Gd$1), Id$1 = A$3({}, sd$1, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd$1 = rd$1(Id$1), Kd$1 = A$3({}, sd$1, { data: 0 }), Ld$1 = rd$1(Kd$1), Md$1 = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd$1 = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od$1 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd$1(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od$1[a2]) ? !!b2[a2] : false;
}
function zd$1() {
  return Pd$1;
}
var Qd$1 = A$3({}, ud$1, { key: function(a2) {
  if (a2.key) {
    var b2 = Md$1[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od$1(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd$1[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd$1, charCode: function(a2) {
  return "keypress" === a2.type ? od$1(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od$1(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd$1 = rd$1(Qd$1), Sd$1 = A$3({}, Ad$1, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td$1 = rd$1(Sd$1), Ud$1 = A$3({}, ud$1, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd$1 }), Vd$1 = rd$1(Ud$1), Wd$1 = A$3({}, sd$1, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd$1 = rd$1(Wd$1), Yd$1 = A$3({}, Ad$1, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd$1 = rd$1(Yd$1), $d$1 = [9, 13, 27, 32], ae$1 = ia$1 && "CompositionEvent" in window, be$1 = null;
ia$1 && "documentMode" in document && (be$1 = document.documentMode);
var ce$1 = ia$1 && "TextEvent" in window && !be$1, de$1 = ia$1 && (!ae$1 || be$1 && 8 < be$1 && 11 >= be$1), ee$1 = String.fromCharCode(32), fe$1 = false;
function ge$1(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d$1.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$1 = false;
function je$1(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee$1;
    case "textInput":
      return a2 = b2.data, a2 === ee$1 && fe$1 ? null : a2;
    default:
      return null;
  }
}
function ke$1(a2, b2) {
  if (ie$1)
    return "compositionend" === a2 || !ae$1 && ge$1(a2, b2) ? (a2 = nd$1(), md$1 = ld$1 = kd$1 = null, ie$1 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$1[a2.type] : "textarea" === b2 ? true : false;
}
function ne$1(a2, b2, c2, d2) {
  Eb$1(d2);
  b2 = oe$1(b2, "onChange");
  0 < b2.length && (c2 = new td$1("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$1 = null, qe$1 = null;
function re$1(a2) {
  se$1(a2, 0);
}
function te$1(a2) {
  var b2 = ue$1(a2);
  if (Wa$1(b2))
    return a2;
}
function ve$1(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we$1 = false;
if (ia$1) {
  var xe$1;
  if (ia$1) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze$1.oninput;
    }
    xe$1 = ye$1;
  } else
    xe$1 = false;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), qe$1 = pe$1 = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$1(qe$1)) {
    var b2 = [];
    ne$1(b2, qe$1, a2, xb$1(a2));
    Jb$1(re$1, b2);
  }
}
function Ce$1(a2, b2, c2) {
  "focusin" === a2 ? (Ae$1(), pe$1 = b2, qe$1 = c2, pe$1.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae$1();
}
function De$1(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$1(qe$1);
}
function Ee$1(a2, b2) {
  if ("click" === a2)
    return te$1(b2);
}
function Fe$1(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$1(b2);
}
function Ge$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie(a2, b2) {
  if (He(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja$1.call(b2, e2) || !He(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a2 = window, b2 = Xa$1(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa$1(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia$1 && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$1 = null, Se$1 = null, Te$1 = false;
function Ue$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$1 || null == Qe$1 || Qe$1 !== Xa$1(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie(Se$1, d2) || (Se$1 = d2, d2 = oe$1(Re$1, "onSelect"), 0 < d2.length && (b2 = new td$1("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
}
function Ve$1(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia$1 && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a2) {
  if (Xe$1[a2])
    return Xe$1[a2];
  if (!We$1[a2])
    return a2;
  var b2 = We$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe$1[a2] = b2[c2];
  return a2;
}
var $e$1 = Ze$1("animationend"), af$1 = Ze$1("animationiteration"), bf$1 = Ze$1("animationstart"), cf$1 = Ze$1("transitionend"), df$1 = /* @__PURE__ */ new Map(), ef$1 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff$1(a2, b2) {
  df$1.set(a2, b2);
  fa$3(b2, [a2]);
}
for (var gf$1 = 0; gf$1 < ef$1.length; gf$1++) {
  var hf$1 = ef$1[gf$1], jf$1 = hf$1.toLowerCase(), kf$1 = hf$1[0].toUpperCase() + hf$1.slice(1);
  ff$1(jf$1, "on" + kf$1);
}
ff$1($e$1, "onAnimationEnd");
ff$1(af$1, "onAnimationIteration");
ff$1(bf$1, "onAnimationStart");
ff$1("dblclick", "onDoubleClick");
ff$1("focusin", "onFocus");
ff$1("focusout", "onBlur");
ff$1(cf$1, "onTransitionEnd");
ha$3("onMouseEnter", ["mouseout", "mouseover"]);
ha$3("onMouseLeave", ["mouseout", "mouseover"]);
ha$3("onPointerEnter", ["pointerout", "pointerover"]);
ha$3("onPointerLeave", ["pointerout", "pointerover"]);
fa$3("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa$3("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa$3("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa$3("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa$3("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa$3("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf$1 = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf$1 = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf$1));
function nf$1(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$1(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf$1(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf$1(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$6(a2, b2) {
  var c2 = b2[of$1];
  void 0 === c2 && (c2 = b2[of$1] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf$1(b2, a2, 2, false), c2.add(d2));
}
function qf$1(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf$1(c2, a2, d2, b2);
}
var rf$1 = "_reactListening" + Math.random().toString(36).slice(2);
function sf$1(a2) {
  if (!a2[rf$1]) {
    a2[rf$1] = true;
    da$2.forEach(function(b3) {
      "selectionchange" !== b3 && (mf$1.has(b3) || qf$1(b3, false, a2), qf$1(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf$1] || (b2[rf$1] = true, qf$1("selectionchange", false, b2));
  }
}
function pf$1(a2, b2, c2, d2) {
  switch (jd$1(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb$1 || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc$1(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb$1(function() {
    var d3 = f2, e3 = xb$1(c2), g3 = [];
    a: {
      var h3 = df$1.get(a2);
      if (void 0 !== h3) {
        var k3 = td$1, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od$1(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd$1;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd$1;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd$1;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd$1;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd$1;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd$1;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd$1;
            break;
          case $e$1:
          case af$1:
          case bf$1:
            k3 = Hd$1;
            break;
          case cf$1:
            k3 = Xd$1;
            break;
          case "scroll":
            k3 = vd$1;
            break;
          case "wheel":
            k3 = Zd$1;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd$1;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td$1;
        }
        var t3 = 0 !== (b2 & 4), J2 = !t3 && "scroll" === a2, x3 = t3 ? null !== h3 ? h3 + "Capture" : null : h3;
        t3 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x3 && (F2 = Kb$1(w2, x3), null != F2 && t3.push(tf$1(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t3.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t3 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb$1 && (n2 = c2.relatedTarget || c2.fromElement) && (Wc$1(n2) || n2[uf$1]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc$1(n2) : null, null !== n2 && (J2 = Vb$1(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t3 = Bd$1;
            F2 = "onMouseLeave";
            x3 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t3 = Td$1, F2 = "onPointerLeave", x3 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$1(k3);
            u2 = null == n2 ? h3 : ue$1(n2);
            h3 = new t3(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc$1(e3) === d3 && (t3 = new t3(x3, w2 + "enter", n2, c2, e3), t3.target = u2, t3.relatedTarget = J2, F2 = t3);
            J2 = F2;
            if (k3 && n2)
              b: {
                t3 = k3;
                x3 = n2;
                w2 = 0;
                for (u2 = t3; u2; u2 = vf$1(u2))
                  w2++;
                u2 = 0;
                for (F2 = x3; F2; F2 = vf$1(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t3 = vf$1(t3), w2--;
                for (; 0 < u2 - w2; )
                  x3 = vf$1(x3), u2--;
                for (; w2--; ) {
                  if (t3 === x3 || null !== x3 && t3 === x3.alternate)
                    break b;
                  t3 = vf$1(t3);
                  x3 = vf$1(x3);
                }
                t3 = null;
              }
            else
              t3 = null;
            null !== k3 && wf$1(g3, h3, k3, t3, false);
            null !== n2 && null !== J2 && wf$1(g3, J2, n2, t3, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$1(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na2 = ve$1;
        else if (me$1(h3))
          if (we$1)
            na2 = Fe$1;
          else {
            na2 = De$1;
            var xa2 = Ce$1;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na2 = Ee$1);
        if (na2 && (na2 = na2(a2, d3))) {
          ne$1(g3, na2, c2, e3);
          break a;
        }
        xa2 && xa2(a2, h3, d3);
        "focusout" === a2 && (xa2 = h3._wrapperState) && xa2.controlled && "number" === h3.type && cb$1(h3, "number", h3.value);
      }
      xa2 = d3 ? ue$1(d3) : window;
      switch (a2) {
        case "focusin":
          if (me$1(xa2) || "true" === xa2.contentEditable)
            Qe$1 = xa2, Re$1 = d3, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re$1 = Qe$1 = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue$1(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e3);
      }
      var $a2;
      if (ae$1)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba2 = "onCompositionStart";
              break b;
            case "compositionend":
              ba2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba2 = "onCompositionUpdate";
              break b;
          }
          ba2 = void 0;
        }
      else
        ie$1 ? ge$1(a2, c2) && (ba2 = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba2 = "onCompositionStart");
      ba2 && (de$1 && "ko" !== c2.locale && (ie$1 || "onCompositionStart" !== ba2 ? "onCompositionEnd" === ba2 && ie$1 && ($a2 = nd$1()) : (kd$1 = e3, ld$1 = "value" in kd$1 ? kd$1.value : kd$1.textContent, ie$1 = true)), xa2 = oe$1(d3, ba2), 0 < xa2.length && (ba2 = new Ld$1(ba2, a2, null, c2, e3), g3.push({ event: ba2, listeners: xa2 }), $a2 ? ba2.data = $a2 : ($a2 = he$1(c2), null !== $a2 && (ba2.data = $a2))));
      if ($a2 = ce$1 ? je$1(a2, c2) : ke$1(a2, c2))
        d3 = oe$1(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld$1("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a2);
    }
    se$1(g3, b2);
  });
}
function tf$1(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$1(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb$1(a2, c2), null != f2 && d2.unshift(tf$1(a2, f2, e2)), f2 = Kb$1(a2, b2), null != f2 && d2.push(tf$1(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf$1(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf$1(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb$1(c2, f2), null != k2 && g2.unshift(tf$1(c2, k2, h2))) : e2 || (k2 = Kb$1(c2, f2), null != k2 && g2.push(tf$1(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf$1 = /\r\n?/g, yf$1 = /\u0000|\uFFFD/g;
function zf$1(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf$1, "\n").replace(yf$1, "");
}
function Af$1(a2, b2, c2) {
  b2 = zf$1(b2);
  if (zf$1(a2) !== b2 && c2)
    throw Error(p$9(425));
}
function Bf$1() {
}
var Cf$1 = null, Df$1 = null;
function Ef$1(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff$1 = "function" === typeof setTimeout ? setTimeout : void 0, Gf$1 = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf$1 = "function" === typeof Promise ? Promise : void 0, Jf$1 = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf$1 ? function(a2) {
  return Hf$1.resolve(null).then(a2).catch(If$1);
} : Ff$1;
function If$1(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf$1 = "__reactProps$" + Nf, uf$1 = "__reactContainer$" + Nf, of$1 = "__reactEvents$" + Nf, Qf$1 = "__reactListeners$" + Nf, Rf$1 = "__reactHandles$" + Nf;
function Wc$1(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf$1] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb$1(a2) {
  a2 = a2[Of] || a2[uf$1];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$1(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$9(33));
}
function Db$1(a2) {
  return a2[Pf$1] || null;
}
var Sf$1 = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$7(a2) {
  0 > Tf || (a2.current = Sf$1[Tf], Sf$1[Tf] = null, Tf--);
}
function G$7(a2, b2) {
  Tf++;
  Sf$1[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$7 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$7(Wf);
  E$7(H$7);
}
function ag(a2, b2, c2) {
  if (H$7.current !== Vf)
    throw Error(p$9(168));
  G$7(H$7, b2);
  G$7(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$9(108, Ra$1(a2) || "Unknown", e2));
  return A$3({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$7.current;
  G$7(H$7, a2);
  G$7(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$9(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$7(Wf), E$7(H$7), G$7(H$7, a2)) : E$7(Wf);
  G$7(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$8;
    try {
      var c2 = eg;
      for (C$8 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac$1(fc$1, jg), e2;
    } finally {
      C$8 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc$1(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc$1(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc$1(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$6 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$6) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$9(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$6 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$9(418));
      a2.flags = a2.flags & -4097 | 2;
      I$6 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$6)
    return Fg(a2), I$6 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef$1(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$9(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$9(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$6 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua$1.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$3({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$7(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$9(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$5 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc$1(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t3 = h2;
          r2 = b2;
          y2 = c2;
          switch (t3.tag) {
            case 1:
              n2 = t3.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t3.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$3({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$9(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa$2.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$3({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb$1(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$5(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$5(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$5(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$7.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$7.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$9(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$9(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$9(284));
    if (!c2._owner)
      throw Error(p$9(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$9(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya$1)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha$1 && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va$2:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa$2:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha$1:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb$1(b3) || Ka$1(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va$2:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa$2:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha$1:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb$1(c3) || Ka$1(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va$2:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa$2:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha$1:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb$1(d3) || Ka$1(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x3 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x3 = u2, u2 = null) : x3 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x3);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x3;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$6 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$6 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x3 = y2(u2, e3, w2, h3[w2], k3), null !== x3 && (a2 && null !== x3.alternate && u2.delete(null === x3.key ? w2 : x3.key), g3 = f2(x3, g3, w2), null === m3 ? l3 = x3 : m3.sibling = x3, m3 = x3);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$6 && tg(e3, w2);
    return l3;
  }
  function t3(e3, g3, h3, k3) {
    var l3 = Ka$1(h3);
    if ("function" !== typeof l3)
      throw Error(p$9(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$9(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x3 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x3 = m3, m3 = null) : x3 = m3.sibling;
      var t4 = r2(e3, m3, n3.value, k3);
      if (null === t4) {
        null === m3 && (m3 = x3);
        break;
      }
      a2 && m3 && null === t4.alternate && b2(e3, m3);
      g3 = f2(t4, g3, w2);
      null === u2 ? l3 = t4 : u2.sibling = t4;
      u2 = t4;
      m3 = x3;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$6 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$6 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$6 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya$1 && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va$2:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya$1) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha$1 && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya$1 ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa$2:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha$1:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb$1(f3))
        return n2(a3, d3, f3, h3);
      if (Ka$1(f3))
        return t3(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$9(174));
  return a2;
}
function Ih(a2, b2) {
  G$7(Gh, b2);
  G$7(Fh, a2);
  G$7(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb$1(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb$1(b2, a2);
  }
  E$7(Eh);
  G$7(Eh, b2);
}
function Jh() {
  E$7(Eh);
  E$7(Fh);
  E$7(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb$1(b2, a2.type);
  b2 !== c2 && (G$7(Fh, a2), G$7(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$7(Eh), E$7(Fh));
}
var M$3 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua$1.ReactCurrentDispatcher, Qh = ua$1.ReactCurrentBatchConfig, Rh = 0, N$4 = null, O$4 = null, P$3 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$3() {
  throw Error(p$9(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f2) {
  Rh = f2;
  N$4 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$9(301));
      f2 += 1;
      P$3 = O$4 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O$4 && null !== O$4.next;
  Rh = 0;
  P$3 = O$4 = N$4 = null;
  Sh = false;
  if (b2)
    throw Error(p$9(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$3 ? N$4.memoizedState = P$3 = a2 : P$3 = P$3.next = a2;
  return P$3;
}
function di() {
  if (null === O$4) {
    var a2 = N$4.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$4.next;
  var b2 = null === P$3 ? N$4.memoizedState : P$3.next;
  if (null !== b2)
    P$3 = b2, O$4 = a2;
  else {
    if (null === a2)
      throw Error(p$9(310));
    O$4 = a2;
    a2 = { memoizedState: O$4.memoizedState, baseState: O$4.baseState, baseQueue: O$4.baseQueue, queue: O$4.queue, next: null };
    null === P$3 ? N$4.memoizedState = P$3 = a2 : P$3 = P$3.next = a2;
  }
  return P$3;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$9(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$4, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$4.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N$4.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$9(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N$4, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$3 && P$3.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R$4)
      throw Error(p$9(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$4.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$4.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N$4, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$4.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$4.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d2) {
  var e2 = ci();
  N$4.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$4) {
    var g2 = O$4.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N$4.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He(c2, b2) || (c2 = yc$1(), N$4.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C$8;
  C$8 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$8 = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L$5();
    mh(c2, a2, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L$5(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N$4 || null !== b2 && b2 === N$4;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc$1(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q$3, useContext: Q$3, useEffect: Q$3, useImperativeHandle: Q$3, useInsertionEffect: Q$3, useLayoutEffect: Q$3, useMemo: Q$3, useReducer: Q$3, useRef: Q$3, useState: Q$3, useDebugValue: Q$3, useDeferredValue: Q$3, useTransition: Q$3, useMutableSource: Q$3, useSyncExternalStore: Q$3, useId: Q$3, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N$4, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$4, e2 = ci();
  if (I$6) {
    if (void 0 === c2)
      throw Error(p$9(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$4)
      throw Error(p$9(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b2 = R$4.identifierPrefix;
  if (I$6) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc$1(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di();
    return Di(b2, O$4.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di();
  return null === O$4 ? b2.memoizedState = a2 : Di(b2, O$4.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b2 = di().memoizedState;
  return [a2, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa$1(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua$1.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$6 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$7(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$7(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$7(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$7(fj, gj), gj |= d2;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$7.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$6 && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$7.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$7.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i(a2, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$3.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G$7(M$3, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$9(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$9(419));
    d2 = Li(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R$4;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$9(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$6 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M$3.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$7(M$3, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$9(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$7(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$7(M$3, M$3.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$7(M$3, M$3.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$7(M$3, M$3.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$7(M$3, M$3.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya$1(a2, e2);
        d2 = Ya$1(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$3({}, e2, { value: void 0 });
        d2 = A$3({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb$1(a2, e2);
        d2 = gb$1(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf$1);
    }
    ub$1(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea$3.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea$3.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$6("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$6)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$4(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$4(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$4(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$7(Wf);
      E$7(H$7);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$4(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$9(166));
          S$4(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf$1] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$6("cancel", d2);
              D$6("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$6("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf$1.length; e2++)
                D$6(lf$1[e2], d2);
              break;
            case "source":
              D$6("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$6(
                "error",
                d2
              );
              D$6("load", d2);
              break;
            case "details":
              D$6("toggle", d2);
              break;
            case "input":
              Za$1(d2, f2);
              D$6("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$6("invalid", d2);
              break;
            case "textarea":
              hb$1(d2, f2), D$6("invalid", d2);
          }
          ub$1(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af$1(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af$1(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea$3.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$6("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db$1(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb$1(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf$1);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb$1(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf$1] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb$1(c2, d2);
            switch (c2) {
              case "dialog":
                D$6("cancel", a2);
                D$6("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$6("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf$1.length; e2++)
                  D$6(lf$1[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$6("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$6(
                  "error",
                  a2
                );
                D$6("load", a2);
                e2 = d2;
                break;
              case "details":
                D$6("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za$1(a2, d2);
                e2 = Ya$1(a2, d2);
                D$6("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$3({}, d2, { value: void 0 });
                D$6("invalid", a2);
                break;
              case "textarea":
                hb$1(a2, d2);
                e2 = gb$1(a2, d2);
                D$6("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub$1(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb$1(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea$3.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$6("scroll", a2) : null != k2 && ta$2(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db$1(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb$1(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa$1(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb$1(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb$1(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf$1);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$4(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$9(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af$1(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af$1(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$4(b2);
      return null;
    case 13:
      E$7(M$3);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$6 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$9(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$9(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$4(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$3.current & 1) ? 0 === T$4 && (T$4 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$4(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf$1(b2.stateNode.containerInfo), S$4(b2), null;
    case 10:
      return Rg(b2.type._context), S$4(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$4(b2), null;
    case 19:
      E$7(M$3);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$4(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$4 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$7(M$3, M$3.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$9() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$6)
              return S$4(b2), null;
          } else
            2 * B$9() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$9(), b2.sibling = null, c2 = M$3.current, G$7(M$3, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$4(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$4(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$4(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$9(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$7(Wf), E$7(H$7), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$7(M$3);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$9(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$7(M$3), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$4 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$2 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$3(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$3(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf$1 = dd;
  a2 = Me();
  if (Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df$1 = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$2 = b2; null !== V$2; )
    if (b2 = V$2, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$2 = a2;
    else
      for (; null !== V$2; ) {
        b2 = V$2;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t3 = n2.memoizedProps, J2 = n2.memoizedState, x3 = b2.stateNode, w2 = x3.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t3 : Lg(b2.type, t3), J2);
                  x3.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$9(163));
            }
        } catch (F2) {
          W$3(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$2 = a2;
          break;
        }
        V$2 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf$1], delete b2[of$1], delete b2[Qf$1], delete b2[Rf$1]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf$1));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$2 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc$1 && "function" === typeof lc$1.onCommitFiberUnmount)
    try {
      lc$1.onCommitFiberUnmount(kc$1, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$4 || Mj(c2, b2);
    case 6:
      var d2 = X$2, e2 = Yj;
      X$2 = null;
      Zj(a2, b2, c2);
      X$2 = d2;
      Yj = e2;
      null !== X$2 && (Yj ? (a2 = X$2, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$2.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$2 && (Yj ? (a2 = X$2, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$2, c2.stateNode));
      break;
    case 4:
      d2 = X$2;
      e2 = Yj;
      X$2 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$2 = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$4 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$4 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$3(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$4 = (d2 = U$4) || null !== c2.memoizedState, Zj(a2, b2, c2), U$4 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$2 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$2 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$2 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$2)
          throw Error(p$9(160));
        ak(f2, g2, e2);
        X$2 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$3(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t3) {
          W$3(a2, a2.return, t3);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t3) {
          W$3(a2, a2.return, t3);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t3) {
          W$3(a2, a2.return, t3);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab$1(e2, f2);
            vb$1(h2, g2);
            var l2 = vb$1(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb$1(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta$2(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb$1(e2, f2);
                break;
              case "textarea":
                ib$1(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb$1(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb$1(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb$1(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf$1] = f2;
          } catch (t3) {
            W$3(a2, a2.return, t3);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$9(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t3) {
          W$3(a2, a2.return, t3);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t3) {
          W$3(a2, a2.return, t3);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$9()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$4 = (l2 = U$4) || m2, dk(b2, a2), U$4 = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$2 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$2 = m2; null !== V$2; ) {
              r2 = V$2;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t3) {
                      W$3(d2, c2, t3);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$2 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb$1("display", g2));
                } catch (t3) {
                  W$3(a2, a2.return, t3);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t3) {
                  W$3(a2, a2.return, t3);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$9(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$9(161));
      }
    } catch (k2) {
      W$3(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$2 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$2; ) {
    var e2 = V$2, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$4;
        h2 = Kj;
        var l2 = U$4;
        Kj = g2;
        if ((U$4 = k2) && !l2)
          for (V$2 = e2; null !== V$2; )
            g2 = V$2, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$2 = k2) : kk(e2);
        for (; null !== f2; )
          V$2 = f2, jk(f2), f2 = f2.sibling;
        V$2 = e2;
        Kj = h2;
        U$4 = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$2 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$4 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$4)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$9(163));
          }
        U$4 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$3(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$3(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$3(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$3(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$3(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$3(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$2 = h2;
      break;
    }
    V$2 = b2.return;
  }
}
var mk = Math.ceil, nk = ua$1.ReactCurrentDispatcher, ok$1 = ua$1.ReactCurrentOwner, pk = ua$1.ReactCurrentBatchConfig, K$5 = 0, R$4 = null, Y$2 = null, Z$2 = 0, gj = 0, fj = Uf(0), T$4 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$5() {
  return 0 !== (K$5 & 6) ? B$9() : -1 !== Bk ? Bk : Bk = B$9();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$5 & 2) && 0 !== Z$2)
    return Z$2 & -Z$2;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc$1()), Ck;
  a2 = C$8;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd$1(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$9(185));
  Ac$1(a2, c2, d2);
  if (0 === (K$5 & 2) || a2 !== R$4)
    a2 === R$4 && (0 === (K$5 & 2) && (rk |= c2), 4 === T$4 && Dk(a2, Z$2)), Ek(a2, d2), 1 === c2 && 0 === K$5 && 0 === (b2.mode & 1) && (Hj = B$9() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc$1(a2, b2);
  var d2 = uc$1(a2, a2 === R$4 ? Z$2 : 0);
  if (0 === d2)
    null !== c2 && bc$1(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc$1(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf$1(function() {
        0 === (K$5 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc$1(d2)) {
        case 1:
          c2 = fc$1;
          break;
        case 4:
          c2 = gc$1;
          break;
        case 16:
          c2 = hc$1;
          break;
        case 536870912:
          c2 = jc$1;
          break;
        default:
          c2 = hc$1;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$5 & 6))
    throw Error(p$9(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc$1(a2, a2 === R$4 ? Z$2 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K$5;
    K$5 |= 2;
    var f2 = Kk();
    if (R$4 !== a2 || Z$2 !== b2)
      vk = null, Hj = B$9() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$5 = e2;
    null !== Y$2 ? b2 = 0 : (R$4 = null, Z$2 = 0, b2 = T$4);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc$1(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$9()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc$1(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$9()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$9(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$9(), 10 < b2)) {
            if (0 !== uc$1(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L$5();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff$1(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc$1(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B$9() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff$1(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$9(329));
      }
    }
  }
  Ek(a2, B$9());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc$1(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$5 & 6))
    throw Error(p$9(327));
  Ik();
  var b2 = uc$1(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$9()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc$1(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$9()), c2;
  if (6 === c2)
    throw Error(p$9(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$9());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$5;
  K$5 |= 1;
  try {
    return a2(b2);
  } finally {
    K$5 = c2, 0 === K$5 && (Hj = B$9() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$5 & 6) && Ik();
  var b2 = K$5;
  K$5 |= 1;
  var c2 = pk.transition, d2 = C$8;
  try {
    if (pk.transition = null, C$8 = 1, a2)
      return a2();
  } finally {
    C$8 = d2, pk.transition = c2, K$5 = b2, 0 === (K$5 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$7(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf$1(c2));
  if (null !== Y$2)
    for (c2 = Y$2.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$7(Wf);
          E$7(H$7);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$7(M$3);
          break;
        case 19:
          E$7(M$3);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$4 = a2;
  Y$2 = a2 = wh(a2.current, null);
  Z$2 = gj = b2;
  T$4 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$2;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N$4.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$3 = O$4 = N$4 = null;
      Th = false;
      Uh = 0;
      ok$1.current = null;
      if (null === c2 || null === c2.return) {
        T$4 = 1;
        qk = b2;
        Y$2 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$2;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t3 = /* @__PURE__ */ new Set();
              t3.add(k2);
              b2.updateQueue = t3;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$9(426));
          }
        } else if (I$6 && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$4 && (T$4 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x3 = Oi(f2, k2, b2);
              fh(f2, x3);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na2) {
      b2 = na2;
      Y$2 === c2 && null !== c2 && (Y$2 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T$4 || 3 === T$4 || 2 === T$4)
    T$4 = 4;
  null === R$4 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$4, Z$2);
}
function Jk(a2, b2) {
  var c2 = K$5;
  K$5 |= 2;
  var d2 = Kk();
  if (R$4 !== a2 || Z$2 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K$5 = c2;
  nk.current = d2;
  if (null !== Y$2)
    throw Error(p$9(261));
  R$4 = null;
  Z$2 = 0;
  return T$4;
}
function Uk() {
  for (; null !== Y$2; )
    Vk(Y$2);
}
function Mk() {
  for (; null !== Y$2 && !cc$1(); )
    Vk(Y$2);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$2 = b2;
  ok$1.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$2 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$2 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$4 = 6;
        Y$2 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$2 = b2;
      return;
    }
    Y$2 = b2 = a2;
  } while (null !== b2);
  0 === T$4 && (T$4 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$8, e2 = pk.transition;
  try {
    pk.transition = null, C$8 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C$8 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$5 & 6))
    throw Error(p$9(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$9(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc$1(a2, f2);
  a2 === R$4 && (Y$2 = R$4 = null, Z$2 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc$1, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$8;
    C$8 = 1;
    var h2 = K$5;
    K$5 |= 4;
    ok$1.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe(Df$1);
    dd = !!Cf$1;
    Df$1 = Cf$1 = null;
    a2.current = c2;
    ik(c2);
    dc$1();
    K$5 = h2;
    C$8 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc$1(c2.stateNode);
  Ek(a2, B$9());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc$1(yk), b2 = pk.transition, c2 = C$8;
    try {
      pk.transition = null;
      C$8 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$5 & 6))
          throw Error(p$9(331));
        var e2 = K$5;
        K$5 |= 4;
        for (V$2 = a2.current; null !== V$2; ) {
          var f2 = V$2, g2 = f2.child;
          if (0 !== (V$2.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$2 = l2; null !== V$2; ) {
                  var m2 = V$2;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$2 = q2;
                  else
                    for (; null !== V$2; ) {
                      m2 = V$2;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$2 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$2 = r2;
                        break;
                      }
                      V$2 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t3 = n2.child;
                if (null !== t3) {
                  n2.child = null;
                  do {
                    var J2 = t3.sibling;
                    t3.sibling = null;
                    t3 = J2;
                  } while (null !== t3);
                }
              }
              V$2 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$2 = g2;
          else
            b:
              for (; null !== V$2; ) {
                f2 = V$2;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x3 = f2.sibling;
                if (null !== x3) {
                  x3.return = f2.return;
                  V$2 = x3;
                  break b;
                }
                V$2 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$2 = w2; null !== V$2; ) {
          g2 = V$2;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$2 = u2;
          else
            b:
              for (g2 = w2; null !== V$2; ) {
                h2 = V$2;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na2) {
                    W$3(h2, h2.return, na2);
                  }
                if (h2 === g2) {
                  V$2 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$2 = F2;
                  break b;
                }
                V$2 = h2.return;
              }
        }
        K$5 = e2;
        jg();
        if (lc$1 && "function" === typeof lc$1.onPostCommitFiberRoot)
          try {
            lc$1.onPostCommitFiberRoot(kc$1, a2);
          } catch (na2) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$8 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$5();
  null !== a2 && (Ac$1(a2, 1, b2), Ek(a2, b2));
}
function W$3(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$5();
          null !== b2 && (Ac$1(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$5();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$4 === a2 && (Z$2 & c2) === c2 && (4 === T$4 || 3 === T$4 && (Z$2 & 130023424) === Z$2 && 500 > B$9() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc$1, sc$1 <<= 1, 0 === (sc$1 & 130023424) && (sc$1 = 4194304)));
  var c2 = L$5();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac$1(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$9(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$6 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$7.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$6 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$9(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$9(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$9(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$9(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$6 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef$1(d2, e2) ? g2 = null : null !== f2 && Ef$1(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$7(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$9(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$9(156, b2.tag));
};
function Gk(a2, b2) {
  return ac$1(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da$2)
      return 11;
    if (a2 === Ga$1)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya$1:
          return Ah(c2.children, e2, f2, b2);
        case za$2:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa$2:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa$2, a2.lanes = f2, a2;
        case Ea$1:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea$1, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia$1:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba$2:
                g2 = 10;
                break a;
              case Ca$2:
                g2 = 9;
                break a;
              case Da$2:
                g2 = 11;
                break a;
              case Ga$1:
                g2 = 14;
                break a;
              case Ha$1:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$9(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia$1;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc$1(0);
  this.expirationTimes = zc$1(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc$1(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa$2, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb$1(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$9(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$9(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$5();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac$1(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L$5(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g2);
  null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$9(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf$1] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc$1();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc$1.length && 0 !== b2 && b2 < Qc$1[c2].priority; c2++)
      ;
    Qc$1.splice(c2, 0, a2);
    0 === c2 && Vc$1(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf$1] = g2.current;
    sf$1(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf$1] = k2.current;
  sf$1(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
Ec$1 = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc$1(b2.pendingLanes);
        0 !== c2 && (Cc$1(b2, c2 | 1), Ek(b2, B$9()), 0 === (K$5 & 6) && (Hj = B$9() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$5();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc$1 = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$5();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc$1 = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L$5();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc$1 = function() {
  return C$8;
};
Ic$1 = function(a2, b2) {
  var c2 = C$8;
  try {
    return C$8 = a2, b2();
  } finally {
    C$8 = c2;
  }
};
yb$1 = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb$1(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db$1(d2);
            if (!e2)
              throw Error(p$9(90));
            Wa$1(d2);
            bb$1(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib$1(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb$1(a2, !!c2.multiple, b2, false);
  }
};
Gb$1 = Rk;
Hb$1 = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb$1, ue$1, Db$1, Eb$1, Fb$1, Rk] }, ul = { findFiberByHostInstance: Wc$1, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua$1.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb$1(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc$1 = wl.inject(vl), lc$1 = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$9(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$9(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf$1] = b2.current;
  sf$1(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$9(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$9(268, a2));
  }
  a2 = Zb$1(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$9(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$9(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf$1] = b2.current;
  sf$1(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$9(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$9(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf$1] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$9(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$9(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var m$9 = reactDomExports;
{
  client.createRoot = m$9.createRoot;
  client.hydrateRoot = m$9.hydrateRoot;
}
const index$1 = "";
const ActionButtonsRow = ({ ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(NewNoteButton, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteNoteButton, {})
  ] });
};
const CLASS_PART_SEPARATOR = "-";
function createClassUtils(config) {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  function getClassGroupId(className) {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
}
const arbitraryPropertyRegex = /^\[(.+)\]$/;
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap(config) {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
}
function getPart(classPartObject, path) {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  function update(key, value) {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  }
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
}
const IMPORTANT_MODIFIER = "!";
function createSplitModifiers(config) {
  const separator = config.separator;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  return function splitModifiers(className) {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
}
function createConfigUtils(config) {
  return {
    cache: createLruCache(config.cacheSize),
    splitModifiers: createSplitModifiers(config),
    ...createClassUtils(config)
  };
}
const SPLIT_CLASSES_REGEX = /\s+/;
function mergeClassList(classList, configUtils) {
  const {
    splitModifiers,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX).map((originalClassName) => {
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = splitModifiers(originalClassName);
    let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter((parsed) => {
    if (!parsed.isTailwindClass) {
      return true;
    }
    const {
      modifierId,
      classGroupId,
      hasPostfixModifier
    } = parsed;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach((group) => classGroupsInConflict.add(modifierId + group));
    return true;
  }).reverse().map((parsed) => parsed.originalClassName).join(" ");
}
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string2 = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string2 && (string2 += " ");
        string2 += resolvedValue;
      }
    }
  }
  return string2;
}
function toValue(mix) {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string2 = "";
  for (let k2 = 0; k2 < mix.length; k2++) {
    if (mix[k2]) {
      if (resolvedValue = toValue(mix[k2])) {
        string2 && (string2 += " ");
        string2 += resolvedValue;
      }
    }
  }
  return string2;
}
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
function fromTheme(key) {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
const fractionRegex = /^\d+\/\d+$/;
const stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isNumber(value) {
  return Boolean(value) && !Number.isNaN(Number(value));
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, "number", isNumber);
}
function isInteger(value) {
  return Boolean(value) && Number.isInteger(Number(value));
}
function isPercent(value) {
  return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, sizeLabels, isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, "position", isNever);
}
const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
function isArbitraryImage(value) {
  return getIsArbitraryValue(value, imageLabels, isImage);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, "", isShadow);
}
function isAny() {
  return true;
}
function getIsArbitraryValue(value, label, testValue) {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly(value) {
  return lengthUnitRegex.test(value);
}
function isNever() {
  return false;
}
function isShadow(value) {
  return shadowRegex.test(value);
}
function isImage(value) {
  return imageRegex.test(value);
}
function getDefaultConfig() {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumber = () => [isNumber, isArbitraryNumber];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": getBlendModes()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
const RootLayout = ({ children, className, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: twMerge("flex flex-row h-screen", className), ...props, children });
};
const Sidebar = ({ className, children, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "aside",
    {
      className: twMerge("w-[250px] mt-10 h-[100vh + 10px] overflow-auto", className),
      ...props,
      children
    }
  );
};
const Content = reactExports.forwardRef(
  ({ children, className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: twMerge("flex-1 overflow-auto", className), ...props, children })
);
Content.displayName = "Content";
const ActionButton = ({ className, children, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      className: twMerge(
        "px-2 py-1 rounded-md border border-zinc-400/50 hover:bg-zinc-600/50 transition-colors duration-100",
        className
      ),
      ...props,
      children
    }
  );
};
let keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString: () => key
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = function(get) {
      return get(this);
    };
    config.write = function(get, set, arg) {
      return set(
        this,
        typeof arg === "function" ? arg(get(this)) : arg
      );
    };
  }
  if (write) {
    config.write = write;
  }
  return config;
}
const hasInitialValue = (atom2) => "init" in atom2;
const isActuallyWritableAtom = (atom2) => !!atom2.write;
const cancelPromiseMap = /* @__PURE__ */ new WeakMap();
const registerCancelPromise = (promise, cancel) => {
  cancelPromiseMap.set(promise, cancel);
  promise.catch(() => {
  }).finally(() => cancelPromiseMap.delete(promise));
};
const cancelPromise = (promise, next) => {
  const cancel = cancelPromiseMap.get(promise);
  if (cancel) {
    cancelPromiseMap.delete(promise);
    cancel(next);
  }
};
const resolvePromise = (promise, value) => {
  promise.status = "fulfilled";
  promise.value = value;
};
const rejectPromise = (promise, e2) => {
  promise.status = "rejected";
  promise.reason = e2;
};
const isPromiseLike$1 = (x3) => typeof (x3 == null ? void 0 : x3.then) === "function";
const isEqualAtomValue = (a2, b2) => !!a2 && "v" in a2 && "v" in b2 && Object.is(a2.v, b2.v);
const isEqualAtomError = (a2, b2) => !!a2 && "e" in a2 && "e" in b2 && Object.is(a2.e, b2.e);
const hasPromiseAtomValue = (a2) => !!a2 && "v" in a2 && a2.v instanceof Promise;
const isEqualPromiseAtomValue = (a2, b2) => "v" in a2 && "v" in b2 && a2.v.orig && a2.v.orig === b2.v.orig;
const returnAtomValue = (atomState) => {
  if ("e" in atomState) {
    throw atomState.e;
  }
  return atomState.v;
};
const createStore = () => {
  const atomStateMap = /* @__PURE__ */ new WeakMap();
  const mountedMap = /* @__PURE__ */ new WeakMap();
  const pendingMap = /* @__PURE__ */ new Map();
  let storeListenersRev2;
  let mountedAtoms;
  if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
    storeListenersRev2 = /* @__PURE__ */ new Set();
    mountedAtoms = /* @__PURE__ */ new Set();
  }
  const getAtomState = (atom2) => atomStateMap.get(atom2);
  const setAtomState = (atom2, atomState) => {
    if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
      Object.freeze(atomState);
    }
    const prevAtomState = atomStateMap.get(atom2);
    atomStateMap.set(atom2, atomState);
    if (!pendingMap.has(atom2)) {
      pendingMap.set(atom2, prevAtomState);
    }
    if (hasPromiseAtomValue(prevAtomState)) {
      const next = "v" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);
      if (prevAtomState.v !== next) {
        cancelPromise(prevAtomState.v, next);
      }
    }
  };
  const updateDependencies = (atom2, nextAtomState, nextDependencies) => {
    const dependencies = /* @__PURE__ */ new Map();
    let changed = false;
    nextDependencies.forEach((aState, a2) => {
      if (!aState && a2 === atom2) {
        aState = nextAtomState;
      }
      if (aState) {
        dependencies.set(a2, aState);
        if (nextAtomState.d.get(a2) !== aState) {
          changed = true;
        }
      } else if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
        console.warn("[Bug] atom state not found");
      }
    });
    if (changed || nextAtomState.d.size !== dependencies.size) {
      nextAtomState.d = dependencies;
    }
  };
  const setAtomValue = (atom2, value, nextDependencies) => {
    const prevAtomState = getAtomState(atom2);
    const nextAtomState = {
      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),
      v: value
    };
    if (nextDependencies) {
      updateDependencies(atom2, nextAtomState, nextDependencies);
    }
    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {
      return prevAtomState;
    }
    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {
      if (prevAtomState.d === nextAtomState.d) {
        return prevAtomState;
      } else {
        nextAtomState.v = prevAtomState.v;
      }
    }
    setAtomState(atom2, nextAtomState);
    return nextAtomState;
  };
  const setAtomValueOrPromise = (atom2, valueOrPromise, nextDependencies, abortPromise) => {
    if (isPromiseLike$1(valueOrPromise)) {
      let continuePromise;
      const updatePromiseDependencies = () => {
        const prevAtomState = getAtomState(atom2);
        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {
          return;
        }
        const nextAtomState = setAtomValue(
          atom2,
          promise,
          nextDependencies
        );
        if (mountedMap.has(atom2) && prevAtomState.d !== nextAtomState.d) {
          mountDependencies(atom2, nextAtomState, prevAtomState.d);
        }
      };
      const promise = new Promise((resolve, reject) => {
        let settled = false;
        valueOrPromise.then(
          (v3) => {
            if (!settled) {
              settled = true;
              resolvePromise(promise, v3);
              resolve(v3);
              updatePromiseDependencies();
            }
          },
          (e2) => {
            if (!settled) {
              settled = true;
              rejectPromise(promise, e2);
              reject(e2);
              updatePromiseDependencies();
            }
          }
        );
        continuePromise = (next) => {
          if (!settled) {
            settled = true;
            next.then(
              (v3) => resolvePromise(promise, v3),
              (e2) => rejectPromise(promise, e2)
            );
            resolve(next);
          }
        };
      });
      promise.orig = valueOrPromise;
      promise.status = "pending";
      registerCancelPromise(promise, (next) => {
        if (next) {
          continuePromise(next);
        }
        abortPromise == null ? void 0 : abortPromise();
      });
      return setAtomValue(atom2, promise, nextDependencies);
    }
    return setAtomValue(atom2, valueOrPromise, nextDependencies);
  };
  const setAtomError = (atom2, error, nextDependencies) => {
    const prevAtomState = getAtomState(atom2);
    const nextAtomState = {
      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),
      e: error
    };
    if (nextDependencies) {
      updateDependencies(atom2, nextAtomState, nextDependencies);
    }
    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {
      return prevAtomState;
    }
    setAtomState(atom2, nextAtomState);
    return nextAtomState;
  };
  const readAtomState = (atom2, force) => {
    const atomState = getAtomState(atom2);
    if (!force && atomState) {
      if (mountedMap.has(atom2)) {
        return atomState;
      }
      if (Array.from(atomState.d).every(([a2, s]) => {
        if (a2 === atom2) {
          return true;
        }
        const aState = readAtomState(a2);
        return aState === s || isEqualAtomValue(aState, s);
      })) {
        return atomState;
      }
    }
    const nextDependencies = /* @__PURE__ */ new Map();
    let isSync = true;
    const getter = (a2) => {
      if (a2 === atom2) {
        const aState2 = getAtomState(a2);
        if (aState2) {
          nextDependencies.set(a2, aState2);
          return returnAtomValue(aState2);
        }
        if (hasInitialValue(a2)) {
          nextDependencies.set(a2, void 0);
          return a2.init;
        }
        throw new Error("no atom init");
      }
      const aState = readAtomState(a2);
      nextDependencies.set(a2, aState);
      return returnAtomValue(aState);
    };
    let controller;
    let setSelf;
    const options = {
      get signal() {
        if (!controller) {
          controller = new AbortController();
        }
        return controller.signal;
      },
      get setSelf() {
        if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && !isActuallyWritableAtom(atom2)) {
          console.warn("setSelf function cannot be used with read-only atom");
        }
        if (!setSelf && isActuallyWritableAtom(atom2)) {
          setSelf = (...args) => {
            if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && isSync) {
              console.warn("setSelf function cannot be called in sync");
            }
            if (!isSync) {
              return writeAtom(atom2, ...args);
            }
          };
        }
        return setSelf;
      }
    };
    try {
      const valueOrPromise = atom2.read(getter, options);
      return setAtomValueOrPromise(
        atom2,
        valueOrPromise,
        nextDependencies,
        () => controller == null ? void 0 : controller.abort()
      );
    } catch (error) {
      return setAtomError(atom2, error, nextDependencies);
    } finally {
      isSync = false;
    }
  };
  const readAtom = (atom2) => returnAtomValue(readAtomState(atom2));
  const addAtom = (atom2) => {
    let mounted = mountedMap.get(atom2);
    if (!mounted) {
      mounted = mountAtom(atom2);
    }
    return mounted;
  };
  const canUnmountAtom = (atom2, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom2));
  const delAtom = (atom2) => {
    const mounted = mountedMap.get(atom2);
    if (mounted && canUnmountAtom(atom2, mounted)) {
      unmountAtom(atom2);
    }
  };
  const recomputeDependents = (atom2) => {
    const dependencyMap = /* @__PURE__ */ new Map();
    const dirtyMap = /* @__PURE__ */ new WeakMap();
    const getDependents = (a2) => {
      var _a;
      const dependents = new Set((_a = mountedMap.get(a2)) == null ? void 0 : _a.t);
      pendingMap.forEach((_, pendingAtom) => {
        var _a2;
        if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a2)) {
          dependents.add(pendingAtom);
        }
      });
      return dependents;
    };
    const loop1 = (a2) => {
      getDependents(a2).forEach((dependent) => {
        if (dependent !== a2) {
          dependencyMap.set(
            dependent,
            (dependencyMap.get(dependent) || /* @__PURE__ */ new Set()).add(a2)
          );
          dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);
          loop1(dependent);
        }
      });
    };
    loop1(atom2);
    const loop2 = (a2) => {
      getDependents(a2).forEach((dependent) => {
        var _a;
        if (dependent !== a2) {
          let dirtyCount = dirtyMap.get(dependent);
          if (dirtyCount) {
            dirtyMap.set(dependent, --dirtyCount);
          }
          if (!dirtyCount) {
            let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);
            if (isChanged) {
              const prevAtomState = getAtomState(dependent);
              const nextAtomState = readAtomState(dependent, true);
              isChanged = !isEqualAtomValue(prevAtomState, nextAtomState);
            }
            if (!isChanged) {
              dependencyMap.forEach((s) => s.delete(dependent));
            }
          }
          loop2(dependent);
        }
      });
    };
    loop2(atom2);
  };
  const writeAtomState = (atom2, ...args) => {
    let isSync = true;
    const getter = (a2) => returnAtomValue(readAtomState(a2));
    const setter = (a2, ...args2) => {
      let r2;
      if (a2 === atom2) {
        if (!hasInitialValue(a2)) {
          throw new Error("atom not writable");
        }
        const prevAtomState = getAtomState(a2);
        const nextAtomState = setAtomValueOrPromise(a2, args2[0]);
        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {
          recomputeDependents(a2);
        }
      } else {
        r2 = writeAtomState(a2, ...args2);
      }
      if (!isSync) {
        const flushed = flushPending();
        if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
          storeListenersRev2.forEach(
            (l2) => l2({ type: "async-write", flushed })
          );
        }
      }
      return r2;
    };
    const result = atom2.write(getter, setter, ...args);
    isSync = false;
    return result;
  };
  const writeAtom = (atom2, ...args) => {
    const result = writeAtomState(atom2, ...args);
    const flushed = flushPending();
    if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
      storeListenersRev2.forEach(
        (l2) => l2({ type: "write", flushed })
      );
    }
    return result;
  };
  const mountAtom = (atom2, initialDependent, onMountQueue) => {
    var _a;
    const queue = onMountQueue || [];
    (_a = getAtomState(atom2)) == null ? void 0 : _a.d.forEach((_, a2) => {
      const aMounted = mountedMap.get(a2);
      if (aMounted) {
        aMounted.t.add(atom2);
      } else {
        if (a2 !== atom2) {
          mountAtom(a2, atom2, queue);
        }
      }
    });
    readAtomState(atom2);
    const mounted = {
      t: new Set(initialDependent && [initialDependent]),
      l: /* @__PURE__ */ new Set()
    };
    mountedMap.set(atom2, mounted);
    if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
      mountedAtoms.add(atom2);
    }
    if (isActuallyWritableAtom(atom2) && atom2.onMount) {
      const { onMount } = atom2;
      queue.push(() => {
        const onUnmount = onMount((...args) => writeAtom(atom2, ...args));
        if (onUnmount) {
          mounted.u = onUnmount;
        }
      });
    }
    if (!onMountQueue) {
      queue.forEach((f2) => f2());
    }
    return mounted;
  };
  const unmountAtom = (atom2) => {
    var _a;
    const onUnmount = (_a = mountedMap.get(atom2)) == null ? void 0 : _a.u;
    if (onUnmount) {
      onUnmount();
    }
    mountedMap.delete(atom2);
    if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
      mountedAtoms.delete(atom2);
    }
    const atomState = getAtomState(atom2);
    if (atomState) {
      if (hasPromiseAtomValue(atomState)) {
        cancelPromise(atomState.v);
      }
      atomState.d.forEach((_, a2) => {
        if (a2 !== atom2) {
          const mounted = mountedMap.get(a2);
          if (mounted) {
            mounted.t.delete(atom2);
            if (canUnmountAtom(a2, mounted)) {
              unmountAtom(a2);
            }
          }
        }
      });
    } else if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
      console.warn("[Bug] could not find atom state to unmount", atom2);
    }
  };
  const mountDependencies = (atom2, atomState, prevDependencies) => {
    const depSet = new Set(atomState.d.keys());
    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a2) => {
      if (depSet.has(a2)) {
        depSet.delete(a2);
        return;
      }
      const mounted = mountedMap.get(a2);
      if (mounted) {
        mounted.t.delete(atom2);
        if (canUnmountAtom(a2, mounted)) {
          unmountAtom(a2);
        }
      }
    });
    depSet.forEach((a2) => {
      const mounted = mountedMap.get(a2);
      if (mounted) {
        mounted.t.add(atom2);
      } else if (mountedMap.has(atom2)) {
        mountAtom(a2, atom2);
      }
    });
  };
  const flushPending = () => {
    let flushed;
    if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
      flushed = /* @__PURE__ */ new Set();
    }
    while (pendingMap.size) {
      const pending = Array.from(pendingMap);
      pendingMap.clear();
      pending.forEach(([atom2, prevAtomState]) => {
        const atomState = getAtomState(atom2);
        if (atomState) {
          const mounted = mountedMap.get(atom2);
          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
            mountDependencies(atom2, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
          }
          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.
          // Maybe we could `mountDependencies` in `setAtomState`?
          (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {
            mounted.l.forEach((listener) => listener());
            if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
              flushed.add(atom2);
            }
          }
        } else if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
          console.warn("[Bug] no atom state to flush");
        }
      });
    }
    if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
      return flushed;
    }
  };
  const subscribeAtom = (atom2, listener) => {
    const mounted = addAtom(atom2);
    const flushed = flushPending();
    const listeners = mounted.l;
    listeners.add(listener);
    if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
      storeListenersRev2.forEach(
        (l2) => l2({ type: "sub", flushed })
      );
    }
    return () => {
      listeners.delete(listener);
      delAtom(atom2);
      if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
        storeListenersRev2.forEach((l2) => l2({ type: "unsub" }));
      }
    };
  };
  if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
    return {
      get: readAtom,
      set: writeAtom,
      sub: subscribeAtom,
      // store dev methods (these are tentative and subject to change without notice)
      dev_subscribe_store: (l2, rev) => {
        if (rev !== 2) {
          throw new Error("The current StoreListener revision is 2.");
        }
        storeListenersRev2.add(l2);
        return () => {
          storeListenersRev2.delete(l2);
        };
      },
      dev_get_mounted_atoms: () => mountedAtoms.values(),
      dev_get_atom_state: (a2) => atomStateMap.get(a2),
      dev_get_mounted: (a2) => mountedMap.get(a2),
      dev_restore_atoms: (values) => {
        for (const [atom2, valueOrPromise] of values) {
          if (hasInitialValue(atom2)) {
            setAtomValueOrPromise(atom2, valueOrPromise);
            recomputeDependents(atom2);
          }
        }
        const flushed = flushPending();
        storeListenersRev2.forEach(
          (l2) => l2({ type: "restore", flushed })
        );
      }
    };
  }
  return {
    get: readAtom,
    set: writeAtom,
    sub: subscribeAtom
  };
};
let defaultStore;
if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === "number") {
    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;
  } else {
    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;
  }
}
const getDefaultStore = () => {
  if (!defaultStore) {
    if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {
      console.warn(
        "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
      );
    }
    defaultStore = createStore();
  }
  return defaultStore;
};
const StoreContext = reactExports.createContext(void 0);
const useStore = (options) => {
  const store = reactExports.useContext(StoreContext);
  return (options == null ? void 0 : options.store) || store || getDefaultStore();
};
const isPromiseLike = (x3) => typeof (x3 == null ? void 0 : x3.then) === "function";
const use = React__default.use || ((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    promise.status = "pending";
    promise.then(
      (v3) => {
        promise.status = "fulfilled";
        promise.value = v3;
      },
      (e2) => {
        promise.status = "rejected";
        promise.reason = e2;
      }
    );
    throw promise;
  }
});
function useAtomValue(atom2, options) {
  const store = useStore(options);
  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = reactExports.useReducer(
    (prev) => {
      const nextValue = store.get(atom2);
      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom2) {
        return prev;
      }
      return [nextValue, store, atom2];
    },
    void 0,
    () => [store.get(atom2), store, atom2]
  );
  let value = valueFromReducer;
  if (storeFromReducer !== store || atomFromReducer !== atom2) {
    rerender();
    value = store.get(atom2);
  }
  const delay = options == null ? void 0 : options.delay;
  reactExports.useEffect(() => {
    const unsub = store.sub(atom2, () => {
      if (typeof delay === "number") {
        setTimeout(rerender, delay);
        return;
      }
      rerender();
    });
    rerender();
    return unsub;
  }, [store, atom2, delay]);
  reactExports.useDebugValue(value);
  return isPromiseLike(value) ? use(value) : value;
}
function useSetAtom(atom2, options) {
  const store = useStore(options);
  const setAtom = reactExports.useCallback(
    (...args) => {
      if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && !("write" in atom2)) {
        throw new Error("not writable atom");
      }
      return store.set(atom2, ...args);
    },
    [store, atom2]
  );
  return setAtom;
}
function useAtom(atom2, options) {
  return [
    useAtomValue(atom2, options),
    // We do wrong type assertion here, which results in throwing an error.
    useSetAtom(atom2, options)
  ];
}
const getCached = (c2, m2, k2) => (m2.has(k2) ? m2 : m2.set(k2, c2())).get(k2);
const cache1 = /* @__PURE__ */ new WeakMap();
const memo2 = (create, dep1, dep2) => {
  const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);
  return getCached(create, cache2, dep2);
};
const defaultFallback = () => void 0;
function unwrap(anAtom, fallback = defaultFallback) {
  return memo2(
    () => {
      const promiseErrorCache = /* @__PURE__ */ new WeakMap();
      const promiseResultCache = /* @__PURE__ */ new WeakMap();
      const refreshAtom = atom(0);
      if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
        refreshAtom.debugPrivate = true;
      }
      const promiseAndValueAtom = atom(
        (get, { setSelf }) => {
          get(refreshAtom);
          const prev = get(promiseAndValueAtom);
          const promise = get(anAtom);
          if (!(promise instanceof Promise)) {
            return { v: promise };
          }
          if (promise === (prev == null ? void 0 : prev.p)) {
            if (promiseErrorCache.has(promise)) {
              throw promiseErrorCache.get(promise);
            }
            if (promiseResultCache.has(promise)) {
              return {
                p: promise,
                v: promiseResultCache.get(promise)
              };
            }
          }
          if (promise !== (prev == null ? void 0 : prev.p)) {
            promise.then(
              (v3) => promiseResultCache.set(promise, v3),
              (e2) => promiseErrorCache.set(promise, e2)
            ).finally(setSelf);
          }
          if (prev && "v" in prev) {
            return { p: promise, f: fallback(prev.v), v: prev.v };
          }
          return { p: promise, f: fallback() };
        },
        (_get, set) => {
          set(refreshAtom, (c2) => c2 + 1);
        }
      );
      promiseAndValueAtom.init = void 0;
      if (({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
        promiseAndValueAtom.debugPrivate = true;
      }
      return atom(
        (get) => {
          const state = get(promiseAndValueAtom);
          if ("f" in state) {
            return state.f;
          }
          return state.v;
        },
        (_get, set, ...args) => set(anAtom, ...args)
      );
    },
    anAtom,
    fallback
  );
}
const loadNotes = async () => {
  const notes = await window.context.getNotes();
  return notes.sort((a2, b2) => b2.lastEditTime - a2.lastEditTime);
};
const notesAtomAsync = atom(loadNotes());
const notesAtom = unwrap(notesAtomAsync, (prev) => prev);
const selectedNoteIndexAtom = atom(null);
const selectedNoteAtomAsync = atom(async (get) => {
  const notes = get(notesAtom);
  const selectedNoteIndex = get(selectedNoteIndexAtom);
  if (selectedNoteIndex == null || !notes)
    return null;
  const selectedNote = notes[selectedNoteIndex];
  const noteContent = await window.context.readNote(selectedNote.title);
  return {
    ...selectedNote,
    content: noteContent
  };
});
const selectedNoteAtom = unwrap(
  selectedNoteAtomAsync,
  (prev) => prev ?? {
    title: "",
    content: "",
    lastEditTime: Date.now()
  }
);
const saveNoteAtom = atom(null, async (get, set, newContent) => {
  const notes = get(notesAtom);
  const selectedNote = get(selectedNoteAtom);
  if (!selectedNote || !notes)
    return;
  await window.context.writeNote(selectedNote.title, newContent);
  set(
    notesAtom,
    notes.map((note) => {
      if (note.title === selectedNote.title) {
        return {
          ...note,
          lastEditTime: Date.now()
        };
      }
      return note;
    })
  );
});
const createEmptyNoteAtom = atom(null, async (get, set) => {
  const notes = get(notesAtom);
  if (!notes)
    return;
  const title = await window.context.createNote();
  if (!title)
    return;
  const newNote = {
    title,
    lastEditTime: Date.now()
  };
  set(notesAtom, [newNote, ...notes.filter((note) => note.title !== newNote.title)]);
  set(selectedNoteIndexAtom, 0);
});
const deleteNoteAtom = atom(null, async (get, set) => {
  const notes = get(notesAtom);
  const selectedNote = get(selectedNoteAtom);
  if (!selectedNote || !notes)
    return;
  const isDeleted = await window.context.deleteNote(selectedNote.title);
  if (!isDeleted)
    return;
  set(
    notesAtom,
    notes.filter((note) => note.title !== selectedNote.title)
  );
  set(selectedNoteIndexAtom, null);
});
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = React__default.createContext && React__default.createContext(DefaultContext);
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
var __rest = globalThis && globalThis.__rest || function(s, e2) {
  var t3 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t3[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t3[p2[i]] = s[p2[i]];
    }
  return t3;
};
function Tree2Element(tree) {
  return tree && tree.map(function(node2, i) {
    return React__default.createElement(node2.tag, __assign({
      key: i
    }, node2.attr), Tree2Element(node2.child));
  });
}
function GenIcon(data) {
  return function(props) {
    return React__default.createElement(IconBase, __assign({
      attr: __assign({}, data.attr)
    }, props), Tree2Element(data.child));
  };
}
function IconBase(props) {
  var elem = function(conf) {
    var attr = props.attr, size = props.size, title = props.title, svgProps = __rest(props, ["attr", "size", "title"]);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return React__default.createElement("svg", __assign({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: __assign(__assign({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && React__default.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? React__default.createElement(IconContext.Consumer, null, function(conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}
function FaRegTrashCan(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 448 512" }, "child": [{ "tag": "path", "attr": { "d": "M170.5 51.6L151.5 80h145l-19-28.4c-1.5-2.2-4-3.6-6.7-3.6H177.1c-2.7 0-5.2 1.3-6.7 3.6zm147-26.6L354.2 80H368h48 8c13.3 0 24 10.7 24 24s-10.7 24-24 24h-8V432c0 44.2-35.8 80-80 80H112c-44.2 0-80-35.8-80-80V128H24c-13.3 0-24-10.7-24-24S10.7 80 24 80h8H80 93.8l36.7-55.1C140.9 9.4 158.4 0 177.1 0h93.7c18.7 0 36.2 9.4 46.6 24.9zM80 128V432c0 17.7 14.3 32 32 32H336c17.7 0 32-14.3 32-32V128H80zm80 64V400c0 8.8-7.2 16-16 16s-16-7.2-16-16V192c0-8.8 7.2-16 16-16s16 7.2 16 16zm80 0V400c0 8.8-7.2 16-16 16s-16-7.2-16-16V192c0-8.8 7.2-16 16-16s16 7.2 16 16zm80 0V400c0 8.8-7.2 16-16 16s-16-7.2-16-16V192c0-8.8 7.2-16 16-16s16 7.2 16 16z" } }] })(props);
}
const DeleteNoteButton = ({ ...props }) => {
  const deleteNote = useSetAtom(deleteNoteAtom);
  const handleDelete = async () => {
    await deleteNote();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButton, { onClick: handleDelete, ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaRegTrashCan, { className: "w-4 h-4 text-zinc-300" }) });
};
function LuFileSignature(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M20 19.5v.5a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8.5L18 5.5" } }, { "tag": "path", "attr": { "d": "M8 18h1" } }, { "tag": "path", "attr": { "d": "M18.42 9.61a2.1 2.1 0 1 1 2.97 2.97L16.95 17 13 18l.99-3.95 4.43-4.44Z" } }] })(props);
}
const NewNoteButton = ({ ...props }) => {
  const createEmptyNote = useSetAtom(createEmptyNoteAtom);
  const handleCreation = async () => {
    await createEmptyNote();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButton, { onClick: handleCreation, ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuFileSignature, { className: "w-4 h-4 text-zinc-300" }) });
};
const DraggableTopBar = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: "absolute inset-0 h-8 bg-transparent" });
};
const FloatingNoteTitle = ({ className, ...props }) => {
  const selectedNote = useAtomValue(selectedNoteAtom);
  if (!selectedNote)
    return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: twMerge("flex justify-center", className), ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-400", children: selectedNote.title }) });
};
const scriptRel = function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i = links.length - 1; i >= 0; i--) {
        const link3 = links[i];
        if (link3.href === dep && (!isCss || link3.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link2 = document.createElement("link");
    link2.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link2.as = "script";
      link2.crossOrigin = "";
    }
    link2.href = dep;
    document.head.appendChild(link2);
    if (isCss) {
      return new Promise((res, rej) => {
        link2.addEventListener("load", res);
        link2.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
var LexicalHistoryPlugin_prod = {};
var LexicalComposerContext_prod = {};
var d$5 = reactExports;
function e$5(a2) {
  let c2 = new URLSearchParams();
  c2.append("code", a2);
  for (let b2 = 1; b2 < arguments.length; b2++)
    c2.append("v", arguments[b2]);
  throw Error(`Minified Lexical error #${a2}; visit https://lexical.dev/docs/error?${c2} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
let f$7 = d$5.createContext(null);
LexicalComposerContext_prod.LexicalComposerContext = f$7;
LexicalComposerContext_prod.createLexicalComposerContext = function(a2, c2) {
  let b2 = null;
  null != a2 && (b2 = a2[1]);
  return { getTheme: function() {
    return null != c2 ? c2 : null != b2 ? b2.getTheme() : null;
  } };
};
LexicalComposerContext_prod.useLexicalComposerContext = function() {
  let a2 = d$5.useContext(f$7);
  null == a2 && e$5(8);
  return a2;
};
const LexicalComposerContext = LexicalComposerContext_prod;
var LexicalComposerContext_1 = LexicalComposerContext;
var LexicalHistory_prod = {};
var LexicalUtils_prod = {};
var LexicalSelection_prod = {};
var Lexical_prod = {};
let ba$2 = {}, ca$2 = {}, ea$2 = {}, fa$2 = {}, ha$2 = {}, la$1 = {}, ma$1 = {}, na$1 = {}, pa$1 = {}, qa$1 = {}, ra$1 = {}, sa$1 = {}, ta$1 = {}, ua = {}, va$1 = {}, wa$1 = {}, xa$1 = {}, za$1 = {}, Aa$1 = {}, Ba$1 = {}, Ca$1 = {}, Da$1 = {}, Ga = {}, Ha = {}, Ia = {}, Ja = {}, Ka = {}, La = {}, Ma = {}, Na = {}, Oa = {}, Pa = {}, Qa = {}, Ra = {}, Sa = {}, Ta = {};
function r$a(a2) {
  let b2 = new URLSearchParams();
  b2.append("code", a2);
  for (let c2 = 1; c2 < arguments.length; c2++)
    b2.append("v", arguments[c2]);
  throw Error(`Minified Lexical error #${a2}; visit https://lexical.dev/docs/error?${b2} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
let Ua = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement, Wa = Ua && "documentMode" in document ? document.documentMode : null, t$8 = Ua && /Mac|iPod|iPhone|iPad/.test(navigator.platform), Xa = Ua && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Ya = Ua && "InputEvent" in window && !Wa ? "getTargetRanges" in new window.InputEvent("input") : false, Za = Ua && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), $a = Ua && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, ab = Ua && /Android/.test(navigator.userAgent), bb = Ua && /^(?=.*Chrome).*/i.test(navigator.userAgent), cb = Ua && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !bb, db = Za || $a || cb ? " " : "​", eb = Xa ? " " : db, fb = /^[^A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0800-\u1fff\u200e\u2c00-\ufb1c\ufe00-\ufe6f\ufefd-\uffff]*[\u0591-\u07ff\ufb1d-\ufdfd\ufe70-\ufefc]/, gb = /^[^\u0591-\u07ff\ufb1d-\ufdfd\ufe70-\ufefc]*[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0800-\u1fff\u200e\u2c00-\ufb1c\ufe00-\ufe6f\ufefd-\uffff]/, hb = { bold: 1, code: 16, highlight: 128, italic: 2, strikethrough: 4, subscript: 32, superscript: 64, underline: 8 }, ib = { directionless: 1, unmergeable: 2 }, jb = { center: 2, end: 6, justify: 4, left: 1, right: 3, start: 5 }, kb = { 2: "center", 6: "end", 4: "justify", 1: "left", 3: "right", 5: "start" }, lb = { normal: 0, segmented: 2, token: 1 }, pb = { 0: "normal", 2: "segmented", 1: "token" }, qb = false, rb = 0;
function sb(a2) {
  rb = a2.timeStamp;
}
function tb(a2, b2, c2) {
  return b2.__lexicalLineBreak === a2 || void 0 !== a2[`__lexicalKey_${c2._key}`];
}
function ub(a2) {
  return a2.getEditorState().read(() => {
    let b2 = v$8();
    return null !== b2 ? b2.clone() : null;
  });
}
function vb(a2, b2, c2) {
  qb = true;
  let d2 = 100 < performance.now() - rb;
  try {
    w$7(a2, () => {
      let e2 = v$8() || ub(a2);
      var f2 = /* @__PURE__ */ new Map(), g2 = a2.getRootElement(), h2 = a2._editorState, k2 = a2._blockCursorElement;
      let m2 = false, p2 = "";
      for (var n2 = 0; n2 < b2.length; n2++) {
        var l2 = b2[n2], q2 = l2.type, u2 = l2.target, y2 = wb(u2, h2);
        if (!(null === y2 && u2 !== g2 || z$7(y2))) {
          if ("characterData" === q2) {
            if (l2 = d2 && B$8(y2))
              a: {
                l2 = e2;
                q2 = u2;
                var x3 = y2;
                if (C$7(l2)) {
                  var A2 = l2.anchor.getNode();
                  if (A2.is(x3) && l2.format !== A2.getFormat()) {
                    l2 = false;
                    break a;
                  }
                }
                l2 = 3 === q2.nodeType && x3.isAttached();
              }
            l2 && (x3 = xb(a2._window), q2 = l2 = null, null !== x3 && x3.anchorNode === u2 && (l2 = x3.anchorOffset, q2 = x3.focusOffset), u2 = u2.nodeValue, null !== u2 && yb(y2, u2, l2, q2, false));
          } else if ("childList" === q2) {
            m2 = true;
            q2 = l2.addedNodes;
            for (x3 = 0; x3 < q2.length; x3++) {
              A2 = q2[x3];
              var aa2 = zb(A2), da2 = A2.parentNode;
              null == da2 || A2 === k2 || null !== aa2 || "BR" === A2.nodeName && tb(A2, da2, a2) || (Xa && (aa2 = A2.innerText || A2.nodeValue) && (p2 += aa2), da2.removeChild(A2));
            }
            l2 = l2.removedNodes;
            q2 = l2.length;
            if (0 < q2) {
              x3 = 0;
              for (A2 = 0; A2 < q2; A2++)
                if (da2 = l2[A2], "BR" === da2.nodeName && tb(da2, u2, a2) || k2 === da2)
                  u2.appendChild(da2), x3++;
              q2 !== x3 && (u2 === g2 && (y2 = h2._nodeMap.get("root")), f2.set(u2, y2));
            }
          }
        }
      }
      if (0 < f2.size)
        for (let [
          Va2,
          ka2
        ] of f2)
          if (E$6(ka2))
            for (f2 = ka2.getChildrenKeys(), g2 = Va2.firstChild, h2 = 0; h2 < f2.length; h2++)
              k2 = a2.getElementByKey(f2[h2]), null !== k2 && (null == g2 ? (Va2.appendChild(k2), g2 = k2) : g2 !== k2 && Va2.replaceChild(k2, g2), g2 = g2.nextSibling);
          else
            B$8(ka2) && ka2.markDirty();
      f2 = c2.takeRecords();
      if (0 < f2.length) {
        for (g2 = 0; g2 < f2.length; g2++)
          for (k2 = f2[g2], h2 = k2.addedNodes, k2 = k2.target, n2 = 0; n2 < h2.length; n2++)
            y2 = h2[n2], u2 = y2.parentNode, null == u2 || "BR" !== y2.nodeName || tb(y2, k2, a2) || u2.removeChild(y2);
        c2.takeRecords();
      }
      null !== e2 && (m2 && (e2.dirty = true, Ab(e2)), Xa && Bb(a2) && e2.insertRawText(p2));
    });
  } finally {
    qb = false;
  }
}
function Cb(a2) {
  let b2 = a2._observer;
  if (null !== b2) {
    let c2 = b2.takeRecords();
    vb(a2, c2, b2);
  }
}
function Db(a2) {
  0 === rb && Eb(a2).addEventListener("textInput", sb, true);
  a2._observer = new MutationObserver((b2, c2) => {
    vb(a2, b2, c2);
  });
}
function Fb(a2, b2) {
  let c2 = a2.__mode, d2 = a2.__format;
  a2 = a2.__style;
  let e2 = b2.__mode, f2 = b2.__format;
  b2 = b2.__style;
  return (null === c2 || c2 === e2) && (null === d2 || d2 === f2) && (null === a2 || a2 === b2);
}
function Gb(a2, b2) {
  let c2 = a2.mergeWithSibling(b2), d2 = F$6()._normalizedNodes;
  d2.add(a2.__key);
  d2.add(b2.__key);
  return c2;
}
function Hb(a2) {
  if ("" === a2.__text && a2.isSimpleText() && !a2.isUnmergeable())
    a2.remove();
  else {
    for (var b2; null !== (b2 = a2.getPreviousSibling()) && B$8(b2) && b2.isSimpleText() && !b2.isUnmergeable(); )
      if ("" === b2.__text)
        b2.remove();
      else {
        Fb(b2, a2) && (a2 = Gb(b2, a2));
        break;
      }
    for (var c2; null !== (c2 = a2.getNextSibling()) && B$8(c2) && c2.isSimpleText() && !c2.isUnmergeable(); )
      if ("" === c2.__text)
        c2.remove();
      else {
        Fb(a2, c2) && Gb(a2, c2);
        break;
      }
  }
}
function Ib(a2) {
  Jb(a2.anchor);
  Jb(a2.focus);
  return a2;
}
function Jb(a2) {
  for (; "element" === a2.type; ) {
    var b2 = a2.getNode(), c2 = a2.offset;
    c2 === b2.getChildrenSize() ? (b2 = b2.getChildAtIndex(c2 - 1), c2 = true) : (b2 = b2.getChildAtIndex(c2), c2 = false);
    if (B$8(b2)) {
      a2.set(b2.__key, c2 ? b2.getTextContentSize() : 0, "text");
      break;
    } else if (!E$6(b2))
      break;
    a2.set(b2.__key, c2 ? b2.getChildrenSize() : 0, "element");
  }
}
let Kb = 1, Lb = "function" === typeof queueMicrotask ? queueMicrotask : (a2) => {
  Promise.resolve().then(a2);
};
function Mb(a2) {
  let b2 = document.activeElement;
  if (null === b2)
    return false;
  let c2 = b2.nodeName;
  return z$7(wb(a2)) && ("INPUT" === c2 || "TEXTAREA" === c2 || "true" === b2.contentEditable && null == b2.__lexicalEditor);
}
function Nb(a2, b2, c2) {
  let d2 = a2.getRootElement();
  try {
    return null !== d2 && d2.contains(b2) && d2.contains(c2) && null !== b2 && !Mb(b2) && Ob(b2) === a2;
  } catch (e2) {
    return false;
  }
}
function Ob(a2) {
  for (; null != a2; ) {
    let b2 = a2.__lexicalEditor;
    if (null != b2)
      return b2;
    a2 = Vb(a2);
  }
  return null;
}
function Wb(a2) {
  return a2.isToken() || a2.isSegmented();
}
function Xb(a2) {
  for (; null != a2; ) {
    if (3 === a2.nodeType)
      return a2;
    a2 = a2.firstChild;
  }
  return null;
}
function Yb(a2, b2, c2) {
  let d2 = hb[b2];
  if (null !== c2 && (a2 & d2) === (c2 & d2))
    return a2;
  a2 ^= d2;
  "subscript" === b2 ? a2 &= ~hb.superscript : "superscript" === b2 && (a2 &= ~hb.subscript);
  return a2;
}
function Zb(a2, b2) {
  if (null != b2)
    a2.__key = b2;
  else {
    G$6();
    99 < $b && r$a(14);
    b2 = F$6();
    var c2 = ac(), d2 = "" + Kb++;
    c2._nodeMap.set(d2, a2);
    E$6(a2) ? b2._dirtyElements.set(d2, true) : b2._dirtyLeaves.add(d2);
    b2._cloneNotNeeded.add(d2);
    b2._dirtyType = 1;
    a2.__key = d2;
  }
}
function bc(a2) {
  var b2 = a2.getParent();
  if (null !== b2) {
    let e2 = a2.getWritable();
    b2 = b2.getWritable();
    var c2 = a2.getPreviousSibling();
    a2 = a2.getNextSibling();
    if (null === c2)
      if (null !== a2) {
        var d2 = a2.getWritable();
        b2.__first = a2.__key;
        d2.__prev = null;
      } else
        b2.__first = null;
    else {
      d2 = c2.getWritable();
      if (null !== a2) {
        let f2 = a2.getWritable();
        f2.__prev = d2.__key;
        d2.__next = f2.__key;
      } else
        d2.__next = null;
      e2.__prev = null;
    }
    null === a2 ? null !== c2 ? (a2 = c2.getWritable(), b2.__last = c2.__key, a2.__next = null) : b2.__last = null : (a2 = a2.getWritable(), null !== c2 ? (c2 = c2.getWritable(), c2.__next = a2.__key, a2.__prev = c2.__key) : a2.__prev = null, e2.__next = null);
    b2.__size--;
    e2.__parent = null;
  }
}
function cc(a2) {
  99 < $b && r$a(14);
  var b2 = a2.getLatest(), c2 = b2.__parent, d2 = ac();
  let e2 = F$6(), f2 = d2._nodeMap;
  d2 = e2._dirtyElements;
  if (null !== c2)
    a:
      for (; null !== c2; ) {
        if (d2.has(c2))
          break a;
        let g2 = f2.get(c2);
        if (void 0 === g2)
          break;
        d2.set(c2, false);
        c2 = g2.__parent;
      }
  b2 = b2.__key;
  e2._dirtyType = 1;
  E$6(a2) ? d2.set(b2, true) : e2._dirtyLeaves.add(b2);
}
function H$6(a2) {
  G$6();
  var b2 = F$6();
  let c2 = b2._compositionKey;
  a2 !== c2 && (b2._compositionKey = a2, null !== c2 && (b2 = I$5(c2), null !== b2 && b2.getWritable()), null !== a2 && (a2 = I$5(a2), null !== a2 && a2.getWritable()));
}
function dc() {
  return ec() ? null : F$6()._compositionKey;
}
function I$5(a2, b2) {
  a2 = (b2 || ac())._nodeMap.get(a2);
  return void 0 === a2 ? null : a2;
}
function zb(a2, b2) {
  let c2 = F$6();
  a2 = a2[`__lexicalKey_${c2._key}`];
  return void 0 !== a2 ? I$5(a2, b2) : null;
}
function wb(a2, b2) {
  for (; null != a2; ) {
    let c2 = zb(a2, b2);
    if (null !== c2)
      return c2;
    a2 = Vb(a2);
  }
  return null;
}
function fc(a2) {
  let b2 = Object.assign({}, a2._decorators);
  return a2._pendingDecorators = b2;
}
function gc(a2) {
  return a2.read(() => J$4().getTextContent());
}
function hc(a2, b2) {
  w$7(a2, () => {
    var c2 = ac();
    if (!c2.isEmpty())
      if ("root" === b2)
        J$4().markDirty();
      else {
        c2 = c2._nodeMap;
        for (let [, d2] of c2)
          d2.markDirty();
      }
  }, null === a2._pendingEditorState ? { tag: "history-merge" } : void 0);
}
function J$4() {
  return ac()._nodeMap.get("root");
}
function Ab(a2) {
  G$6();
  let b2 = ac();
  null !== a2 && (a2.dirty = true, a2.setCachedNodes(null));
  b2._selection = a2;
}
function ic(a2) {
  var b2 = F$6(), c2;
  a: {
    for (c2 = a2; null != c2; ) {
      let d2 = c2[`__lexicalKey_${b2._key}`];
      if (void 0 !== d2) {
        c2 = d2;
        break a;
      }
      c2 = Vb(c2);
    }
    c2 = null;
  }
  return null === c2 ? (b2 = b2.getRootElement(), a2 === b2 ? I$5("root") : null) : I$5(c2);
}
function jc(a2) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(a2);
}
function kc(a2) {
  let b2 = [];
  for (; null !== a2; )
    b2.push(a2), a2 = a2._parentEditor;
  return b2;
}
function lc() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function mc(a2, b2, c2) {
  b2 = xb(b2._window);
  if (null !== b2) {
    var d2 = b2.anchorNode, { anchorOffset: e2, focusOffset: f2 } = b2;
    if (null !== d2 && (b2 = 3 === d2.nodeType ? d2.nodeValue : null, d2 = wb(d2), null !== b2 && B$8(d2))) {
      if (b2 === db && c2) {
        let g2 = c2.length;
        b2 = c2;
        f2 = e2 = g2;
      }
      null !== b2 && yb(d2, b2, e2, f2, a2);
    }
  }
}
function yb(a2, b2, c2, d2, e2) {
  let f2 = a2;
  if (f2.isAttached() && (e2 || !f2.isDirty())) {
    let m2 = f2.isComposing(), p2 = b2;
    (m2 || e2) && b2[b2.length - 1] === db && (p2 = b2.slice(0, -1));
    b2 = f2.getTextContent();
    if (e2 || p2 !== b2)
      if ("" === p2)
        if (H$6(null), Za || $a || cb)
          f2.remove();
        else {
          let n2 = F$6();
          setTimeout(() => {
            n2.update(() => {
              f2.isAttached() && f2.remove();
            });
          }, 20);
        }
      else {
        e2 = f2.getParent();
        b2 = nc();
        var g2 = f2.getTextContentSize(), h2 = dc(), k2 = f2.getKey();
        f2.isToken() || null !== h2 && k2 === h2 && !m2 || C$7(b2) && (null !== e2 && !e2.canInsertTextBefore() && 0 === b2.anchor.offset || b2.anchor.key === a2.__key && 0 === b2.anchor.offset && !f2.canInsertTextBefore() || b2.focus.key === a2.__key && b2.focus.offset === g2 && !f2.canInsertTextAfter()) ? f2.markDirty() : (a2 = v$8(), C$7(a2) && null !== c2 && null !== d2 && (a2.setTextNodeRange(f2, c2, f2, d2), f2.isSegmented() && (c2 = f2.getTextContent(), c2 = K$4(c2), f2.replace(c2), f2 = c2)), f2.setTextContent(p2));
      }
  }
}
function oc(a2, b2) {
  if (b2.isSegmented())
    return true;
  if (!a2.isCollapsed())
    return false;
  a2 = a2.anchor.offset;
  let c2 = b2.getParentOrThrow(), d2 = b2.isToken();
  return 0 === a2 ? ((a2 = !b2.canInsertTextBefore() || !c2.canInsertTextBefore() || d2) || (b2 = b2.getPreviousSibling(), a2 = (B$8(b2) || E$6(b2) && b2.isInline()) && !b2.canInsertTextAfter()), a2) : a2 === b2.getTextContentSize() ? !b2.canInsertTextAfter() || !c2.canInsertTextAfter() || d2 : false;
}
function pc(a2, b2) {
  void 0 === a2.__lexicalClassNameCache && (a2.__lexicalClassNameCache = {});
  let c2 = a2.__lexicalClassNameCache, d2 = c2[b2];
  if (void 0 !== d2)
    return d2;
  a2 = a2[b2];
  return "string" === typeof a2 ? (a2 = a2.split(" "), c2[b2] = a2) : a2;
}
function qc(a2, b2, c2, d2, e2) {
  0 !== c2.size && (c2 = d2.__type, d2 = d2.__key, b2 = b2.get(c2), void 0 === b2 && r$a(33, c2), c2 = b2.klass, b2 = a2.get(c2), void 0 === b2 && (b2 = /* @__PURE__ */ new Map(), a2.set(c2, b2)), a2 = b2.get(d2), c2 = "destroyed" === a2 && "created" === e2, (void 0 === a2 || c2) && b2.set(d2, c2 ? "updated" : e2));
}
function rc(a2, b2, c2) {
  let d2 = a2.getParent(), e2 = c2;
  null !== d2 && (b2 && 0 === c2 ? (e2 = a2.getIndexWithinParent(), a2 = d2) : b2 || c2 !== a2.getChildrenSize() || (e2 = a2.getIndexWithinParent() + 1, a2 = d2));
  return a2.getChildAtIndex(b2 ? e2 - 1 : e2);
}
function sc(a2, b2) {
  var c2 = a2.offset;
  if ("element" === a2.type)
    return a2 = a2.getNode(), rc(a2, b2, c2);
  a2 = a2.getNode();
  return b2 && 0 === c2 || !b2 && c2 === a2.getTextContentSize() ? (c2 = b2 ? a2.getPreviousSibling() : a2.getNextSibling(), null === c2 ? rc(a2.getParentOrThrow(), b2, a2.getIndexWithinParent() + (b2 ? 0 : 1)) : c2) : null;
}
function Bb(a2) {
  a2 = (a2 = Eb(a2).event) && a2.inputType;
  return "insertFromPaste" === a2 || "insertFromPasteAsQuotation" === a2;
}
function tc(a2) {
  return !L$4(a2) && !a2.isLastChild() && !a2.isInline();
}
function uc(a2, b2) {
  a2 = a2._keyToDOMMap.get(b2);
  void 0 === a2 && r$a(75, b2);
  return a2;
}
function Vb(a2) {
  a2 = a2.assignedSlot || a2.parentElement;
  return null !== a2 && 11 === a2.nodeType ? a2.host : a2;
}
function vc(a2, b2) {
  for (a2 = a2.getParent(); null !== a2; ) {
    if (a2.is(b2))
      return true;
    a2 = a2.getParent();
  }
  return false;
}
function Eb(a2) {
  a2 = a2._window;
  null === a2 && r$a(78);
  return a2;
}
function wc(a2) {
  for (a2 = a2.getParentOrThrow(); null !== a2 && !xc(a2); )
    a2 = a2.getParentOrThrow();
  return a2;
}
function xc(a2) {
  return L$4(a2) || E$6(a2) && a2.isShadowRoot();
}
function yc(a2) {
  a2 = a2.constructor.clone(a2);
  Zb(a2, null);
  return a2;
}
function zc(a2) {
  var b2 = F$6();
  let c2 = a2.constructor.getType();
  b2 = b2._nodes.get(c2);
  void 0 === b2 && r$a(97);
  b2 = b2.replace;
  return null !== b2 ? (b2 = b2(a2), b2 instanceof a2.constructor || r$a(98), b2) : a2;
}
function Ac(a2, b2) {
  a2 = a2.getParent();
  !L$4(a2) || E$6(b2) || z$7(b2) || r$a(99);
}
function Bc(a2) {
  return (z$7(a2) || E$6(a2) && !a2.canBeEmpty()) && !a2.isInline();
}
function Cc(a2, b2, c2) {
  c2.style.removeProperty("caret-color");
  b2._blockCursorElement = null;
  b2 = a2.parentElement;
  null !== b2 && b2.removeChild(a2);
}
function xb(a2) {
  return Ua ? (a2 || window).getSelection() : null;
}
function Dc(a2, b2) {
  for (; a2 !== J$4() && null != a2; ) {
    if (b2(a2))
      return a2;
    a2 = a2.getParent();
  }
  return null;
}
function Ec(a2) {
  let b2 = [], c2 = [a2];
  for (; 0 < c2.length; ) {
    let d2 = c2.pop();
    void 0 === d2 && r$a(112);
    E$6(d2) && c2.unshift(...d2.getChildren());
    d2 !== a2 && b2.push(d2);
  }
  return b2;
}
function Fc(a2) {
  return 1 === a2.nodeType;
}
function Gc(a2) {
  if (z$7(a2) && !a2.isInline())
    return true;
  if (!E$6(a2) || xc(a2))
    return false;
  var b2 = a2.getFirstChild();
  b2 = null === b2 || Hc(b2) || B$8(b2) || b2.isInline();
  return !a2.isInline() && false !== a2.canBeEmpty() && b2;
}
function Ic(a2, b2) {
  for (; null !== a2 && null !== a2.getParent() && !b2(a2); )
    a2 = a2.getParentOrThrow();
  return b2(a2) ? a2 : null;
}
function Jc(a2, b2, c2, d2, e2, f2) {
  for (a2 = a2.getFirstChild(); null !== a2; ) {
    let g2 = a2.__key;
    a2.__parent === b2 && (E$6(a2) && Jc(a2, g2, c2, d2, e2, f2), c2.has(g2) || f2.delete(g2), e2.push(g2));
    a2 = a2.getNextSibling();
  }
}
function Kc(a2, b2, c2, d2) {
  a2 = a2._nodeMap;
  b2 = b2._nodeMap;
  let e2 = [];
  for (let [f2] of d2) {
    let g2 = b2.get(f2);
    void 0 === g2 || g2.isAttached() || (E$6(g2) && Jc(g2, f2, a2, b2, e2, d2), a2.has(f2) || d2.delete(f2), e2.push(f2));
  }
  for (let f2 of e2)
    b2.delete(f2);
  for (let f2 of c2)
    d2 = b2.get(f2), void 0 === d2 || d2.isAttached() || (a2.has(f2) || c2.delete(f2), b2.delete(f2));
}
let M$2 = "", N$3 = "", Lc = "", Mc, O$3, Nc, Oc = false, Pc = false, Qc, Rc = null, Sc, Tc, Uc, Vc, Wc, Xc;
function Yc(a2, b2) {
  let c2 = Uc.get(a2);
  if (null !== b2) {
    let d2 = Zc(a2);
    d2.parentNode === b2 && b2.removeChild(d2);
  }
  Vc.has(a2) || O$3._keyToDOMMap.delete(a2);
  E$6(c2) && (a2 = id(c2, Uc), jd(a2, 0, a2.length - 1, null));
  void 0 !== c2 && qc(Xc, Nc, Qc, c2, "destroyed");
}
function jd(a2, b2, c2, d2) {
  for (; b2 <= c2; ++b2) {
    let e2 = a2[b2];
    void 0 !== e2 && Yc(e2, d2);
  }
}
function kd(a2, b2) {
  a2.setProperty("text-align", b2);
}
function ld(a2, b2) {
  var c2 = Mc.theme.indent;
  if ("string" === typeof c2) {
    let d2 = a2.classList.contains(c2);
    0 < b2 && !d2 ? a2.classList.add(c2) : 1 > b2 && d2 && a2.classList.remove(c2);
  }
  c2 = getComputedStyle(a2).getPropertyValue("--lexical-indent-base-value") || "40px";
  a2.style.setProperty("padding-inline-start", 0 === b2 ? "" : `calc(${b2} * ${c2})`);
}
function md(a2, b2) {
  a2 = a2.style;
  0 === b2 ? kd(a2, "") : 1 === b2 ? kd(a2, "left") : 2 === b2 ? kd(a2, "center") : 3 === b2 ? kd(a2, "right") : 4 === b2 ? kd(a2, "justify") : 5 === b2 ? kd(a2, "start") : 6 === b2 && kd(a2, "end");
}
function nd(a2, b2, c2) {
  let d2 = Vc.get(a2);
  void 0 === d2 && r$a(60);
  let e2 = d2.createDOM(Mc, O$3);
  var f2 = O$3._keyToDOMMap;
  e2["__lexicalKey_" + O$3._key] = a2;
  f2.set(a2, e2);
  B$8(d2) ? e2.setAttribute("data-lexical-text", "true") : z$7(d2) && e2.setAttribute("data-lexical-decorator", "true");
  if (E$6(d2)) {
    a2 = d2.__indent;
    f2 = d2.__size;
    0 !== a2 && ld(e2, a2);
    if (0 !== f2) {
      --f2;
      a2 = id(d2, Vc);
      var g2 = N$3;
      N$3 = "";
      od(a2, d2, 0, f2, e2, null);
      pd(d2, e2);
      N$3 = g2;
    }
    a2 = d2.__format;
    0 !== a2 && md(e2, a2);
    d2.isInline() || qd(null, d2, e2);
    tc(d2) && (M$2 += "\n\n", Lc += "\n\n");
  } else
    f2 = d2.getTextContent(), z$7(d2) ? (g2 = d2.decorate(O$3, Mc), null !== g2 && rd(a2, g2), e2.contentEditable = "false") : B$8(d2) && (d2.isDirectionless() || (N$3 += f2)), M$2 += f2, Lc += f2;
  null !== b2 && (null != c2 ? b2.insertBefore(e2, c2) : (c2 = b2.__lexicalLineBreak, null != c2 ? b2.insertBefore(e2, c2) : b2.appendChild(e2)));
  qc(Xc, Nc, Qc, d2, "created");
  return e2;
}
function od(a2, b2, c2, d2, e2, f2) {
  let g2 = M$2;
  for (M$2 = ""; c2 <= d2; ++c2)
    nd(a2[c2], e2, f2);
  tc(b2) && (M$2 += "\n\n");
  e2.__lexicalTextContent = M$2;
  M$2 = g2 + M$2;
}
function sd(a2, b2) {
  a2 = b2.get(a2);
  return Hc(a2) || z$7(a2) && a2.isInline();
}
function qd(a2, b2, c2) {
  a2 = null !== a2 && (0 === a2.__size || sd(a2.__last, Uc));
  b2 = 0 === b2.__size || sd(b2.__last, Vc);
  a2 ? b2 || (b2 = c2.__lexicalLineBreak, null != b2 && c2.removeChild(b2), c2.__lexicalLineBreak = null) : b2 && (b2 = document.createElement("br"), c2.__lexicalLineBreak = b2, c2.appendChild(b2));
}
function pd(a2, b2) {
  var c2 = b2.__lexicalDir;
  if (b2.__lexicalDirTextContent !== N$3 || c2 !== Rc) {
    let f2 = "" === N$3;
    if (f2)
      var d2 = Rc;
    else
      d2 = N$3, d2 = fb.test(d2) ? "rtl" : gb.test(d2) ? "ltr" : null;
    if (d2 !== c2) {
      let g2 = b2.classList, h2 = Mc.theme;
      var e2 = null !== c2 ? h2[c2] : void 0;
      let k2 = null !== d2 ? h2[d2] : void 0;
      void 0 !== e2 && ("string" === typeof e2 && (e2 = e2.split(" "), e2 = h2[c2] = e2), g2.remove(...e2));
      null === d2 || f2 && "ltr" === d2 ? b2.removeAttribute("dir") : (void 0 !== k2 && ("string" === typeof k2 && (c2 = k2.split(" "), k2 = h2[d2] = c2), void 0 !== k2 && g2.add(...k2)), b2.dir = d2);
      Pc || (a2.getWritable().__dir = d2);
    }
    Rc = d2;
    b2.__lexicalDirTextContent = N$3;
    b2.__lexicalDir = d2;
  }
}
function id(a2, b2) {
  let c2 = [];
  for (a2 = a2.__first; null !== a2; ) {
    let d2 = b2.get(a2);
    void 0 === d2 && r$a(101);
    c2.push(a2);
    a2 = d2.__next;
  }
  return c2;
}
function td(a2, b2) {
  var c2 = Uc.get(a2), d2 = Vc.get(a2);
  void 0 !== c2 && void 0 !== d2 || r$a(61);
  var e2 = Oc || Tc.has(a2) || Sc.has(a2);
  let f2 = uc(O$3, a2);
  if (c2 === d2 && !e2)
    return E$6(c2) ? (d2 = f2.__lexicalTextContent, void 0 !== d2 && (M$2 += d2, Lc += d2), d2 = f2.__lexicalDirTextContent, void 0 !== d2 && (N$3 += d2)) : (d2 = c2.getTextContent(), B$8(c2) && !c2.isDirectionless() && (N$3 += d2), Lc += d2, M$2 += d2), f2;
  c2 !== d2 && e2 && qc(Xc, Nc, Qc, d2, "updated");
  if (d2.updateDOM(c2, f2, Mc))
    return d2 = nd(a2, null, null), null === b2 && r$a(62), b2.replaceChild(d2, f2), Yc(a2, null), d2;
  if (E$6(c2) && E$6(d2)) {
    a2 = d2.__indent;
    a2 !== c2.__indent && ld(f2, a2);
    a2 = d2.__format;
    a2 !== c2.__format && md(f2, a2);
    if (e2) {
      a2 = d2;
      e2 = N$3;
      N$3 = "";
      b2 = M$2;
      var g2 = c2.__size, h2 = a2.__size;
      M$2 = "";
      if (1 === g2 && 1 === h2) {
        var k2 = c2.__first, m2 = a2.__first;
        if (k2 === m2)
          td(k2, f2);
        else {
          var p2 = Zc(k2);
          m2 = nd(m2, null, null);
          f2.replaceChild(m2, p2);
          Yc(k2, null);
        }
      } else {
        m2 = id(c2, Uc);
        var n2 = id(a2, Vc);
        if (0 === g2)
          0 !== h2 && od(n2, a2, 0, h2 - 1, f2, null);
        else if (0 === h2)
          0 !== g2 && (k2 = null == f2.__lexicalLineBreak, jd(m2, 0, g2 - 1, k2 ? null : f2), k2 && (f2.textContent = ""));
        else {
          var l2 = m2;
          m2 = n2;
          n2 = g2 - 1;
          g2 = h2 - 1;
          let u2 = f2.firstChild, y2 = 0;
          for (h2 = 0; y2 <= n2 && h2 <= g2; ) {
            var q2 = l2[y2];
            let x3 = m2[h2];
            if (q2 === x3)
              u2 = ud(td(x3, f2)), y2++, h2++;
            else {
              void 0 === k2 && (k2 = new Set(l2));
              void 0 === p2 && (p2 = new Set(m2));
              let A2 = p2.has(q2), aa2 = k2.has(x3);
              A2 ? (aa2 ? (q2 = uc(O$3, x3), q2 === u2 ? u2 = ud(td(x3, f2)) : (null != u2 ? f2.insertBefore(q2, u2) : f2.appendChild(q2), td(x3, f2)), y2++) : nd(x3, f2, u2), h2++) : (u2 = ud(Zc(q2)), Yc(q2, f2), y2++);
            }
          }
          k2 = y2 > n2;
          p2 = h2 > g2;
          k2 && !p2 ? (k2 = m2[g2 + 1], k2 = void 0 === k2 ? null : O$3.getElementByKey(k2), od(m2, a2, h2, g2, f2, k2)) : p2 && !k2 && jd(l2, y2, n2, f2);
        }
      }
      tc(a2) && (M$2 += "\n\n");
      f2.__lexicalTextContent = M$2;
      M$2 = b2 + M$2;
      pd(a2, f2);
      N$3 = e2;
      L$4(d2) || d2.isInline() || qd(c2, d2, f2);
    }
    tc(d2) && (M$2 += "\n\n", Lc += "\n\n");
  } else
    c2 = d2.getTextContent(), z$7(d2) ? (e2 = d2.decorate(
      O$3,
      Mc
    ), null !== e2 && rd(a2, e2)) : B$8(d2) && !d2.isDirectionless() && (N$3 += c2), M$2 += c2, Lc += c2;
  !Pc && L$4(d2) && d2.__cachedText !== Lc && (d2 = d2.getWritable(), d2.__cachedText = Lc);
  return f2;
}
function rd(a2, b2) {
  let c2 = O$3._pendingDecorators, d2 = O$3._decorators;
  if (null === c2) {
    if (d2[a2] === b2)
      return;
    c2 = fc(O$3);
  }
  c2[a2] = b2;
}
function ud(a2) {
  a2 = a2.nextSibling;
  null !== a2 && a2 === O$3._blockCursorElement && (a2 = a2.nextSibling);
  return a2;
}
function Zc(a2) {
  let b2 = Wc.get(a2);
  void 0 === b2 && r$a(75, a2);
  return b2;
}
let vd = Object.freeze({}), Cd = [["keydown", wd], ["pointerdown", xd], ["compositionstart", yd], ["compositionend", zd], ["input", Ad], ["click", Bd], ["cut", vd], ["copy", vd], ["dragstart", vd], ["dragover", vd], ["dragend", vd], ["paste", vd], ["focus", vd], ["blur", vd], ["drop", vd]];
Ya && Cd.push(["beforeinput", (a2, b2) => Dd(a2, b2)]);
let Ed = 0, Fd = 0, Gd = 0, Hd = null, Id = 0, Jd = false, Kd = false, Ld = false, Md = false, Nd = [0, "", 0, "root", 0];
function Od(a2, b2, c2, d2, e2) {
  let f2 = a2.anchor, g2 = a2.focus, h2 = f2.getNode();
  var k2 = F$6();
  let m2 = xb(k2._window), p2 = null !== m2 ? m2.anchorNode : null, n2 = f2.key;
  k2 = k2.getElementByKey(n2);
  let l2 = c2.length;
  return n2 !== g2.key || !B$8(h2) || (!e2 && (!Ya || Gd < d2 + 50) || h2.isDirty() && 2 > l2 || jc(c2)) && f2.offset !== g2.offset && !h2.isComposing() || Wb(h2) || h2.isDirty() && 1 < l2 || (e2 || !Ya) && null !== k2 && !h2.isComposing() && p2 !== Xb(k2) || null !== m2 && null !== b2 && (!b2.collapsed || b2.startContainer !== m2.anchorNode || b2.startOffset !== m2.anchorOffset) || h2.getFormat() !== a2.format || h2.getStyle() !== a2.style || oc(a2, h2);
}
function Pd(a2, b2) {
  return null !== a2 && null !== a2.nodeValue && 3 === a2.nodeType && 0 !== b2 && b2 !== a2.nodeValue.length;
}
function Qd(a2, b2, c2) {
  let { anchorNode: d2, anchorOffset: e2, focusNode: f2, focusOffset: g2 } = a2;
  if (Jd && (Jd = false, Pd(d2, e2) && Pd(f2, g2)))
    return;
  w$7(b2, () => {
    if (!c2)
      Ab(null);
    else if (Nb(b2, d2, f2)) {
      var h2 = v$8();
      if (C$7(h2)) {
        var k2 = h2.anchor, m2 = k2.getNode();
        if (h2.isCollapsed()) {
          "Range" === a2.type && a2.anchorNode === a2.focusNode && (h2.dirty = true);
          var p2 = Eb(b2).event;
          p2 = p2 ? p2.timeStamp : performance.now();
          let [l2, q2, u2, y2, x3] = Nd;
          var n2 = J$4();
          n2 = false === b2.isComposing() && "" === n2.getTextContent();
          p2 < x3 + 200 && k2.offset === u2 && k2.key === y2 ? (h2.format = l2, h2.style = q2) : "text" === k2.type ? (h2.format = m2.getFormat(), h2.style = m2.getStyle()) : "element" !== k2.type || n2 || (h2.format = 0, h2.style = "");
        } else {
          k2 = 255;
          m2 = false;
          p2 = h2.getNodes();
          n2 = p2.length;
          for (let l2 = 0; l2 < n2; l2++) {
            let q2 = p2[l2];
            if (B$8(q2) && (m2 = true, k2 &= q2.getFormat(), 0 === k2))
              break;
          }
          h2.format = m2 ? k2 : 0;
        }
      }
      R$3(b2, ba$2, void 0);
    }
  });
}
function Bd(a2, b2) {
  w$7(b2, () => {
    let c2 = v$8();
    var d2 = xb(b2._window);
    let e2 = nc();
    if (d2)
      if (C$7(c2)) {
        let g2 = c2.anchor;
        var f2 = g2.getNode();
        "element" === g2.type && 0 === g2.offset && c2.isCollapsed() && !L$4(f2) && 1 === J$4().getChildrenSize() && f2.getTopLevelElementOrThrow().isEmpty() && null !== e2 && c2.is(e2) ? (d2.removeAllRanges(), c2.dirty = true) : 3 !== a2.detail || c2.isCollapsed() || (d2 = c2.focus.getNode(), f2 !== d2 && (E$6(f2) ? f2.select(0) : f2.getParentOrThrow().select(0)));
      } else
        "touch" === a2.pointerType && (f2 = d2.anchorNode, null !== f2 && (f2 = f2.nodeType, 1 === f2 || 3 === f2)) && (d2 = Rd(e2, d2, b2), Ab(d2));
    R$3(b2, ca$2, a2);
  });
}
function xd(a2, b2) {
  let c2 = a2.target;
  a2 = a2.pointerType;
  c2 instanceof Node && "touch" !== a2 && w$7(b2, () => {
    z$7(wb(c2)) || (Kd = true);
  });
}
function Sd(a2) {
  if (!a2.getTargetRanges)
    return null;
  a2 = a2.getTargetRanges();
  return 0 === a2.length ? null : a2[0];
}
function Td(a2, b2) {
  return a2 !== b2 || E$6(a2) || E$6(b2) || !a2.isToken() || !b2.isToken();
}
function Dd(a2, b2) {
  let c2 = a2.inputType, d2 = Sd(a2);
  "deleteCompositionText" === c2 || Xa && Bb(b2) || "insertCompositionText" !== c2 && w$7(b2, () => {
    let e2 = v$8();
    if ("deleteContentBackward" === c2) {
      if (null === e2) {
        var f2 = nc();
        if (!C$7(f2))
          return;
        Ab(f2.clone());
      }
      if (C$7(e2)) {
        ab && H$6(e2.anchor.key);
        229 === Fd && a2.timeStamp < Ed + 30 && b2.isComposing() && e2.anchor.key === e2.focus.key ? (H$6(null), Ed = 0, setTimeout(() => {
          w$7(b2, () => {
            H$6(null);
          });
        }, 30), C$7(e2) && (f2 = e2.anchor.getNode(), f2.markDirty(), e2.format = f2.getFormat(), e2.style = f2.getStyle()), 1 >= e2.anchor.getNode().getTextContent().length && (a2.preventDefault(), R$3(b2, ea$2, true))) : (a2.preventDefault(), R$3(b2, ea$2, true));
        return;
      }
    }
    if (C$7(e2)) {
      f2 = a2.data;
      null !== Hd && mc(false, b2, Hd);
      e2.dirty && null === Hd || !e2.isCollapsed() || L$4(e2.anchor.getNode()) || null === d2 || e2.applyDOMRange(d2);
      Hd = null;
      var g2 = e2.focus, h2 = e2.anchor.getNode();
      g2 = g2.getNode();
      if ("insertText" === c2 || "insertTranspose" === c2)
        "\n" === f2 ? (a2.preventDefault(), R$3(b2, fa$2, false)) : "\n\n" === f2 ? (a2.preventDefault(), R$3(b2, ha$2, void 0)) : null == f2 && a2.dataTransfer ? (f2 = a2.dataTransfer.getData("text/plain"), a2.preventDefault(), e2.insertRawText(f2)) : null != f2 && Od(e2, d2, f2, a2.timeStamp, true) ? (a2.preventDefault(), R$3(b2, la$1, f2)) : Hd = f2, Gd = a2.timeStamp;
      else
        switch (a2.preventDefault(), c2) {
          case "insertFromYank":
          case "insertFromDrop":
          case "insertReplacementText":
            R$3(b2, la$1, a2);
            break;
          case "insertFromComposition":
            H$6(null);
            R$3(b2, la$1, a2);
            break;
          case "insertLineBreak":
            H$6(null);
            R$3(b2, fa$2, false);
            break;
          case "insertParagraph":
            H$6(null);
            Ld && !$a ? (Ld = false, R$3(b2, fa$2, false)) : R$3(b2, ha$2, void 0);
            break;
          case "insertFromPaste":
          case "insertFromPasteAsQuotation":
            R$3(b2, ma$1, a2);
            break;
          case "deleteByComposition":
            Td(h2, g2) && R$3(b2, na$1, a2);
            break;
          case "deleteByDrag":
          case "deleteByCut":
            R$3(b2, na$1, a2);
            break;
          case "deleteContent":
            R$3(b2, ea$2, false);
            break;
          case "deleteWordBackward":
            R$3(b2, pa$1, true);
            break;
          case "deleteWordForward":
            R$3(b2, pa$1, false);
            break;
          case "deleteHardLineBackward":
          case "deleteSoftLineBackward":
            R$3(b2, qa$1, true);
            break;
          case "deleteContentForward":
          case "deleteHardLineForward":
          case "deleteSoftLineForward":
            R$3(b2, qa$1, false);
            break;
          case "formatStrikeThrough":
            R$3(b2, ra$1, "strikethrough");
            break;
          case "formatBold":
            R$3(b2, ra$1, "bold");
            break;
          case "formatItalic":
            R$3(b2, ra$1, "italic");
            break;
          case "formatUnderline":
            R$3(b2, ra$1, "underline");
            break;
          case "historyUndo":
            R$3(b2, sa$1, void 0);
            break;
          case "historyRedo":
            R$3(b2, ta$1, void 0);
        }
    }
  });
}
function Ad(a2, b2) {
  a2.stopPropagation();
  w$7(b2, () => {
    var c2 = v$8(), d2 = a2.data, e2 = Sd(a2);
    if (null != d2 && C$7(c2) && Od(c2, e2, d2, a2.timeStamp, false)) {
      Md && (Ud(b2, d2), Md = false);
      var f2 = c2.anchor, g2 = f2.getNode();
      e2 = xb(b2._window);
      if (null === e2)
        return;
      let h2 = f2.offset;
      if (f2 = Ya && !c2.isCollapsed() && B$8(g2) && null !== e2.anchorNode)
        g2 = g2.getTextContent().slice(0, h2) + d2 + g2.getTextContent().slice(h2 + c2.focus.offset), e2 = e2.anchorNode, f2 = g2 === (3 === e2.nodeType ? e2.nodeValue : null);
      f2 || R$3(b2, la$1, d2);
      d2 = d2.length;
      Xa && 1 < d2 && "insertCompositionText" === a2.inputType && !b2.isComposing() && (c2.anchor.offset -= d2);
      Za || $a || cb || !b2.isComposing() || (Ed = 0, H$6(null));
    } else
      mc(false, b2, null !== d2 ? d2 : void 0), Md && (Ud(b2, d2 || void 0), Md = false);
    G$6();
    c2 = F$6();
    Cb(c2);
  });
  Hd = null;
}
function yd(a2, b2) {
  w$7(b2, () => {
    let c2 = v$8();
    if (C$7(c2) && !b2.isComposing()) {
      let d2 = c2.anchor, e2 = c2.anchor.getNode();
      H$6(d2.key);
      (a2.timeStamp < Ed + 30 || "element" === d2.type || !c2.isCollapsed() || e2.getFormat() !== c2.format || e2.getStyle() !== c2.style) && R$3(b2, la$1, eb);
    }
  });
}
function Ud(a2, b2) {
  var c2 = a2._compositionKey;
  H$6(null);
  if (null !== c2 && null != b2) {
    if ("" === b2) {
      b2 = I$5(c2);
      a2 = Xb(a2.getElementByKey(c2));
      null !== a2 && null !== a2.nodeValue && B$8(b2) && yb(b2, a2.nodeValue, null, null, true);
      return;
    }
    if ("\n" === b2[b2.length - 1] && (c2 = v$8(), C$7(c2))) {
      b2 = c2.focus;
      c2.anchor.set(b2.key, b2.offset, b2.type);
      R$3(a2, Ca$1, null);
      return;
    }
  }
  mc(true, a2, b2);
}
function zd(a2, b2) {
  Xa ? Md = true : w$7(b2, () => {
    Ud(b2, a2.data);
  });
}
function wd(a2, b2) {
  Ed = a2.timeStamp;
  Fd = a2.keyCode;
  if (!b2.isComposing()) {
    var { keyCode: c2, shiftKey: d2, ctrlKey: e2, metaKey: f2, altKey: g2 } = a2;
    if (!R$3(b2, ua, a2)) {
      if (39 !== c2 || e2 || f2 || g2)
        if (39 !== c2 || g2 || d2 || !e2 && !f2)
          if (37 !== c2 || e2 || f2 || g2)
            if (37 !== c2 || g2 || d2 || !e2 && !f2)
              if (38 !== c2 || e2 || f2)
                if (40 !== c2 || e2 || f2)
                  if (13 === c2 && d2)
                    Ld = true, R$3(b2, Ca$1, a2);
                  else if (32 === c2)
                    R$3(b2, Da$1, a2);
                  else if (t$8 && e2 && 79 === c2)
                    a2.preventDefault(), Ld = true, R$3(b2, fa$2, true);
                  else if (13 !== c2 || d2) {
                    var h2 = t$8 ? g2 || f2 ? false : 8 === c2 || 72 === c2 && e2 : e2 || g2 || f2 ? false : 8 === c2;
                    h2 ? 8 === c2 ? R$3(b2, Ga, a2) : (a2.preventDefault(), R$3(b2, ea$2, true)) : 27 === c2 ? R$3(
                      b2,
                      Ha,
                      a2
                    ) : (h2 = t$8 ? d2 || g2 || f2 ? false : 46 === c2 || 68 === c2 && e2 : e2 || g2 || f2 ? false : 46 === c2, h2 ? 46 === c2 ? R$3(b2, Ia, a2) : (a2.preventDefault(), R$3(b2, ea$2, false)) : 8 === c2 && (t$8 ? g2 : e2) ? (a2.preventDefault(), R$3(b2, pa$1, true)) : 46 === c2 && (t$8 ? g2 : e2) ? (a2.preventDefault(), R$3(b2, pa$1, false)) : t$8 && f2 && 8 === c2 ? (a2.preventDefault(), R$3(b2, qa$1, true)) : t$8 && f2 && 46 === c2 ? (a2.preventDefault(), R$3(b2, qa$1, false)) : 66 === c2 && !g2 && (t$8 ? f2 : e2) ? (a2.preventDefault(), R$3(b2, ra$1, "bold")) : 85 === c2 && !g2 && (t$8 ? f2 : e2) ? (a2.preventDefault(), R$3(b2, ra$1, "underline")) : 73 === c2 && !g2 && (t$8 ? f2 : e2) ? (a2.preventDefault(), R$3(b2, ra$1, "italic")) : 9 !== c2 || g2 || e2 || f2 ? 90 === c2 && !d2 && (t$8 ? f2 : e2) ? (a2.preventDefault(), R$3(b2, sa$1, void 0)) : (h2 = t$8 ? 90 === c2 && f2 && d2 : 89 === c2 && e2 || 90 === c2 && e2 && d2, h2 ? (a2.preventDefault(), R$3(b2, ta$1, void 0)) : Vd(b2._editorState._selection) ? (h2 = d2 ? false : 67 === c2 ? t$8 ? f2 : e2 : false, h2 ? (a2.preventDefault(), R$3(b2, Oa, a2)) : (h2 = d2 ? false : 88 === c2 ? t$8 ? f2 : e2 : false, h2 ? (a2.preventDefault(), R$3(b2, Pa, a2)) : 65 === c2 && (t$8 ? f2 : e2) && (a2.preventDefault(), R$3(b2, Qa, a2)))) : !Xa && 65 === c2 && (t$8 ? f2 : e2) && (a2.preventDefault(), R$3(b2, Qa, a2))) : R$3(b2, Ja, a2));
                  } else
                    Ld = false, R$3(b2, Ca$1, a2);
                else
                  R$3(b2, Ba$1, a2);
              else
                R$3(b2, Aa$1, a2);
            else
              R$3(b2, za$1, a2);
          else
            R$3(b2, xa$1, a2);
        else
          R$3(b2, wa$1, a2);
      else
        R$3(b2, va$1, a2);
      (e2 || d2 || g2 || f2) && R$3(b2, Ta, a2);
    }
  }
}
function Wd(a2) {
  let b2 = a2.__lexicalEventHandles;
  void 0 === b2 && (b2 = [], a2.__lexicalEventHandles = b2);
  return b2;
}
let Xd = /* @__PURE__ */ new Map();
function Yd(a2) {
  a2 = a2.target;
  let b2 = xb(null == a2 ? null : 9 === a2.nodeType ? a2.defaultView : a2.ownerDocument.defaultView);
  if (null !== b2) {
    var c2 = Ob(b2.anchorNode);
    if (null !== c2) {
      Kd && (Kd = false, w$7(c2, () => {
        var g2 = nc(), h2 = b2.anchorNode;
        null !== h2 && (h2 = h2.nodeType, 1 === h2 || 3 === h2) && (g2 = Rd(g2, b2, c2), Ab(g2));
      }));
      a2 = kc(c2);
      a2 = a2[a2.length - 1];
      var d2 = a2._key, e2 = Xd.get(d2), f2 = e2 || a2;
      f2 !== c2 && Qd(b2, f2, false);
      Qd(b2, c2, true);
      c2 !== a2 ? Xd.set(d2, c2) : e2 && Xd.delete(d2);
    }
  }
}
function Zd(a2, b2) {
  0 === Id && a2.ownerDocument.addEventListener("selectionchange", Yd);
  Id++;
  a2.__lexicalEditor = b2;
  let c2 = Wd(a2);
  for (let d2 = 0; d2 < Cd.length; d2++) {
    let [e2, f2] = Cd[d2], g2 = "function" === typeof f2 ? (h2) => {
      true !== h2._lexicalHandled && (h2._lexicalHandled = true, b2.isEditable() && f2(h2, b2));
    } : (h2) => {
      if (true !== h2._lexicalHandled && (h2._lexicalHandled = true, b2.isEditable()))
        switch (e2) {
          case "cut":
            return R$3(b2, Pa, h2);
          case "copy":
            return R$3(b2, Oa, h2);
          case "paste":
            return R$3(b2, ma$1, h2);
          case "dragstart":
            return R$3(b2, La, h2);
          case "dragover":
            return R$3(b2, Ma, h2);
          case "dragend":
            return R$3(
              b2,
              Na,
              h2
            );
          case "focus":
            return R$3(b2, Ra, h2);
          case "blur":
            return R$3(b2, Sa, h2);
          case "drop":
            return R$3(b2, Ka, h2);
        }
    };
    a2.addEventListener(e2, g2);
    c2.push(() => {
      a2.removeEventListener(e2, g2);
    });
  }
}
function $d(a2, b2, c2) {
  G$6();
  var d2 = a2.__key;
  let e2 = a2.getParent();
  if (null !== e2) {
    var f2 = v$8();
    if (C$7(f2) && E$6(a2)) {
      var { anchor: g2, focus: h2 } = f2;
      var k2 = g2.getNode();
      var m2 = h2.getNode();
      vc(k2, a2) && g2.set(a2.__key, 0, "element");
      vc(m2, a2) && h2.set(a2.__key, 0, "element");
    }
    k2 = f2;
    m2 = false;
    if (C$7(k2) && b2) {
      f2 = k2.anchor;
      let p2 = k2.focus;
      f2.key === d2 && (ae(f2, a2, e2, a2.getPreviousSibling(), a2.getNextSibling()), m2 = true);
      p2.key === d2 && (ae(p2, a2, e2, a2.getPreviousSibling(), a2.getNextSibling()), m2 = true);
    } else
      Vd(k2) && b2 && a2.isSelected() && a2.selectPrevious();
    C$7(k2) && b2 && !m2 ? (d2 = a2.getIndexWithinParent(), bc(a2), be(k2, e2, d2, -1)) : bc(a2);
    c2 || xc(e2) || e2.canBeEmpty() || !e2.isEmpty() || $d(e2, b2);
    b2 && L$4(e2) && e2.isEmpty() && e2.selectEnd();
  }
}
class ce {
  static getType() {
    r$a(64, this.name);
  }
  static clone() {
    r$a(65, this.name);
  }
  constructor(a2) {
    this.__type = this.constructor.getType();
    this.__next = this.__prev = this.__parent = null;
    Zb(this, a2);
  }
  getType() {
    return this.__type;
  }
  isAttached() {
    for (var a2 = this.__key; null !== a2; ) {
      if ("root" === a2)
        return true;
      a2 = I$5(a2);
      if (null === a2)
        break;
      a2 = a2.__parent;
    }
    return false;
  }
  isSelected(a2) {
    a2 = a2 || v$8();
    if (null == a2)
      return false;
    let b2 = a2.getNodes().some((c2) => c2.__key === this.__key);
    return B$8(this) ? b2 : C$7(a2) && "element" === a2.anchor.type && "element" === a2.focus.type && a2.anchor.key === a2.focus.key && a2.anchor.offset === a2.focus.offset ? false : b2;
  }
  getKey() {
    return this.__key;
  }
  getIndexWithinParent() {
    var a2 = this.getParent();
    if (null === a2)
      return -1;
    a2 = a2.getFirstChild();
    let b2 = 0;
    for (; null !== a2; ) {
      if (this.is(a2))
        return b2;
      b2++;
      a2 = a2.getNextSibling();
    }
    return -1;
  }
  getParent() {
    let a2 = this.getLatest().__parent;
    return null === a2 ? null : I$5(a2);
  }
  getParentOrThrow() {
    let a2 = this.getParent();
    null === a2 && r$a(66, this.__key);
    return a2;
  }
  getTopLevelElement() {
    let a2 = this;
    for (; null !== a2; ) {
      let b2 = a2.getParent();
      if (xc(b2))
        return a2;
      a2 = b2;
    }
    return null;
  }
  getTopLevelElementOrThrow() {
    let a2 = this.getTopLevelElement();
    null === a2 && r$a(67, this.__key);
    return a2;
  }
  getParents() {
    let a2 = [], b2 = this.getParent();
    for (; null !== b2; )
      a2.push(b2), b2 = b2.getParent();
    return a2;
  }
  getParentKeys() {
    let a2 = [], b2 = this.getParent();
    for (; null !== b2; )
      a2.push(b2.__key), b2 = b2.getParent();
    return a2;
  }
  getPreviousSibling() {
    let a2 = this.getLatest().__prev;
    return null === a2 ? null : I$5(a2);
  }
  getPreviousSiblings() {
    let a2 = [];
    var b2 = this.getParent();
    if (null === b2)
      return a2;
    for (b2 = b2.getFirstChild(); null !== b2 && !b2.is(this); )
      a2.push(b2), b2 = b2.getNextSibling();
    return a2;
  }
  getNextSibling() {
    let a2 = this.getLatest().__next;
    return null === a2 ? null : I$5(a2);
  }
  getNextSiblings() {
    let a2 = [], b2 = this.getNextSibling();
    for (; null !== b2; )
      a2.push(b2), b2 = b2.getNextSibling();
    return a2;
  }
  getCommonAncestor(a2) {
    let b2 = this.getParents();
    var c2 = a2.getParents();
    E$6(this) && b2.unshift(this);
    E$6(a2) && c2.unshift(a2);
    a2 = b2.length;
    var d2 = c2.length;
    if (0 === a2 || 0 === d2 || b2[a2 - 1] !== c2[d2 - 1])
      return null;
    c2 = new Set(c2);
    for (d2 = 0; d2 < a2; d2++) {
      let e2 = b2[d2];
      if (c2.has(e2))
        return e2;
    }
    return null;
  }
  is(a2) {
    return null == a2 ? false : this.__key === a2.__key;
  }
  isBefore(a2) {
    if (this === a2)
      return false;
    if (a2.isParentOf(this))
      return true;
    if (this.isParentOf(a2))
      return false;
    var b2 = this.getCommonAncestor(a2);
    let c2 = this;
    for (; ; ) {
      var d2 = c2.getParentOrThrow();
      if (d2 === b2) {
        d2 = c2.getIndexWithinParent();
        break;
      }
      c2 = d2;
    }
    for (c2 = a2; ; ) {
      a2 = c2.getParentOrThrow();
      if (a2 === b2) {
        b2 = c2.getIndexWithinParent();
        break;
      }
      c2 = a2;
    }
    return d2 < b2;
  }
  isParentOf(a2) {
    let b2 = this.__key;
    if (b2 === a2.__key)
      return false;
    for (; null !== a2; ) {
      if (a2.__key === b2)
        return true;
      a2 = a2.getParent();
    }
    return false;
  }
  getNodesBetween(a2) {
    let b2 = this.isBefore(a2), c2 = [], d2 = /* @__PURE__ */ new Set();
    for (var e2 = this; ; ) {
      var f2 = e2.__key;
      d2.has(f2) || (d2.add(f2), c2.push(e2));
      if (e2 === a2)
        break;
      f2 = E$6(e2) ? b2 ? e2.getFirstChild() : e2.getLastChild() : null;
      if (null !== f2)
        e2 = f2;
      else if (f2 = b2 ? e2.getNextSibling() : e2.getPreviousSibling(), null !== f2)
        e2 = f2;
      else {
        e2 = e2.getParentOrThrow();
        d2.has(e2.__key) || c2.push(e2);
        if (e2 === a2)
          break;
        f2 = e2;
        do
          null === f2 && r$a(68), e2 = b2 ? f2.getNextSibling() : f2.getPreviousSibling(), f2 = f2.getParent(), null !== f2 && (null !== e2 || d2.has(f2.__key) || c2.push(f2));
        while (null === e2);
      }
    }
    b2 || c2.reverse();
    return c2;
  }
  isDirty() {
    let a2 = F$6()._dirtyLeaves;
    return null !== a2 && a2.has(this.__key);
  }
  getLatest() {
    let a2 = I$5(this.__key);
    null === a2 && r$a(113);
    return a2;
  }
  getWritable() {
    G$6();
    var a2 = ac(), b2 = F$6();
    a2 = a2._nodeMap;
    let c2 = this.__key, d2 = this.getLatest(), e2 = d2.__parent;
    b2 = b2._cloneNotNeeded;
    var f2 = v$8();
    de(f2) && f2.setCachedNodes(null);
    if (b2.has(c2))
      return cc(d2), d2;
    f2 = d2.constructor.clone(d2);
    f2.__parent = e2;
    f2.__next = d2.__next;
    f2.__prev = d2.__prev;
    E$6(d2) && E$6(f2) ? (f2.__first = d2.__first, f2.__last = d2.__last, f2.__size = d2.__size, f2.__indent = d2.__indent, f2.__format = d2.__format, f2.__dir = d2.__dir) : B$8(d2) && B$8(f2) && (f2.__format = d2.__format, f2.__style = d2.__style, f2.__mode = d2.__mode, f2.__detail = d2.__detail);
    b2.add(c2);
    f2.__key = c2;
    cc(f2);
    a2.set(c2, f2);
    return f2;
  }
  getTextContent() {
    return "";
  }
  getTextContentSize() {
    return this.getTextContent().length;
  }
  createDOM() {
    r$a(70);
  }
  updateDOM() {
    r$a(71);
  }
  exportDOM(a2) {
    return { element: this.createDOM(a2._config, a2) };
  }
  exportJSON() {
    r$a(72);
  }
  static importJSON() {
    r$a(18, this.name);
  }
  static transform() {
    return null;
  }
  remove(a2) {
    $d(this, true, a2);
  }
  replace(a2, b2) {
    G$6();
    var c2 = v$8();
    null !== c2 && (c2 = c2.clone());
    Ac(this, a2);
    let d2 = this.getLatest(), e2 = this.__key, f2 = a2.__key, g2 = a2.getWritable();
    a2 = this.getParentOrThrow().getWritable();
    let h2 = a2.__size;
    bc(g2);
    let k2 = d2.getPreviousSibling(), m2 = d2.getNextSibling(), p2 = d2.__prev, n2 = d2.__next, l2 = d2.__parent;
    $d(d2, false, true);
    null === k2 ? a2.__first = f2 : k2.getWritable().__next = f2;
    g2.__prev = p2;
    null === m2 ? a2.__last = f2 : m2.getWritable().__prev = f2;
    g2.__next = n2;
    g2.__parent = l2;
    a2.__size = h2;
    b2 && this.getChildren().forEach((q2) => {
      g2.append(q2);
    });
    C$7(c2) && (Ab(c2), b2 = c2.anchor, c2 = c2.focus, b2.key === e2 && ee(b2, g2), c2.key === e2 && ee(c2, g2));
    dc() === e2 && H$6(f2);
    return g2;
  }
  insertAfter(a2, b2 = true) {
    G$6();
    Ac(this, a2);
    var c2 = this.getWritable();
    let d2 = a2.getWritable();
    var e2 = d2.getParent();
    let f2 = v$8();
    var g2 = false, h2 = false;
    if (null !== e2) {
      var k2 = a2.getIndexWithinParent();
      bc(d2);
      C$7(f2) && (h2 = e2.__key, g2 = f2.anchor, e2 = f2.focus, g2 = "element" === g2.type && g2.key === h2 && g2.offset === k2 + 1, h2 = "element" === e2.type && e2.key === h2 && e2.offset === k2 + 1);
    }
    e2 = this.getNextSibling();
    k2 = this.getParentOrThrow().getWritable();
    let m2 = d2.__key, p2 = c2.__next;
    null === e2 ? k2.__last = m2 : e2.getWritable().__prev = m2;
    k2.__size++;
    c2.__next = m2;
    d2.__next = p2;
    d2.__prev = c2.__key;
    d2.__parent = c2.__parent;
    b2 && C$7(f2) && (b2 = this.getIndexWithinParent(), be(f2, k2, b2 + 1), c2 = k2.__key, g2 && f2.anchor.set(c2, b2 + 2, "element"), h2 && f2.focus.set(c2, b2 + 2, "element"));
    return a2;
  }
  insertBefore(a2, b2 = true) {
    G$6();
    Ac(this, a2);
    var c2 = this.getWritable();
    let d2 = a2.getWritable(), e2 = d2.__key;
    bc(d2);
    let f2 = this.getPreviousSibling(), g2 = this.getParentOrThrow().getWritable(), h2 = c2.__prev, k2 = this.getIndexWithinParent();
    null === f2 ? g2.__first = e2 : f2.getWritable().__next = e2;
    g2.__size++;
    c2.__prev = e2;
    d2.__prev = h2;
    d2.__next = c2.__key;
    d2.__parent = c2.__parent;
    c2 = v$8();
    b2 && C$7(c2) && (b2 = this.getParentOrThrow(), be(c2, b2, k2));
    return a2;
  }
  isParentRequired() {
    return false;
  }
  createParentElementNode() {
    return fe();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(
      0,
      0
    );
  }
  selectPrevious(a2, b2) {
    G$6();
    let c2 = this.getPreviousSibling(), d2 = this.getParentOrThrow();
    return null === c2 ? d2.select(0, 0) : E$6(c2) ? c2.select() : B$8(c2) ? c2.select(a2, b2) : (a2 = c2.getIndexWithinParent() + 1, d2.select(a2, a2));
  }
  selectNext(a2, b2) {
    G$6();
    let c2 = this.getNextSibling(), d2 = this.getParentOrThrow();
    return null === c2 ? d2.select() : E$6(c2) ? c2.select(0, 0) : B$8(c2) ? c2.select(a2, b2) : (a2 = c2.getIndexWithinParent(), d2.select(a2, a2));
  }
  markDirty() {
    this.getWritable();
  }
}
function ge(a2, b2, c2) {
  c2 = c2 || b2.getParentOrThrow().getLastChild();
  let d2 = b2;
  for (b2 = [b2]; d2 !== c2; ) {
    if (!d2.getNextSibling())
      throw Error("insertRangeAfter: lastToInsert must be a later sibling of firstToInsert");
    d2 = d2.getNextSibling();
    b2.push(d2);
  }
  for (let e2 of b2)
    a2 = a2.insertAfter(e2);
}
class he extends ce {
  static getType() {
    return "linebreak";
  }
  static clone(a2) {
    return new he(a2.__key);
  }
  constructor(a2) {
    super(a2);
  }
  getTextContent() {
    return "\n";
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return false;
  }
  static importDOM() {
    return { br: (a2) => {
      let b2 = a2.parentElement, c2, d2;
      return null !== b2 && ((c2 = b2.firstChild) === a2 || c2.nextSibling === a2 && 3 === c2.nodeType && null !== (c2.textContent || "").match(/^( |\t|\r?\n)+$/)) && ((d2 = b2.lastChild) === a2 || d2.previousSibling === a2 && 3 === d2.nodeType && null !== (d2.textContent || "").match(/^( |\t|\r?\n)+$/)) ? null : { conversion: ie, priority: 0 };
    } };
  }
  static importJSON() {
    return je();
  }
  exportJSON() {
    return { type: "linebreak", version: 1 };
  }
}
function ie() {
  return { node: je() };
}
function je() {
  return zc(new he());
}
function Hc(a2) {
  return a2 instanceof he;
}
function ke(a2, b2) {
  return b2 & 16 ? "code" : b2 & 128 ? "mark" : b2 & 32 ? "sub" : b2 & 64 ? "sup" : null;
}
function le(a2, b2) {
  return b2 & 1 ? "strong" : b2 & 2 ? "em" : "span";
}
function me(a2, b2, c2, d2, e2) {
  a2 = d2.classList;
  d2 = pc(e2, "base");
  void 0 !== d2 && a2.add(...d2);
  d2 = pc(e2, "underlineStrikethrough");
  let f2 = false, g2 = b2 & 8 && b2 & 4;
  var h2 = c2 & 8 && c2 & 4;
  void 0 !== d2 && (h2 ? (f2 = true, g2 || a2.add(...d2)) : g2 && a2.remove(...d2));
  for (let k2 in hb)
    h2 = hb[k2], d2 = pc(e2, k2), void 0 !== d2 && (c2 & h2 ? !f2 || "underline" !== k2 && "strikethrough" !== k2 ? (0 === (b2 & h2) || g2 && "underline" === k2 || "strikethrough" === k2) && a2.add(...d2) : b2 & h2 && a2.remove(...d2) : b2 & h2 && a2.remove(...d2));
}
function ne(a2, b2, c2) {
  let d2 = b2.firstChild;
  c2 = c2.isComposing();
  a2 += c2 ? db : "";
  if (null == d2)
    b2.textContent = a2;
  else if (b2 = d2.nodeValue, b2 !== a2)
    if (c2 || Xa) {
      c2 = b2.length;
      let e2 = a2.length, f2 = 0, g2 = 0;
      for (; f2 < c2 && f2 < e2 && b2[f2] === a2[f2]; )
        f2++;
      for (; g2 + f2 < c2 && g2 + f2 < e2 && b2[c2 - g2 - 1] === a2[e2 - g2 - 1]; )
        g2++;
      a2 = [f2, c2 - f2 - g2, a2.slice(f2, e2 - g2)];
      let [h2, k2, m2] = a2;
      0 !== k2 && d2.deleteData(h2, k2);
      d2.insertData(h2, m2);
    } else
      d2.nodeValue = a2;
}
function oe(a2, b2) {
  b2 = document.createElement(b2);
  b2.appendChild(a2);
  return b2;
}
class pe extends ce {
  static getType() {
    return "text";
  }
  static clone(a2) {
    return new pe(a2.__text, a2.__key);
  }
  constructor(a2, b2) {
    super(b2);
    this.__text = a2;
    this.__format = 0;
    this.__style = "";
    this.__detail = this.__mode = 0;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getDetail() {
    return this.getLatest().__detail;
  }
  getMode() {
    let a2 = this.getLatest();
    return pb[a2.__mode];
  }
  getStyle() {
    return this.getLatest().__style;
  }
  isToken() {
    return 1 === this.getLatest().__mode;
  }
  isComposing() {
    return this.__key === dc();
  }
  isSegmented() {
    return 2 === this.getLatest().__mode;
  }
  isDirectionless() {
    return 0 !== (this.getLatest().__detail & 1);
  }
  isUnmergeable() {
    return 0 !== (this.getLatest().__detail & 2);
  }
  hasFormat(a2) {
    a2 = hb[a2];
    return 0 !== (this.getFormat() & a2);
  }
  isSimpleText() {
    return "text" === this.__type && 0 === this.__mode;
  }
  getTextContent() {
    return this.getLatest().__text;
  }
  getFormatFlags(a2, b2) {
    let c2 = this.getLatest().__format;
    return Yb(c2, a2, b2);
  }
  createDOM(a2) {
    var b2 = this.__format, c2 = ke(this, b2);
    let d2 = le(this, b2), e2 = document.createElement(null === c2 ? d2 : c2), f2 = e2;
    this.hasFormat("code") && e2.setAttribute("spellcheck", "false");
    null !== c2 && (f2 = document.createElement(d2), e2.appendChild(f2));
    c2 = f2;
    ne(this.__text, c2, this);
    a2 = a2.theme.text;
    void 0 !== a2 && me(d2, 0, b2, c2, a2);
    b2 = this.__style;
    "" !== b2 && (e2.style.cssText = b2);
    return e2;
  }
  updateDOM(a2, b2, c2) {
    let d2 = this.__text;
    var e2 = a2.__format, f2 = this.__format, g2 = ke(this, e2);
    let h2 = ke(this, f2);
    var k2 = le(this, e2);
    let m2 = le(this, f2);
    if ((null === g2 ? k2 : g2) !== (null === h2 ? m2 : h2))
      return true;
    if (g2 === h2 && k2 !== m2)
      return e2 = b2.firstChild, null == e2 && r$a(48), a2 = g2 = document.createElement(m2), ne(d2, a2, this), c2 = c2.theme.text, void 0 !== c2 && me(m2, 0, f2, a2, c2), b2.replaceChild(g2, e2), false;
    k2 = b2;
    null !== h2 && null !== g2 && (k2 = b2.firstChild, null == k2 && r$a(49));
    ne(d2, k2, this);
    c2 = c2.theme.text;
    void 0 !== c2 && e2 !== f2 && me(m2, e2, f2, k2, c2);
    f2 = this.__style;
    a2.__style !== f2 && (b2.style.cssText = f2);
    return false;
  }
  static importDOM() {
    return {
      "#text": () => ({ conversion: qe, priority: 0 }),
      b: () => ({ conversion: re, priority: 0 }),
      code: () => ({ conversion: se, priority: 0 }),
      em: () => ({ conversion: se, priority: 0 }),
      i: () => ({ conversion: se, priority: 0 }),
      s: () => ({ conversion: se, priority: 0 }),
      span: () => ({ conversion: te, priority: 0 }),
      strong: () => ({ conversion: se, priority: 0 }),
      sub: () => ({ conversion: se, priority: 0 }),
      sup: () => ({ conversion: se, priority: 0 }),
      u: () => ({ conversion: se, priority: 0 })
    };
  }
  static importJSON(a2) {
    let b2 = K$4(a2.text);
    b2.setFormat(a2.format);
    b2.setDetail(a2.detail);
    b2.setMode(a2.mode);
    b2.setStyle(a2.style);
    return b2;
  }
  exportDOM(a2) {
    ({ element: a2 } = super.exportDOM(a2));
    null !== a2 && Fc(a2) || r$a(132);
    a2.style.whiteSpace = "pre-wrap";
    this.hasFormat("bold") && (a2 = oe(a2, "b"));
    this.hasFormat("italic") && (a2 = oe(a2, "i"));
    this.hasFormat("strikethrough") && (a2 = oe(a2, "s"));
    this.hasFormat("underline") && (a2 = oe(a2, "u"));
    return { element: a2 };
  }
  exportJSON() {
    return {
      detail: this.getDetail(),
      format: this.getFormat(),
      mode: this.getMode(),
      style: this.getStyle(),
      text: this.getTextContent(),
      type: "text",
      version: 1
    };
  }
  selectionTransform() {
  }
  setFormat(a2) {
    let b2 = this.getWritable();
    b2.__format = "string" === typeof a2 ? hb[a2] : a2;
    return b2;
  }
  setDetail(a2) {
    let b2 = this.getWritable();
    b2.__detail = "string" === typeof a2 ? ib[a2] : a2;
    return b2;
  }
  setStyle(a2) {
    let b2 = this.getWritable();
    b2.__style = a2;
    return b2;
  }
  toggleFormat(a2) {
    let b2 = this.getFormat();
    a2 = Yb(b2, a2, null);
    return this.setFormat(a2);
  }
  toggleDirectionless() {
    let a2 = this.getWritable();
    a2.__detail ^= 1;
    return a2;
  }
  toggleUnmergeable() {
    let a2 = this.getWritable();
    a2.__detail ^= 2;
    return a2;
  }
  setMode(a2) {
    a2 = lb[a2];
    if (this.__mode === a2)
      return this;
    let b2 = this.getWritable();
    b2.__mode = a2;
    return b2;
  }
  setTextContent(a2) {
    if (this.__text === a2)
      return this;
    let b2 = this.getWritable();
    b2.__text = a2;
    return b2;
  }
  select(a2, b2) {
    G$6();
    let c2 = v$8();
    var d2 = this.getTextContent();
    let e2 = this.__key;
    "string" === typeof d2 ? (d2 = d2.length, void 0 === a2 && (a2 = d2), void 0 === b2 && (b2 = d2)) : b2 = a2 = 0;
    if (C$7(c2))
      d2 = dc(), d2 !== c2.anchor.key && d2 !== c2.focus.key || H$6(e2), c2.setTextNodeRange(this, a2, this, b2);
    else
      return ue(e2, a2, e2, b2, "text", "text");
    return c2;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    let a2 = this.getTextContentSize();
    return this.select(a2, a2);
  }
  spliceText(a2, b2, c2, d2) {
    let e2 = this.getWritable(), f2 = e2.__text, g2 = c2.length, h2 = a2;
    0 > h2 && (h2 = g2 + h2, 0 > h2 && (h2 = 0));
    let k2 = v$8();
    d2 && C$7(k2) && (a2 += g2, k2.setTextNodeRange(e2, a2, e2, a2));
    b2 = f2.slice(0, h2) + c2 + f2.slice(h2 + b2);
    e2.__text = b2;
    return e2;
  }
  canInsertTextBefore() {
    return true;
  }
  canInsertTextAfter() {
    return true;
  }
  splitText(...a2) {
    G$6();
    var b2 = this.getLatest(), c2 = b2.getTextContent(), d2 = b2.__key, e2 = dc(), f2 = new Set(a2);
    a2 = [];
    var g2 = c2.length, h2 = "";
    for (var k2 = 0; k2 < g2; k2++)
      "" !== h2 && f2.has(k2) && (a2.push(h2), h2 = ""), h2 += c2[k2];
    "" !== h2 && a2.push(h2);
    f2 = a2.length;
    if (0 === f2)
      return [];
    if (a2[0] === c2)
      return [b2];
    var m2 = a2[0];
    c2 = b2.getParentOrThrow();
    k2 = b2.getFormat();
    let p2 = b2.getStyle(), n2 = b2.__detail;
    g2 = false;
    b2.isSegmented() ? (h2 = K$4(m2), h2.__format = k2, h2.__style = p2, h2.__detail = n2, g2 = true) : (h2 = b2.getWritable(), h2.__text = m2);
    b2 = v$8();
    h2 = [h2];
    m2 = m2.length;
    for (let u2 = 1; u2 < f2; u2++) {
      var l2 = a2[u2], q2 = l2.length;
      l2 = K$4(l2).getWritable();
      l2.__format = k2;
      l2.__style = p2;
      l2.__detail = n2;
      let y2 = l2.__key;
      q2 = m2 + q2;
      if (C$7(b2)) {
        let x3 = b2.anchor, A2 = b2.focus;
        x3.key === d2 && "text" === x3.type && x3.offset > m2 && x3.offset <= q2 && (x3.key = y2, x3.offset -= m2, b2.dirty = true);
        A2.key === d2 && "text" === A2.type && A2.offset > m2 && A2.offset <= q2 && (A2.key = y2, A2.offset -= m2, b2.dirty = true);
      }
      e2 === d2 && H$6(y2);
      m2 = q2;
      h2.push(l2);
    }
    d2 = this.getPreviousSibling();
    e2 = this.getNextSibling();
    null !== d2 && cc(d2);
    null !== e2 && cc(e2);
    d2 = c2.getWritable();
    e2 = this.getIndexWithinParent();
    g2 ? (d2.splice(e2, 0, h2), this.remove()) : d2.splice(e2, 1, h2);
    C$7(b2) && be(b2, c2, e2, f2 - 1);
    return h2;
  }
  mergeWithSibling(a2) {
    var b2 = a2 === this.getPreviousSibling();
    b2 || a2 === this.getNextSibling() || r$a(50);
    var c2 = this.__key;
    let d2 = a2.__key, e2 = this.__text, f2 = e2.length;
    dc() === d2 && H$6(c2);
    let g2 = v$8();
    if (C$7(g2)) {
      let h2 = g2.anchor, k2 = g2.focus;
      null !== h2 && h2.key === d2 && (ve(h2, b2, c2, a2, f2), g2.dirty = true);
      null !== k2 && k2.key === d2 && (ve(k2, b2, c2, a2, f2), g2.dirty = true);
    }
    c2 = a2.__text;
    this.setTextContent(b2 ? c2 + e2 : e2 + c2);
    b2 = this.getWritable();
    a2.remove();
    return b2;
  }
  isTextEntity() {
    return false;
  }
}
function te(a2) {
  let b2 = "700" === a2.style.fontWeight, c2 = "line-through" === a2.style.textDecoration, d2 = "italic" === a2.style.fontStyle, e2 = "underline" === a2.style.textDecoration, f2 = a2.style.verticalAlign;
  return { forChild: (g2) => {
    if (!B$8(g2))
      return g2;
    b2 && g2.toggleFormat("bold");
    c2 && g2.toggleFormat("strikethrough");
    d2 && g2.toggleFormat("italic");
    e2 && g2.toggleFormat("underline");
    "sub" === f2 && g2.toggleFormat("subscript");
    "super" === f2 && g2.toggleFormat("superscript");
    return g2;
  }, node: null };
}
function re(a2) {
  let b2 = "normal" === a2.style.fontWeight;
  return { forChild: (c2) => {
    B$8(c2) && !b2 && c2.toggleFormat("bold");
    return c2;
  }, node: null };
}
let we = /* @__PURE__ */ new WeakMap();
function qe(a2) {
  null === a2.parentElement && r$a(129);
  for (var b2 = a2.textContent || "", c2, d2 = a2.parentNode, e2 = [a2]; null !== d2 && void 0 === (c2 = we.get(d2)) && !("PRE" === d2.nodeName || 1 === d2.nodeType && void 0 !== d2.style && void 0 !== d2.style.whiteSpace && d2.style.whiteSpace.startsWith("pre")); )
    e2.push(d2), d2 = d2.parentNode;
  c2 = void 0 === c2 ? d2 : c2;
  for (d2 = 0; d2 < e2.length; d2++)
    we.set(e2[d2], c2);
  if (null !== c2) {
    b2 = b2.split(/(\r?\n|\t)/);
    a2 = [];
    e2 = b2.length;
    for (c2 = 0; c2 < e2; c2++)
      d2 = b2[c2], "\n" === d2 || "\r\n" === d2 ? a2.push(je()) : "	" === d2 ? a2.push(xe()) : "" !== d2 && a2.push(K$4(d2));
    return { node: a2 };
  }
  b2 = b2.replace(/\r/g, "").replace(/[ \t\n]+/g, " ");
  if ("" === b2)
    return { node: null };
  if (" " === b2[0]) {
    e2 = a2;
    for (c2 = true; null !== e2 && null !== (e2 = ye(e2, false)); )
      if (d2 = e2.textContent || "", 0 < d2.length) {
        /[ \t\n]$/.test(d2) && (b2 = b2.slice(1));
        c2 = false;
        break;
      }
    c2 && (b2 = b2.slice(1));
  }
  if (" " === b2[b2.length - 1]) {
    for (e2 = true; null !== a2 && null !== (a2 = ye(a2, true)); )
      if (0 < (a2.textContent || "").replace(/^( |\t|\r?\n)+/, "").length) {
        e2 = false;
        break;
      }
    e2 && (b2 = b2.slice(0, b2.length - 1));
  }
  return "" === b2 ? { node: null } : { node: K$4(b2) };
}
let ze = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, "i");
function ye(a2, b2) {
  for (; ; ) {
    for (var c2 = void 0; null === (c2 = b2 ? a2.nextSibling : a2.previousSibling); )
      if (a2 = a2.parentElement, null === a2)
        return null;
    a2 = c2;
    if (1 === a2.nodeType && (c2 = a2.style.display, "" === c2 && null === a2.nodeName.match(ze) || "" !== c2 && !c2.startsWith("inline")))
      return null;
    for (; null !== (c2 = b2 ? a2.firstChild : a2.lastChild); )
      a2 = c2;
    if (3 === a2.nodeType)
      return a2;
    if ("BR" === a2.nodeName)
      return null;
  }
}
let Ae = { code: "code", em: "italic", i: "italic", s: "strikethrough", strong: "bold", sub: "subscript", sup: "superscript", u: "underline" };
function se(a2) {
  let b2 = Ae[a2.nodeName.toLowerCase()];
  return void 0 === b2 ? { node: null } : { forChild: (c2) => {
    B$8(c2) && !c2.hasFormat(b2) && c2.toggleFormat(b2);
    return c2;
  }, node: null };
}
function K$4(a2 = "") {
  return zc(new pe(a2));
}
function B$8(a2) {
  return a2 instanceof pe;
}
class Be extends pe {
  static getType() {
    return "tab";
  }
  static clone(a2) {
    let b2 = new Be(a2.__key);
    b2.__text = a2.__text;
    b2.__format = a2.__format;
    b2.__style = a2.__style;
    return b2;
  }
  constructor(a2) {
    super("	", a2);
    this.__detail = 2;
  }
  static importDOM() {
    return null;
  }
  static importJSON(a2) {
    let b2 = xe();
    b2.setFormat(a2.format);
    b2.setStyle(a2.style);
    return b2;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "tab", version: 1 };
  }
  setTextContent() {
    r$a(126);
  }
  setDetail() {
    r$a(127);
  }
  setMode() {
    r$a(128);
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
}
function xe() {
  return zc(new Be());
}
function Ce(a2) {
  return a2 instanceof Be;
}
class De {
  constructor(a2, b2, c2) {
    this._selection = null;
    this.key = a2;
    this.offset = b2;
    this.type = c2;
  }
  is(a2) {
    return this.key === a2.key && this.offset === a2.offset && this.type === a2.type;
  }
  isBefore(a2) {
    let b2 = this.getNode(), c2 = a2.getNode(), d2 = this.offset;
    a2 = a2.offset;
    if (E$6(b2)) {
      var e2 = b2.getDescendantByIndex(d2);
      b2 = null != e2 ? e2 : b2;
    }
    E$6(c2) && (e2 = c2.getDescendantByIndex(a2), c2 = null != e2 ? e2 : c2);
    return b2 === c2 ? d2 < a2 : b2.isBefore(c2);
  }
  getNode() {
    let a2 = I$5(this.key);
    null === a2 && r$a(20);
    return a2;
  }
  set(a2, b2, c2) {
    let d2 = this._selection, e2 = this.key;
    this.key = a2;
    this.offset = b2;
    this.type = c2;
    ec() || (dc() === e2 && H$6(a2), null !== d2 && (d2.setCachedNodes(null), d2.dirty = true));
  }
}
function Ee(a2, b2) {
  let c2 = b2.__key, d2 = a2.offset, e2 = "element";
  if (B$8(b2))
    e2 = "text", b2 = b2.getTextContentSize(), d2 > b2 && (d2 = b2);
  else if (!E$6(b2)) {
    var f2 = b2.getNextSibling();
    if (B$8(f2))
      c2 = f2.__key, d2 = 0, e2 = "text";
    else if (f2 = b2.getParent())
      c2 = f2.__key, d2 = b2.getIndexWithinParent() + 1;
  }
  a2.set(c2, d2, e2);
}
function ee(a2, b2) {
  if (E$6(b2)) {
    let c2 = b2.getLastDescendant();
    E$6(c2) || B$8(c2) ? Ee(a2, c2) : Ee(a2, b2);
  } else
    Ee(a2, b2);
}
function Fe(a2, b2, c2, d2) {
  let e2 = a2.getNode(), f2 = e2.getChildAtIndex(a2.offset), g2 = K$4(), h2 = L$4(e2) ? fe().append(g2) : g2;
  g2.setFormat(c2);
  g2.setStyle(d2);
  null === f2 ? e2.append(h2) : f2.insertBefore(h2);
  a2.is(b2) && b2.set(g2.__key, 0, "text");
  a2.set(g2.__key, 0, "text");
}
function Ge(a2, b2, c2, d2) {
  a2.key = b2;
  a2.offset = c2;
  a2.type = d2;
}
class Qe {
  constructor(a2, b2) {
    this.anchor = a2;
    this.focus = b2;
    a2._selection = this;
    b2._selection = this;
    this._cachedNodes = null;
    this.dirty = false;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(a2) {
    this._cachedNodes = a2;
  }
  is(a2) {
    return de(a2) ? this.anchor.is(a2.anchor) && this.focus.is(a2.focus) : false;
  }
  isCollapsed() {
    return false;
  }
  extract() {
    return this.getNodes();
  }
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getCharacterOffsets() {
    return Re(this);
  }
}
class Se {
  constructor(a2) {
    this.dirty = false;
    this._nodes = a2;
    this._cachedNodes = null;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(a2) {
    this._cachedNodes = a2;
  }
  is(a2) {
    if (!Vd(a2))
      return false;
    let b2 = this._nodes, c2 = a2._nodes;
    return b2.size === c2.size && Array.from(b2).every((d2) => c2.has(d2));
  }
  add(a2) {
    this.dirty = true;
    this._nodes.add(a2);
    this._cachedNodes = null;
  }
  delete(a2) {
    this.dirty = true;
    this._nodes.delete(a2);
    this._cachedNodes = null;
  }
  clear() {
    this.dirty = true;
    this._nodes.clear();
    this._cachedNodes = null;
  }
  has(a2) {
    return this._nodes.has(a2);
  }
  clone() {
    return new Se(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText() {
  }
  insertText() {
  }
  insertNodes(a2) {
    let b2 = this.getNodes(), c2 = b2.length;
    var d2 = b2[c2 - 1];
    if (B$8(d2))
      d2 = d2.select();
    else {
      let e2 = d2.getIndexWithinParent() + 1;
      d2 = d2.getParentOrThrow().select(e2, e2);
    }
    d2.insertNodes(a2);
    for (a2 = 0; a2 < c2; a2++)
      b2[a2].remove();
  }
  getNodes() {
    var a2 = this._cachedNodes;
    if (null !== a2)
      return a2;
    var b2 = this._nodes;
    a2 = [];
    for (let c2 of b2)
      b2 = I$5(c2), null !== b2 && a2.push(b2);
    ec() || (this._cachedNodes = a2);
    return a2;
  }
  getTextContent() {
    let a2 = this.getNodes(), b2 = "";
    for (let c2 = 0; c2 < a2.length; c2++)
      b2 += a2[c2].getTextContent();
    return b2;
  }
}
function C$7(a2) {
  return a2 instanceof Te;
}
function de(a2) {
  return a2 instanceof Qe;
}
function Ue(a2) {
  let [b2, , c2] = Ve(a2);
  a2 = c2.getChildren();
  let d2 = a2.length;
  var e2 = a2[0].getChildren().length;
  let f2 = Array(d2);
  for (var g2 = 0; g2 < d2; g2++)
    f2[g2] = Array(e2);
  for (e2 = 0; e2 < d2; e2++) {
    g2 = a2[e2].getChildren();
    let h2 = 0;
    for (let k2 = 0; k2 < g2.length; k2++) {
      for (; f2[e2][h2]; )
        h2++;
      let m2 = g2[k2], p2 = m2.__rowSpan || 1, n2 = m2.__colSpan || 1;
      for (let l2 = 0; l2 < p2; l2++)
        for (let q2 = 0; q2 < n2; q2++)
          f2[e2 + l2][h2 + q2] = m2;
      if (b2 === m2)
        return { colSpan: n2, columnIndex: h2, rowIndex: e2, rowSpan: p2 };
      h2 += n2;
    }
  }
  return null;
}
class We extends Qe {
  constructor(a2, b2, c2) {
    super(b2, c2);
    this.gridKey = a2;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(a2) {
    this._cachedNodes = a2;
  }
  is(a2) {
    return Xe(a2) ? this.gridKey === a2.gridKey && this.anchor.is(a2.anchor) && this.focus.is(a2.focus) : false;
  }
  set(a2, b2, c2) {
    this.dirty = true;
    this.gridKey = a2;
    this.anchor.key = b2;
    this.focus.key = c2;
    this._cachedNodes = null;
  }
  clone() {
    return new We(this.gridKey, this.anchor, this.focus);
  }
  isCollapsed() {
    return false;
  }
  extract() {
    return this.getNodes();
  }
  insertRawText() {
  }
  insertText() {
  }
  insertNodes(a2) {
    let b2 = this.focus.getNode();
    Ib(b2.select(0, b2.getChildrenSize())).insertNodes(a2);
  }
  getShape() {
    var a2 = I$5(this.anchor.key);
    S$3(a2) || r$a(103);
    a2 = Ue(a2);
    if (null === a2)
      throw Error("getCellRect: expected to find AnchorNode");
    var b2 = I$5(this.focus.key);
    S$3(b2) || r$a(104);
    let c2 = Ue(b2);
    if (null === c2)
      throw Error("getCellRect: expected to find focusCellNode");
    b2 = Math.min(a2.columnIndex, c2.columnIndex);
    let d2 = Math.max(a2.columnIndex, c2.columnIndex), e2 = Math.min(a2.rowIndex, c2.rowIndex);
    a2 = Math.max(a2.rowIndex, c2.rowIndex);
    return { fromX: Math.min(b2, d2), fromY: Math.min(
      e2,
      a2
    ), toX: Math.max(b2, d2), toY: Math.max(e2, a2) };
  }
  getNodes() {
    function a2(y2) {
      let { cell: x3, startColumn: A2, startRow: aa2 } = y2;
      k2 = Math.min(k2, A2);
      m2 = Math.min(m2, aa2);
      p2 = Math.max(p2, A2 + x3.__colSpan - 1);
      n2 = Math.max(n2, aa2 + x3.__rowSpan - 1);
    }
    var b2 = this._cachedNodes;
    if (null !== b2)
      return b2;
    var c2 = this.anchor.getNode();
    b2 = this.focus.getNode();
    var d2 = Dc(c2, S$3);
    c2 = Dc(b2, S$3);
    S$3(d2) || r$a(103);
    S$3(c2) || r$a(104);
    b2 = d2.getParent();
    Ye(b2) || r$a(105);
    b2 = b2.getParent();
    Ze(b2) || r$a(106);
    var e2 = c2.getParents()[1];
    if (e2 !== b2) {
      if (b2.isParentOf(c2)) {
        b2 = e2.getParent();
        if (null == b2)
          throw Error("Expected focusCellParent to have a parent");
        this.set(this.gridKey, c2.getKey(), b2.getKey());
      } else {
        b2 = b2.getParent();
        if (null == b2)
          throw Error("Expected gridParent to have a parent");
        this.set(this.gridKey, b2.getKey(), c2.getKey());
      }
      return this.getNodes();
    }
    let [f2, g2, h2] = $e(b2, d2, c2), k2 = Math.min(g2.startColumn, h2.startColumn), m2 = Math.min(g2.startRow, h2.startRow), p2 = Math.max(g2.startColumn + g2.cell.__colSpan - 1, h2.startColumn + h2.cell.__colSpan - 1), n2 = Math.max(g2.startRow + g2.cell.__rowSpan - 1, h2.startRow + h2.cell.__rowSpan - 1);
    c2 = k2;
    d2 = m2;
    e2 = k2;
    for (var l2 = m2; k2 < c2 || m2 < d2 || p2 > e2 || n2 > l2; ) {
      if (k2 < c2) {
        var q2 = l2 - d2;
        --c2;
        for (var u2 = 0; u2 <= q2; u2++)
          a2(f2[d2 + u2][c2]);
      }
      if (m2 < d2)
        for (q2 = e2 - c2, --d2, u2 = 0; u2 <= q2; u2++)
          a2(f2[d2][c2 + u2]);
      if (p2 > e2)
        for (q2 = l2 - d2, e2 += 1, u2 = 0; u2 <= q2; u2++)
          a2(f2[d2 + u2][e2]);
      if (n2 > l2)
        for (q2 = e2 - c2, l2 += 1, u2 = 0; u2 <= q2; u2++)
          a2(f2[l2][c2 + u2]);
    }
    b2 = [b2];
    c2 = null;
    for (d2 = m2; d2 <= n2; d2++)
      for (e2 = k2; e2 <= p2; e2++)
        ({ cell: l2 } = f2[d2][e2]), q2 = l2.getParent(), Ye(q2) || r$a(107), q2 !== c2 && b2.push(q2), b2.push(l2, ...Ec(l2)), c2 = q2;
    ec() || (this._cachedNodes = b2);
    return b2;
  }
  getTextContent() {
    let a2 = this.getNodes(), b2 = "";
    for (let c2 = 0; c2 < a2.length; c2++)
      b2 += a2[c2].getTextContent();
    return b2;
  }
}
function Xe(a2) {
  return a2 instanceof We;
}
class Te extends Qe {
  constructor(a2, b2, c2, d2) {
    super(a2, b2);
    this.format = c2;
    this.style = d2;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(a2) {
    this._cachedNodes = a2;
  }
  is(a2) {
    return C$7(a2) ? this.anchor.is(a2.anchor) && this.focus.is(a2.focus) && this.format === a2.format && this.style === a2.style : false;
  }
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  getNodes() {
    var a2 = this._cachedNodes;
    if (null !== a2)
      return a2;
    a2 = this.anchor;
    var b2 = this.focus, c2 = a2.isBefore(b2), d2 = c2 ? a2 : b2;
    c2 = c2 ? b2 : a2;
    a2 = d2.getNode();
    b2 = c2.getNode();
    let e2 = d2.offset;
    d2 = c2.offset;
    E$6(a2) && (c2 = a2.getDescendantByIndex(e2), a2 = null != c2 ? c2 : a2);
    E$6(b2) && (c2 = b2.getDescendantByIndex(d2), null !== c2 && c2 !== a2 && b2.getChildAtIndex(d2) === c2 && (c2 = c2.getPreviousSibling()), b2 = null != c2 ? c2 : b2);
    a2 = a2.is(b2) ? E$6(a2) && 0 < a2.getChildrenSize() ? [] : [a2] : a2.getNodesBetween(b2);
    ec() || (this._cachedNodes = a2);
    return a2;
  }
  setTextNodeRange(a2, b2, c2, d2) {
    Ge(this.anchor, a2.__key, b2, "text");
    Ge(this.focus, c2.__key, d2, "text");
    this._cachedNodes = null;
    this.dirty = true;
  }
  getTextContent() {
    let a2 = this.getNodes();
    if (0 === a2.length)
      return "";
    let b2 = a2[0], c2 = a2[a2.length - 1], d2 = this.anchor, e2 = this.focus, f2 = d2.isBefore(e2), [g2, h2] = Re(this), k2 = "", m2 = true;
    for (let p2 = 0; p2 < a2.length; p2++) {
      let n2 = a2[p2];
      if (E$6(n2) && !n2.isInline())
        m2 || (k2 += "\n"), m2 = n2.isEmpty() ? false : true;
      else if (m2 = false, B$8(n2)) {
        let l2 = n2.getTextContent();
        if (n2 === b2)
          if (n2 === c2) {
            if ("element" !== d2.type || "element" !== e2.type || e2.offset === d2.offset)
              l2 = g2 < h2 ? l2.slice(g2, h2) : l2.slice(h2, g2);
          } else
            l2 = f2 ? l2.slice(g2) : l2.slice(h2);
        else
          n2 === c2 && (l2 = f2 ? l2.slice(0, h2) : l2.slice(0, g2));
        k2 += l2;
      } else
        !z$7(n2) && !Hc(n2) || n2 === c2 && this.isCollapsed() || (k2 += n2.getTextContent());
    }
    return k2;
  }
  applyDOMRange(a2) {
    let b2 = F$6(), c2 = b2.getEditorState()._selection;
    a2 = af(a2.startContainer, a2.startOffset, a2.endContainer, a2.endOffset, b2, c2);
    if (null !== a2) {
      var [d2, e2] = a2;
      Ge(this.anchor, d2.key, d2.offset, d2.type);
      Ge(this.focus, e2.key, e2.offset, e2.type);
      this._cachedNodes = null;
    }
  }
  clone() {
    let a2 = this.anchor, b2 = this.focus;
    return new Te(new De(a2.key, a2.offset, a2.type), new De(b2.key, b2.offset, b2.type), this.format, this.style);
  }
  toggleFormat(a2) {
    this.format = Yb(this.format, a2, null);
    this.dirty = true;
  }
  setStyle(a2) {
    this.style = a2;
    this.dirty = true;
  }
  hasFormat(a2) {
    return 0 !== (this.format & hb[a2]);
  }
  insertRawText(a2) {
    a2 = a2.split(/(\r?\n|\t)/);
    let b2 = [], c2 = a2.length;
    for (let d2 = 0; d2 < c2; d2++) {
      let e2 = a2[d2];
      "\n" === e2 || "\r\n" === e2 ? b2.push(je()) : "	" === e2 ? b2.push(xe()) : b2.push(K$4(e2));
    }
    this.insertNodes(b2);
  }
  insertText(a2) {
    var b2 = this.anchor, c2 = this.focus, d2 = this.isCollapsed() || b2.isBefore(c2), e2 = this.format, f2 = this.style;
    d2 && "element" === b2.type ? Fe(b2, c2, e2, f2) : d2 || "element" !== c2.type || Fe(c2, b2, e2, f2);
    var g2 = this.getNodes(), h2 = g2.length, k2 = d2 ? c2 : b2;
    c2 = (d2 ? b2 : c2).offset;
    var m2 = k2.offset;
    b2 = g2[0];
    B$8(b2) || r$a(26);
    d2 = b2.getTextContent().length;
    var p2 = b2.getParentOrThrow(), n2 = g2[h2 - 1];
    if (this.isCollapsed() && c2 === d2 && (b2.isSegmented() || b2.isToken() || !b2.canInsertTextAfter() || !p2.canInsertTextAfter() && null === b2.getNextSibling())) {
      var l2 = b2.getNextSibling();
      B$8(l2) && l2.canInsertTextBefore() && !Wb(l2) || (l2 = K$4(), l2.setFormat(e2), p2.canInsertTextAfter() ? b2.insertAfter(l2) : p2.insertAfter(l2));
      l2.select(0, 0);
      b2 = l2;
      if ("" !== a2) {
        this.insertText(a2);
        return;
      }
    } else if (this.isCollapsed() && 0 === c2 && (b2.isSegmented() || b2.isToken() || !b2.canInsertTextBefore() || !p2.canInsertTextBefore() && null === b2.getPreviousSibling())) {
      l2 = b2.getPreviousSibling();
      if (!B$8(l2) || Wb(l2))
        l2 = K$4(), l2.setFormat(e2), p2.canInsertTextBefore() ? b2.insertBefore(l2) : p2.insertBefore(l2);
      l2.select();
      b2 = l2;
      if ("" !== a2) {
        this.insertText(a2);
        return;
      }
    } else if (b2.isSegmented() && c2 !== d2)
      p2 = K$4(b2.getTextContent()), p2.setFormat(e2), b2.replace(p2), b2 = p2;
    else if (!(this.isCollapsed() || "" === a2 || (l2 = n2.getParent(), p2.canInsertTextBefore() && p2.canInsertTextAfter() && (!E$6(l2) || l2.canInsertTextBefore() && l2.canInsertTextAfter())))) {
      this.insertText("");
      bf(this.anchor, this.focus, null);
      this.insertText(a2);
      return;
    }
    if (1 === h2)
      if (b2.isToken())
        a2 = K$4(a2), a2.select(), b2.replace(a2);
      else {
        g2 = b2.getFormat();
        h2 = b2.getStyle();
        if (c2 === m2 && (g2 !== e2 || h2 !== f2))
          if ("" === b2.getTextContent())
            b2.setFormat(e2), b2.setStyle(f2);
          else {
            g2 = K$4(a2);
            g2.setFormat(e2);
            g2.setStyle(f2);
            g2.select();
            0 === c2 ? b2.insertBefore(g2, false) : ([h2] = b2.splitText(c2), h2.insertAfter(g2, false));
            g2.isComposing() && "text" === this.anchor.type && (this.anchor.offset -= a2.length);
            return;
          }
        else if (Ce(b2)) {
          a2 = K$4(a2);
          a2.setFormat(e2);
          a2.setStyle(f2);
          a2.select();
          b2.replace(a2);
          return;
        }
        b2 = b2.spliceText(c2, m2 - c2, a2, true);
        "" === b2.getTextContent() ? b2.remove() : "text" === this.anchor.type && (b2.isComposing() ? this.anchor.offset -= a2.length : (this.format = g2, this.style = h2));
      }
    else {
      e2 = /* @__PURE__ */ new Set([...b2.getParentKeys(), ...n2.getParentKeys()]);
      l2 = E$6(b2) ? b2 : b2.getParentOrThrow();
      f2 = E$6(n2) ? n2 : n2.getParentOrThrow();
      p2 = n2;
      if (!l2.is(f2) && f2.isInline()) {
        do
          p2 = f2, f2 = f2.getParentOrThrow();
        while (f2.isInline());
      }
      if ("text" === k2.type && (0 !== m2 || "" === n2.getTextContent()) || "element" === k2.type && n2.getIndexWithinParent() < m2)
        if (B$8(n2) && !n2.isToken() && m2 !== n2.getTextContentSize()) {
          if (n2.isSegmented()) {
            var q2 = K$4(n2.getTextContent());
            n2.replace(q2);
            n2 = q2;
          }
          L$4(k2.getNode()) || "text" !== k2.type || (n2 = n2.spliceText(0, m2, ""));
          e2.add(n2.__key);
        } else
          k2 = n2.getParentOrThrow(), k2.canBeEmpty() || 1 !== k2.getChildrenSize() ? n2.remove() : k2.remove();
      else
        e2.add(n2.__key);
      k2 = f2.getChildren();
      m2 = new Set(g2);
      n2 = l2.is(f2);
      l2 = l2.isInline() && null === b2.getNextSibling() ? l2 : b2;
      for (q2 = k2.length - 1; 0 <= q2; q2--) {
        let u2 = k2[q2];
        if (u2.is(b2) || E$6(u2) && u2.isParentOf(b2))
          break;
        u2.isAttached() && (!m2.has(u2) || u2.is(p2) ? n2 || l2.insertAfter(u2, false) : u2.remove());
      }
      if (!n2)
        for (k2 = f2, f2 = null; null !== k2; ) {
          m2 = k2.getChildren();
          n2 = m2.length;
          if (0 === n2 || m2[n2 - 1].is(f2))
            e2.delete(k2.__key), f2 = k2;
          k2 = k2.getParent();
        }
      b2.isToken() ? c2 === d2 ? b2.select() : (a2 = K$4(a2), a2.select(), b2.replace(a2)) : (b2 = b2.spliceText(c2, d2 - c2, a2, true), "" === b2.getTextContent() ? b2.remove() : b2.isComposing() && "text" === this.anchor.type && (this.anchor.offset -= a2.length));
      for (a2 = 1; a2 < h2; a2++)
        b2 = g2[a2], e2.has(b2.__key) || b2.remove();
    }
  }
  removeText() {
    this.insertText("");
  }
  formatText(a2) {
    if (this.isCollapsed())
      this.toggleFormat(a2), H$6(null);
    else {
      var b2 = this.getNodes(), c2 = [];
      for (var d2 of b2)
        B$8(d2) && c2.push(d2);
      var e2 = c2.length;
      if (0 === e2)
        this.toggleFormat(a2), H$6(null);
      else {
        d2 = this.anchor;
        var f2 = this.focus, g2 = this.isBackward();
        b2 = g2 ? f2 : d2;
        d2 = g2 ? d2 : f2;
        var h2 = 0, k2 = c2[0];
        f2 = "element" === b2.type ? 0 : b2.offset;
        "text" === b2.type && f2 === k2.getTextContentSize() && (h2 = 1, k2 = c2[1], f2 = 0);
        if (null != k2) {
          g2 = k2.getFormatFlags(a2, null);
          var m2 = e2 - 1, p2 = c2[m2];
          e2 = "text" === d2.type ? d2.offset : p2.getTextContentSize();
          if (k2.is(p2))
            f2 !== e2 && (0 === f2 && e2 === k2.getTextContentSize() ? k2.setFormat(g2) : (a2 = k2.splitText(f2, e2), a2 = 0 === f2 ? a2[0] : a2[1], a2.setFormat(g2), "text" === b2.type && b2.set(a2.__key, 0, "text"), "text" === d2.type && d2.set(a2.__key, e2 - f2, "text")), this.format = g2);
          else {
            0 !== f2 && ([, k2] = k2.splitText(f2), f2 = 0);
            k2.setFormat(g2);
            var n2 = p2.getFormatFlags(a2, g2);
            0 < e2 && (e2 !== p2.getTextContentSize() && ([p2] = p2.splitText(e2)), p2.setFormat(n2));
            for (h2 += 1; h2 < m2; h2++) {
              let l2 = c2[h2];
              if (!l2.isToken()) {
                let q2 = l2.getFormatFlags(a2, n2);
                l2.setFormat(q2);
              }
            }
            "text" === b2.type && b2.set(k2.__key, f2, "text");
            "text" === d2.type && d2.set(p2.__key, e2, "text");
            this.format = g2 | n2;
          }
        }
      }
    }
  }
  insertNodes(a2) {
    if (0 !== a2.length) {
      if ("root" === this.anchor.key) {
        this.insertParagraph();
        var b2 = v$8();
        if (!C$7(b2))
          throw Error("Expected RangeSelection after insertParagraph");
        return b2.insertNodes(a2);
      }
      var c2 = Ic(this.anchor.getNode(), Gc);
      b2 = a2[a2.length - 1];
      if ("__language" in c2)
        if ("__language" in a2[0])
          this.insertText(a2[0].getTextContent());
        else {
          var d2 = cf(this);
          c2.splice(d2, 0, a2);
          b2.selectEnd();
        }
      else if (a2.some((g2) => (E$6(g2) || z$7(g2)) && !g2.isInline())) {
        b2 = df(a2);
        a2 = b2.getLastDescendant();
        var e2 = b2.getChildren();
        b2 = E$6(c2) && c2.isEmpty() ? null : this.insertParagraph();
        d2 = e2[e2.length - 1];
        var f2 = e2[0];
        ((g2) => E$6(g2) && Gc(g2) && !g2.isEmpty() && E$6(c2) && (!c2.isEmpty() || "__value" in c2 && "__checked" in c2))(f2) && (c2.append(...f2.getChildren()), f2 = e2[1]);
        f2 && ge(c2, f2);
        e2 = Ic(a2, Gc);
        b2 && E$6(e2) && ("__value" in b2 && "__checked" in b2 || Gc(d2)) && (e2.append(...b2.getChildren()), b2.remove());
        E$6(c2) && c2.isEmpty() && c2.remove();
        a2.selectEnd();
        a2 = E$6(c2) ? c2.getLastChild() : null;
        Hc(a2) && e2 !== c2 && a2.remove();
      } else
        d2 = cf(this), c2.splice(d2, 0, a2), b2.selectEnd();
    }
  }
  insertParagraph() {
    if ("root" === this.anchor.key) {
      var a2 = fe();
      J$4().splice(this.anchor.offset, 0, [a2]);
      a2.select();
      return a2;
    }
    var b2 = cf(this);
    a2 = Ic(this.anchor.getNode(), Gc);
    b2 = (b2 = a2.getChildAtIndex(b2)) ? [b2, ...b2.getNextSiblings()] : [];
    return (a2 = a2.insertNewAfter(this, false)) ? (a2.append(...b2), a2.selectStart(), a2) : null;
  }
  insertLineBreak(a2) {
    var b2 = je();
    this.insertNodes([b2]);
    a2 && (a2 = b2.getParentOrThrow(), b2 = b2.getIndexWithinParent(), a2.select(b2, b2));
  }
  extract() {
    var a2 = this.getNodes(), b2 = a2.length, c2 = b2 - 1, d2 = this.anchor;
    let e2 = this.focus;
    var f2 = a2[0];
    let g2 = a2[c2], [h2, k2] = Re(this);
    if (0 === b2)
      return [];
    if (1 === b2)
      return B$8(f2) && !this.isCollapsed() ? (a2 = h2 > k2 ? k2 : h2, c2 = f2.splitText(a2, h2 > k2 ? h2 : k2), a2 = 0 === a2 ? c2[0] : c2[1], null != a2 ? [a2] : []) : [f2];
    b2 = d2.isBefore(e2);
    B$8(f2) && (d2 = b2 ? h2 : k2, d2 === f2.getTextContentSize() ? a2.shift() : 0 !== d2 && ([, f2] = f2.splitText(d2), a2[0] = f2));
    B$8(g2) && (f2 = g2.getTextContent().length, b2 = b2 ? k2 : h2, 0 === b2 ? a2.pop() : b2 !== f2 && ([g2] = g2.splitText(b2), a2[c2] = g2));
    return a2;
  }
  modify(a2, b2, c2) {
    var d2 = this.focus, e2 = this.anchor, f2 = "move" === a2, g2 = sc(d2, b2);
    if (z$7(g2) && !g2.isIsolated())
      f2 && g2.isKeyboardSelectable() ? (b2 = ef(), b2.add(g2.__key), Ab(b2)) : (a2 = b2 ? g2.getPreviousSibling() : g2.getNextSibling(), B$8(a2) ? (g2 = a2.__key, b2 = b2 ? a2.getTextContent().length : 0, d2.set(g2, b2, "text"), f2 && e2.set(g2, b2, "text")) : (c2 = g2.getParentOrThrow(), E$6(a2) ? (c2 = a2.__key, g2 = b2 ? a2.getChildrenSize() : 0) : (g2 = g2.getIndexWithinParent(), c2 = c2.__key, b2 || g2++), d2.set(c2, g2, "element"), f2 && e2.set(c2, g2, "element")));
    else if (e2 = F$6(), d2 = xb(e2._window)) {
      var h2 = e2._blockCursorElement, k2 = e2._rootElement;
      null === k2 || null === h2 || !E$6(g2) || g2.isInline() || g2.canBeEmpty() || Cc(h2, e2, k2);
      d2.modify(a2, b2 ? "backward" : "forward", c2);
      if (0 < d2.rangeCount && (g2 = d2.getRangeAt(0), e2 = this.anchor.getNode(), e2 = L$4(e2) ? e2 : wc(e2), this.applyDOMRange(g2), this.dirty = true, !f2)) {
        f2 = this.getNodes();
        a2 = [];
        c2 = false;
        for (h2 = 0; h2 < f2.length; h2++)
          k2 = f2[h2], vc(k2, e2) ? a2.push(k2) : c2 = true;
        c2 && 0 < a2.length && (b2 ? (b2 = a2[0], E$6(b2) ? b2.selectStart() : b2.getParentOrThrow().selectStart()) : (b2 = a2[a2.length - 1], E$6(b2) ? b2.selectEnd() : b2.getParentOrThrow().selectEnd()));
        if (d2.anchorNode !== g2.startContainer || d2.anchorOffset !== g2.startOffset)
          b2 = this.focus, f2 = this.anchor, d2 = f2.key, g2 = f2.offset, e2 = f2.type, Ge(f2, b2.key, b2.offset, b2.type), Ge(b2, d2, g2, e2), this._cachedNodes = null;
      }
    }
  }
  deleteCharacter(a2) {
    let b2 = this.isCollapsed();
    if (this.isCollapsed()) {
      var c2 = this.anchor, d2 = this.focus, e2 = c2.getNode();
      if (!a2 && ("element" === c2.type && E$6(e2) && c2.offset === e2.getChildrenSize() || "text" === c2.type && c2.offset === e2.getTextContentSize())) {
        var f2 = e2.getParent();
        f2 = e2.getNextSibling() || (null === f2 ? null : f2.getNextSibling());
        if (E$6(f2) && f2.isShadowRoot())
          return;
      }
      f2 = sc(d2, a2);
      if (z$7(f2) && !f2.isIsolated()) {
        f2.isKeyboardSelectable() && E$6(e2) && 0 === e2.getChildrenSize() ? (e2.remove(), a2 = ef(), a2.add(f2.__key), Ab(a2)) : (f2.remove(), F$6().dispatchCommand(ba$2, void 0));
        return;
      }
      if (!a2 && E$6(f2) && E$6(e2) && e2.isEmpty()) {
        e2.remove();
        f2.selectStart();
        return;
      }
      this.modify("extend", a2, "character");
      if (!this.isCollapsed()) {
        f2 = "text" === d2.type ? d2.getNode() : null;
        e2 = "text" === c2.type ? c2.getNode() : null;
        if (null !== f2 && f2.isSegmented()) {
          if (c2 = d2.offset, d2 = f2.getTextContentSize(), f2.is(e2) || a2 && c2 !== d2 || !a2 && 0 !== c2) {
            ff(f2, a2, c2);
            return;
          }
        } else if (null !== e2 && e2.isSegmented() && (c2 = c2.offset, d2 = e2.getTextContentSize(), e2.is(f2) || a2 && 0 !== c2 || !a2 && c2 !== d2)) {
          ff(e2, a2, c2);
          return;
        }
        e2 = this.anchor;
        f2 = this.focus;
        c2 = e2.getNode();
        d2 = f2.getNode();
        if (c2 === d2 && "text" === e2.type && "text" === f2.type) {
          var g2 = e2.offset, h2 = f2.offset;
          let k2 = g2 < h2;
          d2 = k2 ? g2 : h2;
          h2 = k2 ? h2 : g2;
          g2 = h2 - 1;
          d2 !== g2 && (c2 = c2.getTextContent().slice(d2, h2), jc(c2) || (a2 ? f2.offset = g2 : e2.offset = g2));
        }
      } else if (a2 && 0 === c2.offset && ("element" === c2.type ? c2.getNode() : c2.getNode().getParentOrThrow()).collapseAtStart(this))
        return;
    }
    this.removeText();
    a2 && !b2 && this.isCollapsed() && "element" === this.anchor.type && 0 === this.anchor.offset && (a2 = this.anchor.getNode(), a2.isEmpty() && L$4(a2.getParent()) && 0 === a2.getIndexWithinParent() && a2.collapseAtStart(this));
  }
  deleteLine(a2) {
    this.isCollapsed() && ("text" === this.anchor.type && this.modify("extend", a2, "lineboundary"), 0 === (a2 ? this.focus : this.anchor).offset && this.modify("extend", a2, "character"));
    this.removeText();
  }
  deleteWord(a2) {
    this.isCollapsed() && this.modify("extend", a2, "word");
    this.removeText();
  }
}
function Vd(a2) {
  return a2 instanceof Se;
}
function gf(a2) {
  let b2 = a2.offset;
  if ("text" === a2.type)
    return b2;
  a2 = a2.getNode();
  return b2 === a2.getChildrenSize() ? a2.getTextContent().length : 0;
}
function Re(a2) {
  let b2 = a2.anchor;
  a2 = a2.focus;
  return "element" === b2.type && "element" === a2.type && b2.key === a2.key && b2.offset === a2.offset ? [0, 0] : [gf(b2), gf(a2)];
}
function ff(a2, b2, c2) {
  let d2 = a2.getTextContent().split(/(?=\s)/g), e2 = d2.length, f2 = 0, g2 = 0;
  for (let h2 = 0; h2 < e2; h2++) {
    let k2 = d2[h2], m2 = h2 === e2 - 1;
    g2 = f2;
    f2 += k2.length;
    if (b2 && f2 === c2 || f2 > c2 || m2) {
      d2.splice(h2, 1);
      m2 && (g2 = void 0);
      break;
    }
  }
  b2 = d2.join("").trim();
  "" === b2 ? a2.remove() : (a2.setTextContent(b2), a2.select(g2, g2));
}
function hf(a2, b2, c2, d2) {
  var e2 = b2;
  if (1 === a2.nodeType) {
    let h2 = false;
    var f2 = a2.childNodes, g2 = f2.length;
    e2 === g2 && (h2 = true, e2 = g2 - 1);
    let k2 = f2[e2];
    g2 = false;
    k2 === d2._blockCursorElement ? (k2 = f2[e2 + 1], g2 = true) : null !== d2._blockCursorElement && e2--;
    d2 = ic(k2);
    if (B$8(d2))
      e2 = h2 ? d2.getTextContentSize() : 0;
    else {
      f2 = ic(a2);
      if (null === f2)
        return null;
      if (E$6(f2)) {
        a2 = f2.getChildAtIndex(e2);
        if (b2 = E$6(a2))
          b2 = a2.getParent(), b2 = null === c2 || null === b2 || !b2.canBeEmpty() || b2 !== c2.getNode();
        b2 && (c2 = h2 ? a2.getLastDescendant() : a2.getFirstDescendant(), null === c2 ? (f2 = a2, e2 = 0) : (a2 = c2, f2 = E$6(a2) ? a2 : a2.getParentOrThrow()));
        B$8(a2) ? (d2 = a2, f2 = null, e2 = h2 ? a2.getTextContentSize() : 0) : a2 !== f2 && h2 && !g2 && e2++;
      } else
        e2 = f2.getIndexWithinParent(), e2 = 0 === b2 && z$7(f2) && ic(a2) === f2 ? e2 : e2 + 1, f2 = f2.getParentOrThrow();
      if (E$6(f2))
        return new De(f2.__key, e2, "element");
    }
  } else
    d2 = ic(a2);
  return B$8(d2) ? new De(d2.__key, e2, "text") : null;
}
function jf(a2, b2, c2) {
  var d2 = a2.offset, e2 = a2.getNode();
  0 === d2 ? (d2 = e2.getPreviousSibling(), e2 = e2.getParent(), b2) ? (c2 || !b2) && null === d2 && E$6(e2) && e2.isInline() && (b2 = e2.getPreviousSibling(), B$8(b2) && (a2.key = b2.__key, a2.offset = b2.getTextContent().length)) : E$6(d2) && !c2 && d2.isInline() ? (a2.key = d2.__key, a2.offset = d2.getChildrenSize(), a2.type = "element") : B$8(d2) && (a2.key = d2.__key, a2.offset = d2.getTextContent().length) : d2 === e2.getTextContent().length && (d2 = e2.getNextSibling(), e2 = e2.getParent(), b2 && E$6(d2) && d2.isInline() ? (a2.key = d2.__key, a2.offset = 0, a2.type = "element") : (c2 || b2) && null === d2 && E$6(e2) && e2.isInline() && !e2.canInsertTextAfter() && (b2 = e2.getNextSibling(), B$8(b2) && (a2.key = b2.__key, a2.offset = 0)));
}
function bf(a2, b2, c2) {
  if ("text" === a2.type && "text" === b2.type) {
    var d2 = a2.isBefore(b2);
    let e2 = a2.is(b2);
    jf(a2, d2, e2);
    jf(b2, !d2, e2);
    e2 && (b2.key = a2.key, b2.offset = a2.offset, b2.type = a2.type);
    d2 = F$6();
    d2.isComposing() && d2._compositionKey !== a2.key && C$7(c2) && (d2 = c2.anchor, c2 = c2.focus, Ge(a2, d2.key, d2.offset, d2.type), Ge(b2, c2.key, c2.offset, c2.type));
  }
}
function af(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || null === c2 || !Nb(e2, a2, c2))
    return null;
  b2 = hf(a2, b2, C$7(f2) ? f2.anchor : null, e2);
  if (null === b2)
    return null;
  d2 = hf(c2, d2, C$7(f2) ? f2.focus : null, e2);
  if (null === d2 || "element" === b2.type && "element" === d2.type && (a2 = ic(a2), c2 = ic(c2), z$7(a2) && z$7(c2)))
    return null;
  bf(b2, d2, f2);
  return [b2, d2];
}
function ue(a2, b2, c2, d2, e2, f2) {
  let g2 = ac();
  a2 = new Te(new De(a2, b2, e2), new De(c2, d2, f2), 0, "");
  a2.dirty = true;
  return g2._selection = a2;
}
function ef() {
  return new Se(/* @__PURE__ */ new Set());
}
function kf(a2) {
  let b2 = a2.getEditorState()._selection, c2 = xb(a2._window);
  return C$7(b2) || null == b2 ? Rd(b2, c2, a2) : b2.clone();
}
function Rd(a2, b2, c2) {
  var d2 = c2._window;
  if (null === d2)
    return null;
  var e2 = d2.event, f2 = e2 ? e2.type : void 0;
  d2 = "selectionchange" === f2;
  e2 = !qb && (d2 || "beforeinput" === f2 || "compositionstart" === f2 || "compositionend" === f2 || "click" === f2 && e2 && 3 === e2.detail || "drop" === f2 || void 0 === f2);
  let g2;
  if (!C$7(a2) || e2) {
    if (null === b2)
      return null;
    e2 = b2.anchorNode;
    f2 = b2.focusNode;
    g2 = b2.anchorOffset;
    b2 = b2.focusOffset;
    if (d2 && C$7(a2) && !Nb(c2, e2, f2))
      return a2.clone();
  } else
    return a2.clone();
  c2 = af(e2, g2, f2, b2, c2, a2);
  if (null === c2)
    return null;
  let [h2, k2] = c2;
  return new Te(h2, k2, C$7(a2) ? a2.format : 0, C$7(a2) ? a2.style : "");
}
function v$8() {
  return ac()._selection;
}
function nc() {
  return F$6()._editorState._selection;
}
function be(a2, b2, c2, d2 = 1) {
  var e2 = a2.anchor, f2 = a2.focus, g2 = e2.getNode(), h2 = f2.getNode();
  if (b2.is(g2) || b2.is(h2)) {
    g2 = b2.__key;
    if (a2.isCollapsed()) {
      if (b2 = e2.offset, c2 <= b2 && 0 < d2 || c2 < b2 && 0 > d2)
        c2 = Math.max(0, b2 + d2), e2.set(g2, c2, "element"), f2.set(g2, c2, "element"), lf(a2);
    } else {
      let m2 = a2.isBackward();
      h2 = m2 ? f2 : e2;
      var k2 = h2.getNode();
      e2 = m2 ? e2 : f2;
      f2 = e2.getNode();
      b2.is(k2) && (k2 = h2.offset, (c2 <= k2 && 0 < d2 || c2 < k2 && 0 > d2) && h2.set(g2, Math.max(0, k2 + d2), "element"));
      b2.is(f2) && (b2 = e2.offset, (c2 <= b2 && 0 < d2 || c2 < b2 && 0 > d2) && e2.set(g2, Math.max(0, b2 + d2), "element"));
    }
    lf(a2);
  }
}
function lf(a2) {
  var b2 = a2.anchor, c2 = b2.offset;
  let d2 = a2.focus;
  var e2 = d2.offset, f2 = b2.getNode(), g2 = d2.getNode();
  if (a2.isCollapsed())
    E$6(f2) && (g2 = f2.getChildrenSize(), g2 = (e2 = c2 >= g2) ? f2.getChildAtIndex(g2 - 1) : f2.getChildAtIndex(c2), B$8(g2) && (c2 = 0, e2 && (c2 = g2.getTextContentSize()), b2.set(g2.__key, c2, "text"), d2.set(g2.__key, c2, "text")));
  else {
    if (E$6(f2)) {
      let h2 = f2.getChildrenSize();
      c2 = (a2 = c2 >= h2) ? f2.getChildAtIndex(h2 - 1) : f2.getChildAtIndex(c2);
      B$8(c2) && (f2 = 0, a2 && (f2 = c2.getTextContentSize()), b2.set(c2.__key, f2, "text"));
    }
    E$6(g2) && (c2 = g2.getChildrenSize(), e2 = (b2 = e2 >= c2) ? g2.getChildAtIndex(c2 - 1) : g2.getChildAtIndex(e2), B$8(e2) && (g2 = 0, b2 && (g2 = e2.getTextContentSize()), d2.set(e2.__key, g2, "text")));
  }
}
function mf(a2, b2) {
  b2 = b2.getEditorState()._selection;
  a2 = a2._selection;
  if (C$7(a2)) {
    var c2 = a2.anchor;
    let d2 = a2.focus, e2;
    "text" === c2.type && (e2 = c2.getNode(), e2.selectionTransform(b2, a2));
    "text" === d2.type && (c2 = d2.getNode(), e2 !== c2 && c2.selectionTransform(b2, a2));
  }
}
function ae(a2, b2, c2, d2, e2) {
  let f2 = null, g2 = 0, h2 = null;
  null !== d2 ? (f2 = d2.__key, B$8(d2) ? (g2 = d2.getTextContentSize(), h2 = "text") : E$6(d2) && (g2 = d2.getChildrenSize(), h2 = "element")) : null !== e2 && (f2 = e2.__key, B$8(e2) ? h2 = "text" : E$6(e2) && (h2 = "element"));
  null !== f2 && null !== h2 ? a2.set(f2, g2, h2) : (g2 = b2.getIndexWithinParent(), -1 === g2 && (g2 = c2.getChildrenSize()), a2.set(c2.__key, g2, "element"));
}
function ve(a2, b2, c2, d2, e2) {
  "text" === a2.type ? (a2.key = c2, b2 || (a2.offset += e2)) : a2.offset > d2.getIndexWithinParent() && --a2.offset;
}
function $e(a2, b2, c2) {
  let d2 = [], e2 = null, f2 = null;
  a2 = a2.getChildren();
  for (let p2 = 0; p2 < a2.length; p2++) {
    var g2 = a2[p2];
    Ye(g2) || r$a(108);
    var h2 = g2.getChildren();
    g2 = 0;
    for (let n2 of h2) {
      for (S$3(n2) || r$a(109); void 0 !== d2[p2] && void 0 !== d2[p2][g2]; )
        g2++;
      h2 = p2;
      var k2 = g2, m2 = n2;
      let l2 = { cell: m2, startColumn: k2, startRow: h2 }, q2 = m2.__rowSpan, u2 = m2.__colSpan;
      for (let y2 = 0; y2 < q2; y2++) {
        void 0 === d2[h2 + y2] && (d2[h2 + y2] = []);
        for (let x3 = 0; x3 < u2; x3++)
          d2[h2 + y2][k2 + x3] = l2;
      }
      b2.is(m2) && (e2 = l2);
      c2.is(m2) && (f2 = l2);
      g2 += n2.__colSpan;
    }
  }
  null === e2 && r$a(110);
  null === f2 && r$a(111);
  return [d2, e2, f2];
}
function Ve(a2) {
  a2 instanceof nf || (a2 instanceof ce ? (a2 = Dc(a2, S$3), S$3(a2) || r$a(114)) : (a2 = Dc(a2.getNode(), S$3), S$3(a2) || r$a(114)));
  let b2 = a2.getParent();
  Ye(b2) || r$a(115);
  let c2 = b2.getParent();
  Ze(c2) || r$a(116);
  return [a2, b2, c2];
}
function cf(a2) {
  a2.isCollapsed() || a2.removeText();
  var b2 = a2.anchor, c2 = b2.getNode();
  if (!B$8(c2))
    return b2.offset;
  let d2 = c2.getParent();
  if (!d2)
    return a2 = fe(), J$4().append(a2), a2.select(), 0;
  c2 = c2.splitText(b2.offset);
  if (0 === c2.length)
    return 0;
  b2 = 0 === b2.offset ? 0 : 1;
  c2 = c2[0].getIndexWithinParent() + b2;
  if (!d2.isInline() || 0 === c2)
    return c2;
  (c2 = d2.getChildAtIndex(c2)) && d2.insertNewAfter(a2).append(c2, ...c2.getNextSiblings());
  return d2.getIndexWithinParent() + b2;
}
function df(a2) {
  let b2 = fe(), c2 = null;
  for (let d2 = 0; d2 < a2.length; d2++) {
    let e2 = a2[d2], f2 = Hc(e2);
    if (f2 || z$7(e2) && e2.isInline() || E$6(e2) && e2.isInline() || B$8(e2) || e2.isParentRequired()) {
      if (null === c2 && (c2 = e2.createParentElementNode(), b2.append(c2), f2))
        continue;
      null !== c2 && c2.append(e2);
    } else
      b2.append(e2), c2 = null;
  }
  return b2;
}
let T$3 = null, U$3 = null, W$2 = false, of = false, $b = 0, pf = { characterData: true, childList: true, subtree: true };
function ec() {
  return W$2 || null !== T$3 && T$3._readOnly;
}
function G$6() {
  W$2 && r$a(13);
}
function ac() {
  null === T$3 && r$a(15);
  return T$3;
}
function F$6() {
  null === U$3 && r$a(16);
  return U$3;
}
function qf(a2, b2, c2) {
  var d2 = b2.__type;
  let e2 = a2._nodes.get(d2);
  void 0 === e2 && r$a(30, d2);
  a2 = c2.get(d2);
  void 0 === a2 && (a2 = Array.from(e2.transforms), c2.set(d2, a2));
  c2 = a2.length;
  for (d2 = 0; d2 < c2 && (a2[d2](b2), b2.isAttached()); d2++)
    ;
}
function rf(a2, b2) {
  b2 = b2._dirtyLeaves;
  a2 = a2._nodeMap;
  for (let c2 of b2)
    b2 = a2.get(c2), B$8(b2) && b2.isAttached() && b2.isSimpleText() && !b2.isUnmergeable() && Hb(b2);
}
function sf(a2, b2) {
  let c2 = b2._dirtyLeaves, d2 = b2._dirtyElements;
  a2 = a2._nodeMap;
  let e2 = dc(), f2 = /* @__PURE__ */ new Map();
  var g2 = c2;
  let h2 = g2.size;
  for (var k2 = d2, m2 = k2.size; 0 < h2 || 0 < m2; ) {
    if (0 < h2) {
      b2._dirtyLeaves = /* @__PURE__ */ new Set();
      for (let p2 of g2)
        g2 = a2.get(p2), B$8(g2) && g2.isAttached() && g2.isSimpleText() && !g2.isUnmergeable() && Hb(g2), void 0 !== g2 && void 0 !== g2 && g2.__key !== e2 && g2.isAttached() && qf(b2, g2, f2), c2.add(p2);
      g2 = b2._dirtyLeaves;
      h2 = g2.size;
      if (0 < h2) {
        $b++;
        continue;
      }
    }
    b2._dirtyLeaves = /* @__PURE__ */ new Set();
    b2._dirtyElements = /* @__PURE__ */ new Map();
    for (let p2 of k2)
      if (k2 = p2[0], m2 = p2[1], "root" === k2 || m2)
        g2 = a2.get(k2), void 0 !== g2 && void 0 !== g2 && g2.__key !== e2 && g2.isAttached() && qf(b2, g2, f2), d2.set(k2, m2);
    g2 = b2._dirtyLeaves;
    h2 = g2.size;
    k2 = b2._dirtyElements;
    m2 = k2.size;
    $b++;
  }
  b2._dirtyLeaves = c2;
  b2._dirtyElements = d2;
}
function tf(a2, b2) {
  var c2 = a2.type, d2 = b2.get(c2);
  void 0 === d2 && r$a(17, c2);
  c2 = d2.klass;
  a2.type !== c2.getType() && r$a(18, c2.name);
  c2 = c2.importJSON(a2);
  a2 = a2.children;
  if (E$6(c2) && Array.isArray(a2))
    for (d2 = 0; d2 < a2.length; d2++) {
      let e2 = tf(a2[d2], b2);
      c2.append(e2);
    }
  return c2;
}
function uf(a2, b2) {
  let c2 = T$3, d2 = W$2, e2 = U$3;
  T$3 = a2;
  W$2 = true;
  U$3 = null;
  try {
    return b2();
  } finally {
    T$3 = c2, W$2 = d2, U$3 = e2;
  }
}
function vf(a2, b2) {
  let c2 = a2._pendingEditorState, d2 = a2._rootElement, e2 = a2._headless || null === d2;
  if (null !== c2) {
    var f2 = a2._editorState, g2 = f2._selection, h2 = c2._selection, k2 = 0 !== a2._dirtyType, m2 = T$3, p2 = W$2, n2 = U$3, l2 = a2._updating, q2 = a2._observer, u2 = null;
    a2._pendingEditorState = null;
    a2._editorState = c2;
    if (!e2 && k2 && null !== q2) {
      U$3 = a2;
      T$3 = c2;
      W$2 = false;
      a2._updating = true;
      try {
        let D2 = a2._dirtyType, P2 = a2._dirtyElements, Q2 = a2._dirtyLeaves;
        q2.disconnect();
        var y2 = D2, x3 = P2, A2 = Q2;
        N$3 = Lc = M$2 = "";
        Oc = 2 === y2;
        Rc = null;
        O$3 = a2;
        Mc = a2._config;
        Nc = a2._nodes;
        Qc = O$3._listeners.mutation;
        Sc = x3;
        Tc = A2;
        Uc = f2._nodeMap;
        Vc = c2._nodeMap;
        Pc = c2._readOnly;
        Wc = new Map(a2._keyToDOMMap);
        let ia2 = /* @__PURE__ */ new Map();
        Xc = ia2;
        td("root", null);
        Xc = Wc = Mc = Vc = Uc = Tc = Sc = Nc = O$3 = void 0;
        u2 = ia2;
      } catch (D2) {
        D2 instanceof Error && a2._onError(D2);
        if (of)
          throw D2;
        wf(a2, null, d2, c2);
        Db(a2);
        a2._dirtyType = 2;
        of = true;
        vf(a2, f2);
        of = false;
        return;
      } finally {
        q2.observe(d2, pf), a2._updating = l2, T$3 = m2, W$2 = p2, U$3 = n2;
      }
    }
    c2._readOnly || (c2._readOnly = true);
    var aa2 = a2._dirtyLeaves, da2 = a2._dirtyElements, Va2 = a2._normalizedNodes, ka2 = a2._updateTags, $c2 = a2._deferred;
    k2 && (a2._dirtyType = 0, a2._cloneNotNeeded.clear(), a2._dirtyLeaves = /* @__PURE__ */ new Set(), a2._dirtyElements = /* @__PURE__ */ new Map(), a2._normalizedNodes = /* @__PURE__ */ new Set(), a2._updateTags = /* @__PURE__ */ new Set());
    var He2 = a2._decorators, Pb2 = a2._pendingDecorators || He2, Kf2 = c2._nodeMap, ad2;
    for (ad2 in Pb2)
      Kf2.has(ad2) || (Pb2 === He2 && (Pb2 = fc(a2)), delete Pb2[ad2]);
    var ja2 = e2 ? null : xb(a2._window);
    if (a2._editable && null !== ja2 && (k2 || null === h2 || h2.dirty)) {
      U$3 = a2;
      T$3 = c2;
      try {
        null !== q2 && q2.disconnect();
        if (k2 || null === h2 || h2.dirty) {
          let D2 = a2._blockCursorElement;
          null !== D2 && Cc(D2, a2, d2);
          a: {
            let P2 = ja2.anchorNode, Q2 = ja2.focusNode, ia2 = ja2.anchorOffset, mb2 = ja2.focusOffset, X2 = document.activeElement;
            if (!(ka2.has("collaboration") && X2 !== d2 || null !== X2 && Mb(X2)))
              if (C$7(h2)) {
                var nb2 = h2.anchor, bd2 = h2.focus, Ie2 = nb2.key, Lf2 = bd2.key, Je2 = uc(a2, Ie2), Ke2 = uc(a2, Lf2), Qb2 = nb2.offset, Le2 = bd2.offset, cd2 = h2.format, dd2 = h2.style, Me2 = h2.isCollapsed(), ob2 = Je2, Rb2 = Ke2, ed2 = false;
                if ("text" === nb2.type) {
                  ob2 = Xb(Je2);
                  let Y2 = nb2.getNode();
                  ed2 = Y2.getFormat() !== cd2 || Y2.getStyle() !== dd2;
                } else
                  C$7(g2) && "text" === g2.anchor.type && (ed2 = true);
                "text" === bd2.type && (Rb2 = Xb(Ke2));
                if (null !== ob2 && null !== Rb2) {
                  if (Me2 && (null === g2 || ed2 || C$7(g2) && (g2.format !== cd2 || g2.style !== dd2))) {
                    var Mf2 = performance.now();
                    Nd = [cd2, dd2, Qb2, Ie2, Mf2];
                  }
                  if (ia2 === Qb2 && mb2 === Le2 && P2 === ob2 && Q2 === Rb2 && ("Range" !== ja2.type || !Me2) && (null !== X2 && d2.contains(X2) || d2.focus({ preventScroll: true }), "element" !== nb2.type))
                    break a;
                  try {
                    ja2.setBaseAndExtent(ob2, Qb2, Rb2, Le2);
                  } catch (Y2) {
                  }
                  if (!ka2.has("skip-scroll-into-view") && h2.isCollapsed() && null !== d2 && d2 === document.activeElement) {
                    let Y2 = h2 instanceof Te && "element" === h2.anchor.type ? ob2.childNodes[Qb2] || null : 0 < ja2.rangeCount ? ja2.getRangeAt(0) : null;
                    if (null !== Y2) {
                      let Z2;
                      if (Y2 instanceof Text) {
                        let V2 = document.createRange();
                        V2.selectNode(Y2);
                        Z2 = V2.getBoundingClientRect();
                      } else
                        Z2 = Y2.getBoundingClientRect();
                      let ya2 = d2.ownerDocument, Ea2 = ya2.defaultView;
                      if (null !== Ea2)
                        for (var { top: fd2, bottom: gd2 } = Z2, Sb2, Tb2, oa2 = d2; null !== oa2; ) {
                          let V2 = oa2 === ya2.body;
                          if (V2)
                            Sb2 = 0, Tb2 = Eb(a2).innerHeight;
                          else {
                            let Ub2 = oa2.getBoundingClientRect();
                            Sb2 = Ub2.top;
                            Tb2 = Ub2.bottom;
                          }
                          let Fa2 = 0;
                          fd2 < Sb2 ? Fa2 = -(Sb2 - fd2) : gd2 > Tb2 && (Fa2 = gd2 - Tb2);
                          if (0 !== Fa2)
                            if (V2)
                              Ea2.scrollBy(0, Fa2);
                            else {
                              let Ub2 = oa2.scrollTop;
                              oa2.scrollTop += Fa2;
                              let Ne2 = oa2.scrollTop - Ub2;
                              fd2 -= Ne2;
                              gd2 -= Ne2;
                            }
                          if (V2)
                            break;
                          oa2 = Vb(oa2);
                        }
                    }
                  }
                  Jd = true;
                }
              } else
                null !== g2 && Nb(a2, P2, Q2) && ja2.removeAllRanges();
          }
        }
        a: {
          let D2 = a2._blockCursorElement;
          if (C$7(h2) && h2.isCollapsed() && "element" === h2.anchor.type && d2.contains(document.activeElement)) {
            let P2 = h2.anchor, Q2 = P2.getNode(), ia2 = P2.offset, mb2 = Q2.getChildrenSize(), X2 = false, Y2 = null;
            if (ia2 === mb2) {
              let Z2 = Q2.getChildAtIndex(ia2 - 1);
              Bc(Z2) && (X2 = true);
            } else {
              let Z2 = Q2.getChildAtIndex(ia2);
              if (Bc(Z2)) {
                let ya2 = Z2.getPreviousSibling();
                if (null === ya2 || Bc(ya2))
                  X2 = true, Y2 = a2.getElementByKey(Z2.__key);
              }
            }
            if (X2) {
              let Z2 = a2.getElementByKey(Q2.__key);
              if (null === D2) {
                let ya2 = a2._config.theme, Ea2 = document.createElement("div");
                Ea2.contentEditable = "false";
                Ea2.setAttribute("data-lexical-cursor", "true");
                let V2 = ya2.blockCursor;
                if (void 0 !== V2) {
                  if ("string" === typeof V2) {
                    let Fa2 = V2.split(" ");
                    V2 = ya2.blockCursor = Fa2;
                  }
                  void 0 !== V2 && Ea2.classList.add(...V2);
                }
                a2._blockCursorElement = D2 = Ea2;
              }
              d2.style.caretColor = "transparent";
              null === Y2 ? Z2.appendChild(D2) : Z2.insertBefore(D2, Y2);
              break a;
            }
          }
          null !== D2 && Cc(D2, a2, d2);
        }
        null !== q2 && q2.observe(d2, pf);
      } finally {
        U$3 = n2, T$3 = m2;
      }
    }
    if (null !== u2) {
      var Nf2 = u2;
      let D2 = Array.from(a2._listeners.mutation), P2 = D2.length;
      for (let Q2 = 0; Q2 < P2; Q2++) {
        let [ia2, mb2] = D2[Q2], X2 = Nf2.get(mb2);
        void 0 !== X2 && ia2(X2, { dirtyLeaves: aa2, prevEditorState: f2, updateTags: ka2 });
      }
    }
    C$7(h2) || null === h2 || null !== g2 && g2.is(h2) || a2.dispatchCommand(ba$2, void 0);
    var hd2 = a2._pendingDecorators;
    null !== hd2 && (a2._decorators = hd2, a2._pendingDecorators = null, xf("decorator", a2, true, hd2));
    var Of2 = gc(b2 || f2), Oe2 = gc(c2);
    Of2 !== Oe2 && xf("textcontent", a2, true, Oe2);
    xf("update", a2, true, { dirtyElements: da2, dirtyLeaves: aa2, editorState: c2, normalizedNodes: Va2, prevEditorState: b2 || f2, tags: ka2 });
    a2._deferred = [];
    if (0 !== $c2.length) {
      let D2 = a2._updating;
      a2._updating = true;
      try {
        for (let P2 = 0; P2 < $c2.length; P2++)
          $c2[P2]();
      } finally {
        a2._updating = D2;
      }
    }
    var Pe2 = a2._updates;
    if (0 !== Pe2.length) {
      let D2 = Pe2.shift();
      if (D2) {
        let [P2, Q2] = D2;
        yf(a2, P2, Q2);
      }
    }
  }
}
function xf(a2, b2, c2, ...d2) {
  let e2 = b2._updating;
  b2._updating = c2;
  try {
    let f2 = Array.from(b2._listeners[a2]);
    for (a2 = 0; a2 < f2.length; a2++)
      f2[a2].apply(null, d2);
  } finally {
    b2._updating = e2;
  }
}
function R$3(a2, b2, c2) {
  if (false === a2._updating || U$3 !== a2) {
    let f2 = false;
    a2.update(() => {
      f2 = R$3(a2, b2, c2);
    });
    return f2;
  }
  let d2 = kc(a2);
  for (let f2 = 4; 0 <= f2; f2--)
    for (let g2 = 0; g2 < d2.length; g2++) {
      var e2 = d2[g2]._commands.get(b2);
      if (void 0 !== e2 && (e2 = e2[f2], void 0 !== e2)) {
        e2 = Array.from(e2);
        let h2 = e2.length;
        for (let k2 = 0; k2 < h2; k2++)
          if (true === e2[k2](c2, a2))
            return true;
      }
    }
  return false;
}
function zf(a2, b2) {
  let c2 = a2._updates;
  for (b2 = b2 || false; 0 !== c2.length; ) {
    var d2 = c2.shift();
    if (d2) {
      let [e2, f2] = d2, g2;
      void 0 !== f2 && (d2 = f2.onUpdate, g2 = f2.tag, f2.skipTransforms && (b2 = true), d2 && a2._deferred.push(d2), g2 && a2._updateTags.add(g2));
      e2();
    }
  }
  return b2;
}
function yf(a2, b2, c2) {
  let d2 = a2._updateTags;
  var e2, f2 = e2 = false;
  if (void 0 !== c2) {
    var g2 = c2.onUpdate;
    e2 = c2.tag;
    null != e2 && d2.add(e2);
    e2 = c2.skipTransforms || false;
    f2 = c2.discrete || false;
  }
  g2 && a2._deferred.push(g2);
  c2 = a2._editorState;
  g2 = a2._pendingEditorState;
  let h2 = false;
  if (null === g2 || g2._readOnly)
    g2 = a2._pendingEditorState = new Af(new Map((g2 || c2)._nodeMap)), h2 = true;
  g2._flushSync = f2;
  f2 = T$3;
  let k2 = W$2, m2 = U$3, p2 = a2._updating;
  T$3 = g2;
  W$2 = false;
  a2._updating = true;
  U$3 = a2;
  try {
    h2 && (a2._headless ? null != c2._selection && (g2._selection = c2._selection.clone()) : g2._selection = kf(a2));
    let n2 = a2._compositionKey;
    b2();
    e2 = zf(a2, e2);
    mf(g2, a2);
    0 !== a2._dirtyType && (e2 ? rf(g2, a2) : sf(g2, a2), zf(a2), Kc(c2, g2, a2._dirtyLeaves, a2._dirtyElements));
    n2 !== a2._compositionKey && (g2._flushSync = true);
    let l2 = g2._selection;
    if (C$7(l2)) {
      let q2 = g2._nodeMap, u2 = l2.focus.key;
      void 0 !== q2.get(l2.anchor.key) && void 0 !== q2.get(u2) || r$a(19);
    } else
      Vd(l2) && 0 === l2._nodes.size && (g2._selection = null);
  } catch (n2) {
    n2 instanceof Error && a2._onError(n2);
    a2._pendingEditorState = c2;
    a2._dirtyType = 2;
    a2._cloneNotNeeded.clear();
    a2._dirtyLeaves = /* @__PURE__ */ new Set();
    a2._dirtyElements.clear();
    vf(a2);
    return;
  } finally {
    T$3 = f2, W$2 = k2, U$3 = m2, a2._updating = p2, $b = 0;
  }
  0 !== a2._dirtyType || Bf(g2, a2) ? g2._flushSync ? (g2._flushSync = false, vf(a2)) : h2 && Lb(() => {
    vf(a2);
  }) : (g2._flushSync = false, h2 && (d2.clear(), a2._deferred = [], a2._pendingEditorState = null));
}
function w$7(a2, b2, c2) {
  a2._updating ? a2._updates.push([b2, c2]) : yf(a2, b2, c2);
}
class Cf extends ce {
  constructor(a2) {
    super(a2);
  }
  decorate() {
    r$a(47);
  }
  isIsolated() {
    return false;
  }
  isInline() {
    return true;
  }
  isKeyboardSelectable() {
    return true;
  }
}
function z$7(a2) {
  return a2 instanceof Cf;
}
class Df extends ce {
  constructor(a2) {
    super(a2);
    this.__last = this.__first = null;
    this.__indent = this.__format = this.__size = 0;
    this.__dir = null;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getFormatType() {
    let a2 = this.getFormat();
    return kb[a2] || "";
  }
  getIndent() {
    return this.getLatest().__indent;
  }
  getChildren() {
    let a2 = [], b2 = this.getFirstChild();
    for (; null !== b2; )
      a2.push(b2), b2 = b2.getNextSibling();
    return a2;
  }
  getChildrenKeys() {
    let a2 = [], b2 = this.getFirstChild();
    for (; null !== b2; )
      a2.push(b2.__key), b2 = b2.getNextSibling();
    return a2;
  }
  getChildrenSize() {
    return this.getLatest().__size;
  }
  isEmpty() {
    return 0 === this.getChildrenSize();
  }
  isDirty() {
    let a2 = F$6()._dirtyElements;
    return null !== a2 && a2.has(this.__key);
  }
  isLastChild() {
    let a2 = this.getLatest(), b2 = this.getParentOrThrow().getLastChild();
    return null !== b2 && b2.is(a2);
  }
  getAllTextNodes() {
    let a2 = [], b2 = this.getFirstChild();
    for (; null !== b2; ) {
      B$8(b2) && a2.push(b2);
      if (E$6(b2)) {
        let c2 = b2.getAllTextNodes();
        a2.push(...c2);
      }
      b2 = b2.getNextSibling();
    }
    return a2;
  }
  getFirstDescendant() {
    let a2 = this.getFirstChild();
    for (; null !== a2; ) {
      if (E$6(a2)) {
        let b2 = a2.getFirstChild();
        if (null !== b2) {
          a2 = b2;
          continue;
        }
      }
      break;
    }
    return a2;
  }
  getLastDescendant() {
    let a2 = this.getLastChild();
    for (; null !== a2; ) {
      if (E$6(a2)) {
        let b2 = a2.getLastChild();
        if (null !== b2) {
          a2 = b2;
          continue;
        }
      }
      break;
    }
    return a2;
  }
  getDescendantByIndex(a2) {
    let b2 = this.getChildren(), c2 = b2.length;
    if (a2 >= c2)
      return a2 = b2[c2 - 1], E$6(a2) && a2.getLastDescendant() || a2 || null;
    a2 = b2[a2];
    return E$6(a2) && a2.getFirstDescendant() || a2 || null;
  }
  getFirstChild() {
    let a2 = this.getLatest().__first;
    return null === a2 ? null : I$5(a2);
  }
  getFirstChildOrThrow() {
    let a2 = this.getFirstChild();
    null === a2 && r$a(45, this.__key);
    return a2;
  }
  getLastChild() {
    let a2 = this.getLatest().__last;
    return null === a2 ? null : I$5(a2);
  }
  getLastChildOrThrow() {
    let a2 = this.getLastChild();
    null === a2 && r$a(96, this.__key);
    return a2;
  }
  getChildAtIndex(a2) {
    var b2 = this.getChildrenSize();
    let c2;
    if (a2 < b2 / 2) {
      c2 = this.getFirstChild();
      for (b2 = 0; null !== c2 && b2 <= a2; ) {
        if (b2 === a2)
          return c2;
        c2 = c2.getNextSibling();
        b2++;
      }
      return null;
    }
    c2 = this.getLastChild();
    for (--b2; null !== c2 && b2 >= a2; ) {
      if (b2 === a2)
        return c2;
      c2 = c2.getPreviousSibling();
      b2--;
    }
    return null;
  }
  getTextContent() {
    let a2 = "", b2 = this.getChildren(), c2 = b2.length;
    for (let d2 = 0; d2 < c2; d2++) {
      let e2 = b2[d2];
      a2 += e2.getTextContent();
      E$6(e2) && d2 !== c2 - 1 && !e2.isInline() && (a2 += "\n\n");
    }
    return a2;
  }
  getTextContentSize() {
    let a2 = 0, b2 = this.getChildren(), c2 = b2.length;
    for (let d2 = 0; d2 < c2; d2++) {
      let e2 = b2[d2];
      a2 += e2.getTextContentSize();
      E$6(e2) && d2 !== c2 - 1 && !e2.isInline() && (a2 += 2);
    }
    return a2;
  }
  getDirection() {
    return this.getLatest().__dir;
  }
  hasFormat(a2) {
    return "" !== a2 ? (a2 = jb[a2], 0 !== (this.getFormat() & a2)) : false;
  }
  select(a2, b2) {
    G$6();
    let c2 = v$8(), d2 = a2, e2 = b2;
    var f2 = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (0 === a2 && 0 === b2) {
        if (a2 = this.getFirstChild(), B$8(a2) || E$6(a2))
          return a2.select(0, 0);
      } else if (!(void 0 !== a2 && a2 !== f2 || void 0 !== b2 && b2 !== f2) && (a2 = this.getLastChild(), B$8(a2) || E$6(a2)))
        return a2.select();
    }
    void 0 === d2 && (d2 = f2);
    void 0 === e2 && (e2 = f2);
    f2 = this.__key;
    if (C$7(c2))
      c2.anchor.set(f2, d2, "element"), c2.focus.set(f2, e2, "element"), c2.dirty = true;
    else
      return ue(f2, d2, f2, e2, "element", "element");
    return c2;
  }
  selectStart() {
    let a2 = this.getFirstDescendant();
    return a2 ? a2.selectStart() : this.select();
  }
  selectEnd() {
    let a2 = this.getLastDescendant();
    return a2 ? a2.selectEnd() : this.select();
  }
  clear() {
    let a2 = this.getWritable();
    this.getChildren().forEach((b2) => b2.remove());
    return a2;
  }
  append(...a2) {
    return this.splice(
      this.getChildrenSize(),
      0,
      a2
    );
  }
  setDirection(a2) {
    let b2 = this.getWritable();
    b2.__dir = a2;
    return b2;
  }
  setFormat(a2) {
    this.getWritable().__format = "" !== a2 ? jb[a2] : 0;
    return this;
  }
  setIndent(a2) {
    this.getWritable().__indent = a2;
    return this;
  }
  splice(a2, b2, c2) {
    let d2 = c2.length, e2 = this.getChildrenSize(), f2 = this.getWritable(), g2 = f2.__key;
    var h2 = [], k2 = [];
    let m2 = this.getChildAtIndex(a2 + b2), p2 = null, n2 = e2 - b2 + d2;
    if (0 !== a2)
      if (a2 === e2)
        p2 = this.getLastChild();
      else {
        var l2 = this.getChildAtIndex(a2);
        null !== l2 && (p2 = l2.getPreviousSibling());
      }
    if (0 < b2) {
      var q2 = null === p2 ? this.getFirstChild() : p2.getNextSibling();
      for (l2 = 0; l2 < b2; l2++) {
        null === q2 && r$a(100);
        var u2 = q2.getNextSibling(), y2 = q2.__key;
        q2 = q2.getWritable();
        bc(q2);
        k2.push(y2);
        q2 = u2;
      }
    }
    l2 = p2;
    for (u2 = 0; u2 < d2; u2++) {
      y2 = c2[u2];
      null !== l2 && y2.is(l2) && (p2 = l2 = l2.getPreviousSibling());
      q2 = y2.getWritable();
      q2.__parent === g2 && n2--;
      bc(q2);
      let x3 = y2.__key;
      null === l2 ? (f2.__first = x3, q2.__prev = null) : (l2 = l2.getWritable(), l2.__next = x3, q2.__prev = l2.__key);
      y2.__key === g2 && r$a(76);
      q2.__parent = g2;
      h2.push(x3);
      l2 = y2;
    }
    a2 + b2 === e2 ? null !== l2 && (l2.getWritable().__next = null, f2.__last = l2.__key) : null !== m2 && (a2 = m2.getWritable(), null !== l2 ? (b2 = l2.getWritable(), a2.__prev = l2.__key, b2.__next = m2.__key) : a2.__prev = null);
    f2.__size = n2;
    if (k2.length && (a2 = v$8(), C$7(a2))) {
      k2 = new Set(k2);
      h2 = new Set(h2);
      let { anchor: x3, focus: A2 } = a2;
      Ef(x3, k2, h2) && ae(x3, x3.getNode(), this, p2, m2);
      Ef(A2, k2, h2) && ae(A2, A2.getNode(), this, p2, m2);
      0 !== n2 || this.canBeEmpty() || xc(this) || this.remove();
    }
    return f2;
  }
  exportJSON() {
    return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "element", version: 1 };
  }
  insertNewAfter() {
    return null;
  }
  canIndent() {
    return true;
  }
  collapseAtStart() {
    return false;
  }
  excludeFromCopy() {
    return false;
  }
  canExtractContents() {
    return true;
  }
  canReplaceWith() {
    return true;
  }
  canInsertAfter() {
    return true;
  }
  canBeEmpty() {
    return true;
  }
  canInsertTextBefore() {
    return true;
  }
  canInsertTextAfter() {
    return true;
  }
  isInline() {
    return false;
  }
  isShadowRoot() {
    return false;
  }
  canMergeWith() {
    return false;
  }
  extractWithChild() {
    return false;
  }
}
function E$6(a2) {
  return a2 instanceof Df;
}
function Ef(a2, b2, c2) {
  for (a2 = a2.getNode(); a2; ) {
    let d2 = a2.__key;
    if (b2.has(d2) && !c2.has(d2))
      return true;
    a2 = a2.getParent();
  }
  return false;
}
class Ff extends Df {
  static getType() {
    return "root";
  }
  static clone() {
    return new Ff();
  }
  constructor() {
    super("root");
    this.__cachedText = null;
  }
  getTopLevelElementOrThrow() {
    r$a(51);
  }
  getTextContent() {
    let a2 = this.__cachedText;
    return !ec() && 0 !== F$6()._dirtyType || null === a2 ? super.getTextContent() : a2;
  }
  remove() {
    r$a(52);
  }
  replace() {
    r$a(53);
  }
  insertBefore() {
    r$a(54);
  }
  insertAfter() {
    r$a(55);
  }
  updateDOM() {
    return false;
  }
  append(...a2) {
    for (let b2 = 0; b2 < a2.length; b2++) {
      let c2 = a2[b2];
      E$6(c2) || z$7(c2) || r$a(56);
    }
    return super.append(...a2);
  }
  static importJSON(a2) {
    let b2 = J$4();
    b2.setFormat(a2.format);
    b2.setIndent(a2.indent);
    b2.setDirection(a2.direction);
    return b2;
  }
  exportJSON() {
    return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "root", version: 1 };
  }
  collapseAtStart() {
    return true;
  }
}
function L$4(a2) {
  return a2 instanceof Ff;
}
function Bf(a2, b2) {
  b2 = b2.getEditorState()._selection;
  a2 = a2._selection;
  if (null !== a2) {
    if (a2.dirty || !a2.is(b2))
      return true;
  } else if (null !== b2)
    return true;
  return false;
}
function Gf() {
  return new Af(/* @__PURE__ */ new Map([["root", new Ff()]]));
}
function Hf(a2) {
  let b2 = a2.exportJSON();
  var c2 = a2.constructor;
  b2.type !== c2.getType() && r$a(130, c2.name);
  let d2 = b2.children;
  if (E$6(a2))
    for (Array.isArray(d2) || r$a(59, c2.name), a2 = a2.getChildren(), c2 = 0; c2 < a2.length; c2++) {
      let e2 = Hf(a2[c2]);
      d2.push(e2);
    }
  return b2;
}
class Af {
  constructor(a2, b2) {
    this._nodeMap = a2;
    this._selection = b2 || null;
    this._readOnly = this._flushSync = false;
  }
  isEmpty() {
    return 1 === this._nodeMap.size && null === this._selection;
  }
  read(a2) {
    return uf(this, a2);
  }
  clone(a2) {
    a2 = new Af(this._nodeMap, void 0 === a2 ? this._selection : a2);
    a2._readOnly = true;
    return a2;
  }
  toJSON() {
    return uf(this, () => ({ root: Hf(J$4()) }));
  }
}
class If extends Df {
  static getType() {
    return "paragraph";
  }
  static clone(a2) {
    return new If(a2.__key);
  }
  createDOM(a2) {
    let b2 = document.createElement("p");
    a2 = pc(a2.theme, "paragraph");
    void 0 !== a2 && b2.classList.add(...a2);
    return b2;
  }
  updateDOM() {
    return false;
  }
  static importDOM() {
    return { p: () => ({ conversion: Jf, priority: 0 }) };
  }
  exportDOM(a2) {
    ({ element: a2 } = super.exportDOM(a2));
    if (a2 && Fc(a2)) {
      this.isEmpty() && a2.append(document.createElement("br"));
      var b2 = this.getFormatType();
      a2.style.textAlign = b2;
      if (b2 = this.getDirection())
        a2.dir = b2;
      b2 = this.getIndent();
      0 < b2 && (a2.style.textIndent = `${20 * b2}px`);
    }
    return { element: a2 };
  }
  static importJSON(a2) {
    let b2 = fe();
    b2.setFormat(a2.format);
    b2.setIndent(a2.indent);
    b2.setDirection(a2.direction);
    return b2;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "paragraph", version: 1 };
  }
  insertNewAfter(a2, b2) {
    a2 = fe();
    let c2 = this.getDirection();
    a2.setDirection(c2);
    this.insertAfter(a2, b2);
    return a2;
  }
  collapseAtStart() {
    let a2 = this.getChildren();
    if (0 === a2.length || B$8(a2[0]) && "" === a2[0].getTextContent().trim()) {
      if (null !== this.getNextSibling())
        return this.selectNext(), this.remove(), true;
      if (null !== this.getPreviousSibling())
        return this.selectPrevious(), this.remove(), true;
    }
    return false;
  }
}
function Jf(a2) {
  let b2 = fe();
  a2.style && (b2.setFormat(a2.style.textAlign), a2 = parseInt(a2.style.textIndent, 10) / 20, 0 < a2 && b2.setIndent(a2));
  return { node: b2 };
}
function fe() {
  return zc(new If());
}
function wf(a2, b2, c2, d2) {
  let e2 = a2._keyToDOMMap;
  e2.clear();
  a2._editorState = Gf();
  a2._pendingEditorState = d2;
  a2._compositionKey = null;
  a2._dirtyType = 0;
  a2._cloneNotNeeded.clear();
  a2._dirtyLeaves = /* @__PURE__ */ new Set();
  a2._dirtyElements.clear();
  a2._normalizedNodes = /* @__PURE__ */ new Set();
  a2._updateTags = /* @__PURE__ */ new Set();
  a2._updates = [];
  a2._blockCursorElement = null;
  d2 = a2._observer;
  null !== d2 && (d2.disconnect(), a2._observer = null);
  null !== b2 && (b2.textContent = "");
  null !== c2 && (c2.textContent = "", e2.set("root", c2));
}
function Pf(a2, b2) {
  let c2 = /* @__PURE__ */ new Map(), d2 = /* @__PURE__ */ new Set(), e2 = (f2) => {
    Object.keys(f2).forEach((g2) => {
      let h2 = c2.get(g2);
      void 0 === h2 && (h2 = [], c2.set(g2, h2));
      h2.push(f2[g2]);
    });
  };
  a2.forEach((f2) => {
    f2 = null != f2.klass.importDOM ? f2.klass.importDOM.bind(f2.klass) : null;
    null == f2 || d2.has(f2) || (d2.add(f2), f2 = f2(), null !== f2 && e2(f2));
  });
  b2 && e2(b2);
  return c2;
}
class Qf {
  constructor(a2, b2, c2, d2, e2, f2, g2) {
    this._parentEditor = b2;
    this._rootElement = null;
    this._editorState = a2;
    this._compositionKey = this._pendingEditorState = null;
    this._deferred = [];
    this._keyToDOMMap = /* @__PURE__ */ new Map();
    this._updates = [];
    this._updating = false;
    this._listeners = { decorator: /* @__PURE__ */ new Set(), editable: /* @__PURE__ */ new Set(), mutation: /* @__PURE__ */ new Map(), root: /* @__PURE__ */ new Set(), textcontent: /* @__PURE__ */ new Set(), update: /* @__PURE__ */ new Set() };
    this._commands = /* @__PURE__ */ new Map();
    this._config = d2;
    this._nodes = c2;
    this._decorators = {};
    this._pendingDecorators = null;
    this._dirtyType = 0;
    this._cloneNotNeeded = /* @__PURE__ */ new Set();
    this._dirtyLeaves = /* @__PURE__ */ new Set();
    this._dirtyElements = /* @__PURE__ */ new Map();
    this._normalizedNodes = /* @__PURE__ */ new Set();
    this._updateTags = /* @__PURE__ */ new Set();
    this._observer = null;
    this._key = lc();
    this._onError = e2;
    this._htmlConversions = f2;
    this._editable = g2;
    this._headless = null !== b2 && b2._headless;
    this._blockCursorElement = this._window = null;
  }
  isComposing() {
    return null != this._compositionKey;
  }
  registerUpdateListener(a2) {
    let b2 = this._listeners.update;
    b2.add(a2);
    return () => {
      b2.delete(a2);
    };
  }
  registerEditableListener(a2) {
    let b2 = this._listeners.editable;
    b2.add(a2);
    return () => {
      b2.delete(a2);
    };
  }
  registerDecoratorListener(a2) {
    let b2 = this._listeners.decorator;
    b2.add(a2);
    return () => {
      b2.delete(a2);
    };
  }
  registerTextContentListener(a2) {
    let b2 = this._listeners.textcontent;
    b2.add(a2);
    return () => {
      b2.delete(a2);
    };
  }
  registerRootListener(a2) {
    let b2 = this._listeners.root;
    a2(this._rootElement, null);
    b2.add(a2);
    return () => {
      a2(null, this._rootElement);
      b2.delete(a2);
    };
  }
  registerCommand(a2, b2, c2) {
    void 0 === c2 && r$a(35);
    let d2 = this._commands;
    d2.has(a2) || d2.set(a2, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
    let e2 = d2.get(a2);
    void 0 === e2 && r$a(36, String(a2));
    let f2 = e2[c2];
    f2.add(b2);
    return () => {
      f2.delete(b2);
      e2.every((g2) => 0 === g2.size) && d2.delete(a2);
    };
  }
  registerMutationListener(a2, b2) {
    void 0 === this._nodes.get(a2.getType()) && r$a(37, a2.name);
    let c2 = this._listeners.mutation;
    c2.set(b2, a2);
    return () => {
      c2.delete(b2);
    };
  }
  registerNodeTransformToKlass(a2, b2) {
    var c2 = a2.getType();
    c2 = this._nodes.get(c2);
    void 0 === c2 && r$a(37, a2.name);
    c2.transforms.add(b2);
    return c2;
  }
  registerNodeTransform(a2, b2) {
    var c2 = this.registerNodeTransformToKlass(a2, b2);
    let d2 = [c2];
    c2 = c2.replaceWithKlass;
    null != c2 && (c2 = this.registerNodeTransformToKlass(c2, b2), d2.push(c2));
    hc(this, a2.getType());
    return () => {
      d2.forEach((e2) => e2.transforms.delete(b2));
    };
  }
  hasNode(a2) {
    return this._nodes.has(a2.getType());
  }
  hasNodes(a2) {
    return a2.every(this.hasNode.bind(this));
  }
  dispatchCommand(a2, b2) {
    return R$3(this, a2, b2);
  }
  getDecorators() {
    return this._decorators;
  }
  getRootElement() {
    return this._rootElement;
  }
  getKey() {
    return this._key;
  }
  setRootElement(a2) {
    let b2 = this._rootElement;
    if (a2 !== b2) {
      let f2 = pc(this._config.theme, "root");
      var c2 = this._pendingEditorState || this._editorState;
      this._rootElement = a2;
      wf(this, b2, a2, c2);
      if (null !== b2) {
        if (!this._config.disableEvents) {
          0 !== Id && (Id--, 0 === Id && b2.ownerDocument.removeEventListener("selectionchange", Yd));
          var d2 = b2.__lexicalEditor;
          if (null !== d2 && void 0 !== d2) {
            if (null !== d2._parentEditor) {
              var e2 = kc(d2);
              e2 = e2[e2.length - 1]._key;
              Xd.get(e2) === d2 && Xd.delete(e2);
            } else
              Xd.delete(d2._key);
            b2.__lexicalEditor = null;
          }
          d2 = Wd(b2);
          for (e2 = 0; e2 < d2.length; e2++)
            d2[e2]();
          b2.__lexicalEventHandles = [];
        }
        null != f2 && b2.classList.remove(...f2);
      }
      null !== a2 ? (c2 = (c2 = a2.ownerDocument) && c2.defaultView || null, d2 = a2.style, d2.userSelect = "text", d2.whiteSpace = "pre-wrap", d2.wordBreak = "break-word", a2.setAttribute(
        "data-lexical-editor",
        "true"
      ), this._window = c2, this._dirtyType = 2, Db(this), this._updateTags.add("history-merge"), vf(this), this._config.disableEvents || Zd(a2, this), null != f2 && a2.classList.add(...f2)) : (this._editorState = c2, this._window = this._pendingEditorState = null);
      xf("root", this, false, a2, b2);
    }
  }
  getElementByKey(a2) {
    return this._keyToDOMMap.get(a2) || null;
  }
  getEditorState() {
    return this._editorState;
  }
  setEditorState(a2, b2) {
    a2.isEmpty() && r$a(38);
    Cb(this);
    let c2 = this._pendingEditorState, d2 = this._updateTags;
    b2 = void 0 !== b2 ? b2.tag : null;
    null === c2 || c2.isEmpty() || (null != b2 && d2.add(b2), vf(this));
    this._pendingEditorState = a2;
    this._dirtyType = 2;
    this._dirtyElements.set("root", false);
    this._compositionKey = null;
    null != b2 && d2.add(b2);
    vf(this);
  }
  parseEditorState(a2, b2) {
    a2 = "string" === typeof a2 ? JSON.parse(a2) : a2;
    let c2 = Gf(), d2 = T$3, e2 = W$2, f2 = U$3, g2 = this._dirtyElements, h2 = this._dirtyLeaves, k2 = this._cloneNotNeeded, m2 = this._dirtyType;
    this._dirtyElements = /* @__PURE__ */ new Map();
    this._dirtyLeaves = /* @__PURE__ */ new Set();
    this._cloneNotNeeded = /* @__PURE__ */ new Set();
    this._dirtyType = 0;
    T$3 = c2;
    W$2 = false;
    U$3 = this;
    try {
      tf(a2.root, this._nodes), b2 && b2(), c2._readOnly = true;
    } catch (p2) {
      p2 instanceof Error && this._onError(p2);
    } finally {
      this._dirtyElements = g2, this._dirtyLeaves = h2, this._cloneNotNeeded = k2, this._dirtyType = m2, T$3 = d2, W$2 = e2, U$3 = f2;
    }
    return c2;
  }
  update(a2, b2) {
    w$7(this, a2, b2);
  }
  focus(a2, b2 = {}) {
    let c2 = this._rootElement;
    null !== c2 && (c2.setAttribute("autocapitalize", "off"), w$7(this, () => {
      let d2 = v$8(), e2 = J$4();
      null !== d2 ? d2.dirty = true : 0 !== e2.getChildrenSize() && ("rootStart" === b2.defaultSelection ? e2.selectStart() : e2.selectEnd());
    }, { onUpdate: () => {
      c2.removeAttribute("autocapitalize");
      a2 && a2();
    }, tag: "focus" }), null === this._pendingEditorState && c2.removeAttribute("autocapitalize"));
  }
  blur() {
    var a2 = this._rootElement;
    null !== a2 && a2.blur();
    a2 = xb(this._window);
    null !== a2 && a2.removeAllRanges();
  }
  isEditable() {
    return this._editable;
  }
  setEditable(a2) {
    this._editable !== a2 && (this._editable = a2, xf("editable", this, true, a2));
  }
  toJSON() {
    return { editorState: this._editorState.toJSON() };
  }
}
class nf extends Df {
  constructor(a2, b2) {
    super(b2);
    this.__colSpan = a2;
    this.__rowSpan = 1;
  }
  exportJSON() {
    return { ...super.exportJSON(), colSpan: this.__colSpan, rowSpan: this.__rowSpan };
  }
  getColSpan() {
    return this.__colSpan;
  }
  setColSpan(a2) {
    this.getWritable().__colSpan = a2;
    return this;
  }
  getRowSpan() {
    return this.__rowSpan;
  }
  setRowSpan(a2) {
    this.getWritable().__rowSpan = a2;
    return this;
  }
}
function S$3(a2) {
  return a2 instanceof nf;
}
class Rf extends Df {
}
function Ze(a2) {
  return a2 instanceof Rf;
}
class Sf extends Df {
}
function Ye(a2) {
  return a2 instanceof Sf;
}
Lexical_prod.$INTERNAL_isPointSelection = de;
Lexical_prod.$addUpdateTag = function(a2) {
  G$6();
  F$6()._updateTags.add(a2);
};
Lexical_prod.$applyNodeReplacement = zc;
Lexical_prod.$copyNode = yc;
Lexical_prod.$createLineBreakNode = je;
Lexical_prod.$createNodeSelection = ef;
Lexical_prod.$createParagraphNode = fe;
Lexical_prod.$createRangeSelection = function() {
  let a2 = new De("root", 0, "element"), b2 = new De("root", 0, "element");
  return new Te(a2, b2, 0, "");
};
Lexical_prod.$createTabNode = xe;
Lexical_prod.$createTextNode = K$4;
Lexical_prod.$getAdjacentNode = sc;
Lexical_prod.$getNearestNodeFromDOMNode = wb;
Lexical_prod.$getNearestRootOrShadowRoot = wc;
Lexical_prod.$getNodeByKey = I$5;
Lexical_prod.$getPreviousSelection = nc;
Lexical_prod.$getRoot = J$4;
Lexical_prod.$getSelection = v$8;
Lexical_prod.$getTextContent = function() {
  let a2 = v$8();
  return null === a2 ? "" : a2.getTextContent();
};
Lexical_prod.$hasAncestor = vc;
Lexical_prod.$hasUpdateTag = function(a2) {
  return F$6()._updateTags.has(a2);
};
Lexical_prod.$insertNodes = function(a2) {
  let b2 = v$8() || nc();
  null === b2 && (b2 = J$4().selectEnd());
  b2.insertNodes(a2);
};
Lexical_prod.$isBlockElementNode = function(a2) {
  return E$6(a2) && !a2.isInline();
};
Lexical_prod.$isDecoratorNode = z$7;
Lexical_prod.$isElementNode = E$6;
Lexical_prod.$isInlineElementOrDecoratorNode = function(a2) {
  return E$6(a2) && a2.isInline() || z$7(a2) && a2.isInline();
};
Lexical_prod.$isLeafNode = function(a2) {
  return B$8(a2) || Hc(a2) || z$7(a2);
};
Lexical_prod.$isLineBreakNode = Hc;
Lexical_prod.$isNodeSelection = Vd;
Lexical_prod.$isParagraphNode = function(a2) {
  return a2 instanceof If;
};
Lexical_prod.$isRangeSelection = C$7;
Lexical_prod.$isRootNode = L$4;
Lexical_prod.$isRootOrShadowRoot = xc;
Lexical_prod.$isTabNode = Ce;
Lexical_prod.$isTextNode = B$8;
Lexical_prod.$nodesOfType = function(a2) {
  var b2 = ac();
  let c2 = b2._readOnly, d2 = a2.getType();
  b2 = b2._nodeMap;
  let e2 = [];
  for (let [, f2] of b2)
    f2 instanceof a2 && f2.__type === d2 && (c2 || f2.isAttached()) && e2.push(f2);
  return e2;
};
Lexical_prod.$normalizeSelection__EXPERIMENTAL = Ib;
Lexical_prod.$parseSerializedNode = function(a2) {
  return tf(a2, F$6()._nodes);
};
Lexical_prod.$selectAll = function() {
  var a2 = J$4();
  a2 = a2.select(0, a2.getChildrenSize());
  Ab(Ib(a2));
};
Lexical_prod.$setCompositionKey = H$6;
Lexical_prod.$setSelection = Ab;
Lexical_prod.$splitNode = function(a2, b2) {
  let c2 = a2.getChildAtIndex(b2);
  null == c2 && (c2 = a2);
  xc(a2) && r$a(102);
  let d2 = (g2) => {
    const h2 = g2.getParentOrThrow(), k2 = xc(h2), m2 = g2 !== c2 || k2 ? yc(g2) : g2;
    if (k2)
      return g2.insertAfter(m2), [g2, m2, m2];
    const [p2, n2, l2] = d2(h2);
    g2 = g2.getNextSiblings();
    l2.append(m2, ...g2);
    return [p2, n2, m2];
  }, [e2, f2] = d2(c2);
  return [e2, f2];
};
Lexical_prod.BLUR_COMMAND = Sa;
Lexical_prod.CAN_REDO_COMMAND = {};
Lexical_prod.CAN_UNDO_COMMAND = {};
Lexical_prod.CLEAR_EDITOR_COMMAND = {};
Lexical_prod.CLEAR_HISTORY_COMMAND = {};
Lexical_prod.CLICK_COMMAND = ca$2;
Lexical_prod.COMMAND_PRIORITY_CRITICAL = 4;
Lexical_prod.COMMAND_PRIORITY_EDITOR = 0;
Lexical_prod.COMMAND_PRIORITY_HIGH = 3;
Lexical_prod.COMMAND_PRIORITY_LOW = 1;
Lexical_prod.COMMAND_PRIORITY_NORMAL = 2;
Lexical_prod.CONTROLLED_TEXT_INSERTION_COMMAND = la$1;
Lexical_prod.COPY_COMMAND = Oa;
Lexical_prod.CUT_COMMAND = Pa;
Lexical_prod.DELETE_CHARACTER_COMMAND = ea$2;
Lexical_prod.DELETE_LINE_COMMAND = qa$1;
Lexical_prod.DELETE_WORD_COMMAND = pa$1;
Lexical_prod.DEPRECATED_$computeGridMap = $e;
Lexical_prod.DEPRECATED_$createGridSelection = function() {
  let a2 = new De("root", 0, "element"), b2 = new De("root", 0, "element");
  return new We("root", a2, b2);
};
Lexical_prod.DEPRECATED_$getGridCellNodeRect = Ue;
Lexical_prod.DEPRECATED_$getNodeTriplet = Ve;
Lexical_prod.DEPRECATED_$isGridCellNode = S$3;
Lexical_prod.DEPRECATED_$isGridNode = Ze;
Lexical_prod.DEPRECATED_$isGridRowNode = Ye;
Lexical_prod.DEPRECATED_$isGridSelection = Xe;
Lexical_prod.DEPRECATED_GridCellNode = nf;
Lexical_prod.DEPRECATED_GridNode = Rf;
Lexical_prod.DEPRECATED_GridRowNode = Sf;
Lexical_prod.DRAGEND_COMMAND = Na;
Lexical_prod.DRAGOVER_COMMAND = Ma;
Lexical_prod.DRAGSTART_COMMAND = La;
Lexical_prod.DROP_COMMAND = Ka;
Lexical_prod.DecoratorNode = Cf;
Lexical_prod.ElementNode = Df;
Lexical_prod.FOCUS_COMMAND = Ra;
Lexical_prod.FORMAT_ELEMENT_COMMAND = {};
Lexical_prod.FORMAT_TEXT_COMMAND = ra$1;
Lexical_prod.INDENT_CONTENT_COMMAND = {};
Lexical_prod.INSERT_LINE_BREAK_COMMAND = fa$2;
Lexical_prod.INSERT_PARAGRAPH_COMMAND = ha$2;
Lexical_prod.INSERT_TAB_COMMAND = {};
Lexical_prod.KEY_ARROW_DOWN_COMMAND = Ba$1;
Lexical_prod.KEY_ARROW_LEFT_COMMAND = xa$1;
Lexical_prod.KEY_ARROW_RIGHT_COMMAND = va$1;
Lexical_prod.KEY_ARROW_UP_COMMAND = Aa$1;
Lexical_prod.KEY_BACKSPACE_COMMAND = Ga;
Lexical_prod.KEY_DELETE_COMMAND = Ia;
Lexical_prod.KEY_DOWN_COMMAND = ua;
Lexical_prod.KEY_ENTER_COMMAND = Ca$1;
Lexical_prod.KEY_ESCAPE_COMMAND = Ha;
Lexical_prod.KEY_MODIFIER_COMMAND = Ta;
Lexical_prod.KEY_SPACE_COMMAND = Da$1;
Lexical_prod.KEY_TAB_COMMAND = Ja;
Lexical_prod.LineBreakNode = he;
Lexical_prod.MOVE_TO_END = wa$1;
Lexical_prod.MOVE_TO_START = za$1;
Lexical_prod.OUTDENT_CONTENT_COMMAND = {};
Lexical_prod.PASTE_COMMAND = ma$1;
Lexical_prod.ParagraphNode = If;
Lexical_prod.REDO_COMMAND = ta$1;
Lexical_prod.REMOVE_TEXT_COMMAND = na$1;
Lexical_prod.RootNode = Ff;
Lexical_prod.SELECTION_CHANGE_COMMAND = ba$2;
Lexical_prod.SELECT_ALL_COMMAND = Qa;
Lexical_prod.TabNode = Be;
Lexical_prod.TextNode = pe;
Lexical_prod.UNDO_COMMAND = sa$1;
Lexical_prod.createCommand = function() {
  return {};
};
Lexical_prod.createEditor = function(a2) {
  var b2 = a2 || {}, c2 = U$3, d2 = b2.theme || {};
  let e2 = void 0 === a2 ? c2 : b2.parentEditor || null, f2 = b2.disableEvents || false, g2 = Gf(), h2 = b2.namespace || (null !== e2 ? e2._config.namespace : lc()), k2 = b2.editorState, m2 = [Ff, pe, he, Be, If, ...b2.nodes || []], { onError: p2, html: n2 } = b2;
  b2 = void 0 !== b2.editable ? b2.editable : true;
  if (void 0 === a2 && null !== c2)
    a2 = c2._nodes;
  else
    for (a2 = /* @__PURE__ */ new Map(), c2 = 0; c2 < m2.length; c2++) {
      let q2 = m2[c2], u2 = null;
      var l2 = null;
      "function" !== typeof q2 && (l2 = q2, q2 = l2.replace, u2 = l2.with, l2 = l2.withKlass || null);
      let y2 = q2.getType(), x3 = q2.transform(), A2 = /* @__PURE__ */ new Set();
      null !== x3 && A2.add(x3);
      a2.set(y2, { exportDOM: n2 && n2.export ? n2.export.get(q2) : void 0, klass: q2, replace: u2, replaceWithKlass: l2, transforms: A2 });
    }
  d2 = new Qf(g2, e2, a2, { disableEvents: f2, namespace: h2, theme: d2 }, p2 ? p2 : console.error, Pf(a2, n2 ? n2.import : void 0), b2);
  void 0 !== k2 && (d2._pendingEditorState = k2, d2._dirtyType = 2);
  return d2;
};
Lexical_prod.getNearestEditorFromDOMNode = Ob;
Lexical_prod.isHTMLAnchorElement = function(a2) {
  return Fc(a2) && "A" === a2.tagName;
};
Lexical_prod.isHTMLElement = Fc;
Lexical_prod.isSelectionCapturedInDecoratorInput = Mb;
Lexical_prod.isSelectionWithinEditor = Nb;
const Lexical = Lexical_prod;
var Lexical_1 = Lexical;
var k$9 = Lexical_1;
let u$a = /* @__PURE__ */ new Map();
function v$7(a2) {
  for (; null != a2; ) {
    if (a2.nodeType === Node.TEXT_NODE)
      return a2;
    a2 = a2.firstChild;
  }
  return null;
}
function w$6(a2) {
  let b2 = a2.parentNode;
  if (null == b2)
    throw Error("Should never happen");
  return [b2, Array.from(b2.childNodes).indexOf(a2)];
}
function y$6(a2) {
  let b2 = {};
  a2 = a2.split(";");
  for (let d2 of a2)
    if ("" !== d2) {
      let [f2, c2] = d2.split(/:([^]+)/);
      f2 && c2 && (b2[f2.trim()] = c2.trim());
    }
  return b2;
}
function z$6(a2) {
  let b2 = u$a.get(a2);
  void 0 === b2 && (b2 = y$6(a2), u$a.set(a2, b2));
  return b2;
}
function A$2(a2) {
  let b2 = "";
  for (let d2 in a2)
    d2 && (b2 += `${d2}: ${a2[d2]};`);
  return b2;
}
function B$7(a2, b2) {
  var d2 = z$6("getStyle" in a2 ? a2.getStyle() : a2.style);
  b2 = Object.entries(b2).reduce((f2, [c2, g2]) => {
    null === g2 ? delete f2[c2] : f2[c2] = g2;
    return f2;
  }, { ...d2 });
  d2 = A$2(b2);
  a2.setStyle(d2);
  u$a.set(d2, b2);
}
function C$6(a2, b2) {
  var d2 = a2.getNodes(), f2 = d2.length;
  if (k$9.DEPRECATED_$isGridSelection(a2)) {
    var c2 = k$9.$createRangeSelection(), g2 = c2.anchor, h2 = c2.focus;
    for (var e2 = 0; e2 < f2; e2++) {
      var l2 = d2[e2];
      k$9.DEPRECATED_$isGridCellNode(l2) && (g2.set(l2.getKey(), 0, "element"), h2.set(l2.getKey(), l2.getChildrenSize(), "element"), C$6(k$9.$normalizeSelection__EXPERIMENTAL(c2), b2));
    }
    k$9.$setSelection(a2);
  } else if (--f2, c2 = d2[0], g2 = d2[f2], a2.isCollapsed() && k$9.$isRangeSelection(a2))
    B$7(a2, b2);
  else {
    e2 = a2.anchor;
    var m2 = a2.focus;
    l2 = c2.getTextContent().length;
    var p2 = m2.offset, n2 = e2.offset, r2 = e2.isBefore(m2);
    h2 = r2 ? n2 : p2;
    a2 = r2 ? p2 : n2;
    var q2 = r2 ? e2.type : m2.type, t3 = r2 ? m2.type : e2.type;
    m2 = r2 ? m2.key : e2.key;
    k$9.$isTextNode(c2) && h2 === l2 && (r2 = c2.getNextSibling(), k$9.$isTextNode(r2) && (h2 = n2 = 0, c2 = r2));
    if (1 === d2.length)
      k$9.$isTextNode(c2) && (h2 = "element" === q2 ? 0 : n2 > p2 ? p2 : n2, a2 = "element" === t3 ? l2 : n2 > p2 ? n2 : p2, h2 !== a2 && (0 === h2 && a2 === l2 ? (B$7(c2, b2), c2.select(h2, a2)) : (d2 = c2.splitText(h2, a2), d2 = 0 === h2 ? d2[0] : d2[1], B$7(d2, b2), d2.select(0, a2 - h2))));
    else
      for (k$9.$isTextNode(c2) && h2 < c2.getTextContentSize() && (0 !== h2 && (c2 = c2.splitText(h2)[1], h2 = 0, e2.set(c2.getKey(), h2, "text")), B$7(c2, b2)), k$9.$isTextNode(g2) && (h2 = g2.getTextContent().length, g2.__key !== m2 && 0 !== a2 && (a2 = h2), a2 !== h2 && ([g2] = g2.splitText(a2)), 0 !== a2 && B$7(g2, b2)), a2 = 1; a2 < f2; a2++)
        h2 = d2[a2], e2 = h2.getKey(), k$9.$isTextNode(h2) && e2 !== c2.getKey() && e2 !== g2.getKey() && !h2.isToken() && B$7(h2, b2);
  }
}
function D$5(a2) {
  for (; null !== a2 && !k$9.$isRootOrShadowRoot(a2); ) {
    let b2 = a2.getLatest(), d2 = a2.getParent();
    0 === b2.getChildrenSize() && a2.remove(true);
    a2 = d2;
  }
}
function E$5(a2, b2, d2, f2, c2 = null) {
  if (0 !== b2.length) {
    var g2 = b2[0], h2 = /* @__PURE__ */ new Map(), e2 = [];
    g2 = k$9.$isElementNode(g2) ? g2 : g2.getParentOrThrow();
    g2.isInline() && (g2 = g2.getParentOrThrow());
    for (var l2 = false; null !== g2; ) {
      var m2 = g2.getPreviousSibling();
      if (null !== m2) {
        g2 = m2;
        l2 = true;
        break;
      }
      g2 = g2.getParentOrThrow();
      if (k$9.$isRootOrShadowRoot(g2))
        break;
    }
    m2 = /* @__PURE__ */ new Set();
    for (var p2 = 0; p2 < d2; p2++) {
      var n2 = b2[p2];
      k$9.$isElementNode(n2) && 0 === n2.getChildrenSize() && m2.add(n2.getKey());
    }
    var r2 = /* @__PURE__ */ new Set();
    for (p2 = 0; p2 < d2; p2++) {
      n2 = b2[p2];
      var q2 = n2.getParent();
      null !== q2 && q2.isInline() && (q2 = q2.getParent());
      if (null !== q2 && k$9.$isLeafNode(n2) && !r2.has(n2.getKey())) {
        if (n2 = q2.getKey(), void 0 === h2.get(n2)) {
          let t3 = f2();
          t3.setFormat(q2.getFormatType());
          t3.setIndent(q2.getIndent());
          e2.push(t3);
          h2.set(n2, t3);
          q2.getChildren().forEach((x3) => {
            t3.append(x3);
            r2.add(x3.getKey());
            k$9.$isElementNode(x3) && x3.getChildrenKeys().forEach((I2) => r2.add(I2));
          });
          D$5(q2);
        }
      } else
        m2.has(n2.getKey()) && (q2 = f2(), q2.setFormat(n2.getFormatType()), q2.setIndent(n2.getIndent()), e2.push(q2), n2.remove(true));
    }
    if (null !== c2)
      for (b2 = 0; b2 < e2.length; b2++)
        c2.append(e2[b2]);
    b2 = null;
    if (k$9.$isRootOrShadowRoot(g2))
      if (l2)
        if (null !== c2)
          g2.insertAfter(c2);
        else
          for (c2 = e2.length - 1; 0 <= c2; c2--)
            g2.insertAfter(e2[c2]);
      else if (l2 = g2.getFirstChild(), k$9.$isElementNode(l2) && (g2 = l2), null === l2)
        if (c2)
          g2.append(c2);
        else
          for (c2 = 0; c2 < e2.length; c2++)
            l2 = e2[c2], g2.append(l2), b2 = l2;
      else if (null !== c2)
        l2.insertBefore(c2);
      else
        for (g2 = 0; g2 < e2.length; g2++)
          c2 = e2[g2], l2.insertBefore(c2), b2 = c2;
    else if (c2)
      g2.insertAfter(c2);
    else
      for (c2 = e2.length - 1; 0 <= c2; c2--)
        l2 = e2[c2], g2.insertAfter(l2), b2 = l2;
    e2 = k$9.$getPreviousSelection();
    k$9.$isRangeSelection(e2) && e2.anchor.getNode().isAttached() && e2.focus.getNode().isAttached() ? k$9.$setSelection(e2.clone()) : null !== b2 ? b2.selectEnd() : a2.dirty = true;
  }
}
function F$5(a2, b2, d2, f2) {
  a2.modify(b2 ? "extend" : "move", d2, f2);
}
function G$5(a2) {
  a2 = a2.anchor.getNode();
  return "rtl" === (k$9.$isRootNode(a2) ? a2 : a2.getParentOrThrow()).getDirection();
}
function H$5(a2) {
  if (k$9.$isDecoratorNode(a2) && !a2.isInline())
    return true;
  if (!k$9.$isElementNode(a2) || k$9.$isRootOrShadowRoot(a2))
    return false;
  var b2 = a2.getFirstChild();
  b2 = null === b2 || k$9.$isLineBreakNode(b2) || k$9.$isTextNode(b2) || b2.isInline();
  return !a2.isInline() && false !== a2.canBeEmpty() && b2;
}
LexicalSelection_prod.$addNodeStyle = function(a2) {
  a2 = a2.getStyle();
  let b2 = y$6(a2);
  u$a.set(a2, b2);
};
LexicalSelection_prod.$cloneWithProperties = function(a2) {
  let b2 = a2.constructor.clone(a2);
  b2.__parent = a2.__parent;
  b2.__next = a2.__next;
  b2.__prev = a2.__prev;
  if (k$9.$isElementNode(a2) && k$9.$isElementNode(b2))
    return b2.__first = a2.__first, b2.__last = a2.__last, b2.__size = a2.__size, b2.__format = a2.__format, b2.__indent = a2.__indent, b2.__dir = a2.__dir, b2;
  k$9.$isTextNode(a2) && k$9.$isTextNode(b2) && (b2.__format = a2.__format, b2.__style = a2.__style, b2.__mode = a2.__mode, b2.__detail = a2.__detail);
  return b2;
};
LexicalSelection_prod.$getSelectionStyleValueForProperty = function(a2, b2, d2 = "") {
  let f2 = null, c2 = a2.getNodes();
  var g2 = a2.anchor, h2 = a2.focus, e2 = a2.isBackward();
  let l2 = e2 ? h2.offset : g2.offset;
  g2 = e2 ? h2.getNode() : g2.getNode();
  if (a2.isCollapsed() && "" !== a2.style && (a2 = z$6(a2.style), null !== a2 && b2 in a2))
    return a2[b2];
  for (a2 = 0; a2 < c2.length; a2++) {
    var m2 = c2[a2];
    if ((0 === a2 || 0 !== l2 || !m2.is(g2)) && k$9.$isTextNode(m2)) {
      if (h2 = b2, e2 = d2, m2 = m2.getStyle(), m2 = z$6(m2), h2 = null !== m2 ? m2[h2] || e2 : e2, null === f2)
        f2 = h2;
      else if (f2 !== h2) {
        f2 = "";
        break;
      }
    }
  }
  return null === f2 ? d2 : f2;
};
LexicalSelection_prod.$isAtNodeEnd = function(a2) {
  return "text" === a2.type ? a2.offset === a2.getNode().getTextContentSize() : a2.offset === a2.getNode().getChildrenSize();
};
LexicalSelection_prod.$isParentElementRTL = G$5;
LexicalSelection_prod.$moveCaretSelection = F$5;
LexicalSelection_prod.$moveCharacter = function(a2, b2, d2) {
  let f2 = G$5(a2);
  F$5(a2, b2, d2 ? !f2 : f2, "character");
};
LexicalSelection_prod.$patchStyleText = C$6;
LexicalSelection_prod.$selectAll = function(a2) {
  let b2 = a2.anchor;
  a2 = a2.focus;
  var d2 = b2.getNode().getTopLevelElementOrThrow().getParentOrThrow();
  let f2 = d2.getFirstDescendant();
  d2 = d2.getLastDescendant();
  let c2 = "element", g2 = "element", h2 = 0;
  k$9.$isTextNode(f2) ? c2 = "text" : k$9.$isElementNode(f2) || null === f2 || (f2 = f2.getParentOrThrow());
  k$9.$isTextNode(d2) ? (g2 = "text", h2 = d2.getTextContentSize()) : k$9.$isElementNode(d2) || null === d2 || (d2 = d2.getParentOrThrow());
  f2 && d2 && (b2.set(f2.getKey(), 0, c2), a2.set(d2.getKey(), h2, g2));
};
LexicalSelection_prod.$setBlocksType = function(a2, b2) {
  if ("root" === a2.anchor.key) {
    b2 = b2();
    var d2 = k$9.$getRoot();
    (a2 = d2.getFirstChild()) ? a2.replace(b2, true) : d2.append(b2);
  } else {
    d2 = a2.getNodes();
    for (a2 = a2.anchor.getNode(); null !== a2 && null !== a2.getParent() && !H$5(a2); )
      a2 = a2.getParentOrThrow();
    (a2 = H$5(a2) ? a2 : null) && -1 === d2.indexOf(a2) && d2.push(a2);
    for (a2 = 0; a2 < d2.length; a2++) {
      let f2 = d2[a2];
      if (!H$5(f2))
        continue;
      let c2 = b2();
      c2.setFormat(f2.getFormatType());
      c2.setIndent(f2.getIndent());
      f2.replace(c2, true);
    }
  }
};
LexicalSelection_prod.$shouldOverrideDefaultCharacterSelection = function(a2, b2) {
  a2 = k$9.$getAdjacentNode(a2.focus, b2);
  return k$9.$isDecoratorNode(a2) && !a2.isIsolated() || k$9.$isElementNode(a2) && !a2.isInline() && !a2.canBeEmpty();
};
LexicalSelection_prod.$sliceSelectedTextNodeContent = function(a2, b2) {
  if (b2.isSelected() && !b2.isSegmented() && !b2.isToken() && k$9.$INTERNAL_isPointSelection(a2)) {
    var d2 = a2.anchor.getNode(), f2 = a2.focus.getNode(), c2 = b2.is(d2), g2 = b2.is(f2);
    if (c2 || g2) {
      c2 = a2.isBackward();
      let [h2, e2] = a2.getCharacterOffsets();
      a2 = d2.is(f2);
      g2 = b2.is(c2 ? f2 : d2);
      f2 = b2.is(c2 ? d2 : f2);
      d2 = 0;
      let l2 = void 0;
      a2 ? (d2 = h2 > e2 ? e2 : h2, l2 = h2 > e2 ? h2 : e2) : g2 ? (d2 = c2 ? e2 : h2, l2 = void 0) : f2 && (c2 = c2 ? h2 : e2, d2 = 0, l2 = c2);
      b2.__text = b2.__text.slice(d2, l2);
    }
  }
  return b2;
};
LexicalSelection_prod.$wrapNodes = function(a2, b2, d2 = null) {
  var f2 = a2.getNodes();
  let c2 = f2.length;
  var g2 = a2.anchor;
  if (0 === c2 || 1 === c2 && "element" === g2.type && 0 === g2.getNode().getChildrenSize()) {
    a2 = "text" === g2.type ? g2.getNode().getParentOrThrow() : g2.getNode();
    f2 = a2.getChildren();
    let e2 = b2();
    e2.setFormat(a2.getFormatType());
    e2.setIndent(a2.getIndent());
    f2.forEach((l2) => e2.append(l2));
    d2 && (e2 = d2.append(e2));
    a2.replace(e2);
  } else {
    g2 = null;
    var h2 = [];
    for (let e2 = 0; e2 < c2; e2++) {
      let l2 = f2[e2];
      k$9.$isRootOrShadowRoot(l2) ? (E$5(a2, h2, h2.length, b2, d2), h2 = [], g2 = l2) : null === g2 || null !== g2 && k$9.$hasAncestor(
        l2,
        g2
      ) ? h2.push(l2) : (E$5(a2, h2, h2.length, b2, d2), h2 = [l2]);
    }
    E$5(a2, h2, h2.length, b2, d2);
  }
};
LexicalSelection_prod.createDOMRange = function(a2, b2, d2, f2, c2) {
  let g2 = b2.getKey(), h2 = f2.getKey(), e2 = document.createRange(), l2 = a2.getElementByKey(g2);
  a2 = a2.getElementByKey(h2);
  k$9.$isTextNode(b2) && (l2 = v$7(l2));
  k$9.$isTextNode(f2) && (a2 = v$7(a2));
  if (void 0 === b2 || void 0 === f2 || null === l2 || null === a2)
    return null;
  "BR" === l2.nodeName && ([l2, d2] = w$6(l2));
  "BR" === a2.nodeName && ([a2, c2] = w$6(a2));
  b2 = l2.firstChild;
  l2 === a2 && null != b2 && "BR" === b2.nodeName && 0 === d2 && 0 === c2 && (c2 = 1);
  try {
    e2.setStart(l2, d2), e2.setEnd(a2, c2);
  } catch (m2) {
    return null;
  }
  !e2.collapsed || d2 === c2 && g2 === h2 || (e2.setStart(a2, c2), e2.setEnd(
    l2,
    d2
  ));
  return e2;
};
LexicalSelection_prod.createRectsFromDOMRange = function(a2, b2) {
  var d2 = a2.getRootElement();
  if (null === d2)
    return [];
  a2 = d2.getBoundingClientRect();
  d2 = getComputedStyle(d2);
  d2 = parseFloat(d2.paddingLeft) + parseFloat(d2.paddingRight);
  b2 = Array.from(b2.getClientRects());
  let f2 = b2.length;
  b2.sort((g2, h2) => {
    let e2 = g2.top - h2.top;
    return 3 >= Math.abs(e2) ? g2.left - h2.left : e2;
  });
  let c2;
  for (let g2 = 0; g2 < f2; g2++) {
    let h2 = b2[g2], e2 = h2.width + d2 === a2.width;
    c2 && c2.top <= h2.top && c2.top + c2.height > h2.top && c2.left + c2.width > h2.left || e2 ? (b2.splice(g2--, 1), f2--) : c2 = h2;
  }
  return b2;
};
LexicalSelection_prod.getStyleObjectFromCSS = z$6;
LexicalSelection_prod.trimTextContentFromAnchor = function(a2, b2, d2) {
  let f2 = b2.getNode();
  if (k$9.$isElementNode(f2)) {
    var c2 = f2.getDescendantByIndex(b2.offset);
    null !== c2 && (f2 = c2);
  }
  for (; 0 < d2 && null !== f2; ) {
    k$9.$isElementNode(f2) && (c2 = f2.getLastDescendant(), null !== c2 && (f2 = c2));
    var g2 = f2.getPreviousSibling(), h2 = 0;
    if (null === g2) {
      c2 = f2.getParentOrThrow();
      for (var e2 = c2.getPreviousSibling(); null === e2; ) {
        c2 = c2.getParent();
        if (null === c2) {
          g2 = null;
          break;
        }
        e2 = c2.getPreviousSibling();
      }
      null !== c2 && (h2 = c2.isInline() ? 0 : 2, g2 = e2);
    }
    e2 = f2.getTextContent();
    "" === e2 && k$9.$isElementNode(f2) && !f2.isInline() && (e2 = "\n\n");
    c2 = e2.length;
    if (!k$9.$isTextNode(f2) || d2 >= c2)
      e2 = f2.getParent(), f2.remove(), null == e2 || 0 !== e2.getChildrenSize() || k$9.$isRootNode(e2) || e2.remove(), d2 -= c2 + h2, f2 = g2;
    else {
      let l2 = f2.getKey();
      h2 = a2.getEditorState().read(() => {
        const p2 = k$9.$getNodeByKey(l2);
        return k$9.$isTextNode(p2) && p2.isSimpleText() ? p2.getTextContent() : null;
      });
      g2 = c2 - d2;
      let m2 = e2.slice(0, g2);
      null !== h2 && h2 !== e2 ? (d2 = k$9.$getPreviousSelection(), c2 = f2, f2.isSimpleText() ? f2.setTextContent(h2) : (c2 = k$9.$createTextNode(h2), f2.replace(c2)), k$9.$isRangeSelection(d2) && d2.isCollapsed() && (d2 = d2.anchor.offset, c2.select(d2, d2))) : f2.isSimpleText() ? (h2 = b2.key === l2, e2 = b2.offset, e2 < d2 && (e2 = c2), d2 = h2 ? e2 - d2 : 0, c2 = h2 ? e2 : g2, h2 && 0 === d2 ? ([d2] = f2.splitText(d2, c2), d2.remove()) : ([, d2] = f2.splitText(d2, c2), d2.remove())) : (d2 = k$9.$createTextNode(m2), f2.replace(d2));
      d2 = 0;
    }
  }
};
const LexicalSelection = LexicalSelection_prod;
var LexicalSelection_1 = LexicalSelection;
var k$8 = LexicalSelection_1, B$6 = Lexical_1;
function C$5(a2) {
  let b2 = new URLSearchParams();
  b2.append("code", a2);
  for (let c2 = 1; c2 < arguments.length; c2++)
    b2.append("v", arguments[c2]);
  throw Error(`Minified Lexical error #${a2}; visit https://lexical.dev/docs/error?${b2} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function D$4(...a2) {
  return () => {
    a2.forEach((b2) => b2());
  };
}
let E$4 = { attributes: true, characterData: true, childList: true, subtree: true };
function F$4(a2, b2, c2) {
  function e2() {
    if (null === g2)
      throw Error("Unexpected null rootDOMNode");
    if (null === n2)
      throw Error("Unexpected null parentDOMNode");
    let { left: p2, top: z2 } = g2.getBoundingClientRect();
    var q2 = n2;
    let r2 = k$8.createRectsFromDOMRange(a2, b2);
    t3.isConnected || q2.append(t3);
    q2 = false;
    for (let x3 = 0; x3 < r2.length; x3++) {
      var w2 = r2[x3];
      let u2 = h2[x3] || document.createElement("div"), y2 = u2.style;
      "absolute" !== y2.position && (y2.position = "absolute", q2 = true);
      var l2 = `${w2.left - p2}px`;
      y2.left !== l2 && (y2.left = l2, q2 = true);
      l2 = `${w2.top - z2}px`;
      y2.top !== l2 && (u2.style.top = l2, q2 = true);
      l2 = `${w2.width}px`;
      y2.width !== l2 && (u2.style.width = l2, q2 = true);
      w2 = `${w2.height}px`;
      y2.height !== w2 && (u2.style.height = w2, q2 = true);
      u2.parentNode !== t3 && (t3.append(u2), q2 = true);
      h2[x3] = u2;
    }
    for (; h2.length > r2.length; )
      h2.pop();
    q2 && c2(h2);
  }
  function d2() {
    g2 = n2 = null;
    null !== m2 && m2.disconnect();
    m2 = null;
    t3.remove();
    for (let p2 of h2)
      p2.remove();
    h2 = [];
  }
  function f2() {
    let p2 = a2.getRootElement();
    if (null === p2)
      return d2();
    let z2 = p2.parentElement;
    if (!(z2 instanceof HTMLElement))
      return d2();
    d2();
    g2 = p2;
    n2 = z2;
    m2 = new MutationObserver((q2) => {
      let r2 = a2.getRootElement(), w2 = r2 && r2.parentElement;
      if (r2 !== g2 || w2 !== n2)
        return f2();
      for (let l2 of q2)
        if (!t3.contains(l2.target))
          return e2();
    });
    m2.observe(z2, E$4);
    e2();
  }
  let g2 = null, n2 = null, m2 = null, h2 = [], t3 = document.createElement("div"), A2 = a2.registerRootListener(f2);
  return () => {
    A2();
    d2();
  };
}
function G$4(a2, b2) {
  for (let c2 of b2)
    if (a2.type.startsWith(c2))
      return true;
  return false;
}
function H$4(a2, b2) {
  for (; a2 !== B$6.$getRoot() && null != a2; ) {
    if (b2(a2))
      return a2;
    a2 = a2.getParent();
  }
  return null;
}
LexicalUtils_prod.$splitNode = B$6.$splitNode;
LexicalUtils_prod.isHTMLAnchorElement = B$6.isHTMLAnchorElement;
LexicalUtils_prod.isHTMLElement = B$6.isHTMLElement;
LexicalUtils_prod.$dfs = function(a2, b2) {
  let c2 = [];
  a2 = (a2 || B$6.$getRoot()).getLatest();
  b2 = b2 || (B$6.$isElementNode(a2) ? a2.getLastDescendant() : a2);
  for (var e2 = a2, d2 = 0; null !== (e2 = e2.getParent()); )
    d2++;
  for (e2 = d2; null !== a2 && !a2.is(b2); )
    if (c2.push({ depth: e2, node: a2 }), B$6.$isElementNode(a2) && 0 < a2.getChildrenSize())
      a2 = a2.getFirstChild(), e2++;
    else
      for (d2 = null; null === d2 && null !== a2; )
        d2 = a2.getNextSibling(), null === d2 ? (a2 = a2.getParent(), e2--) : a2 = d2;
  null !== a2 && a2.is(b2) && c2.push({ depth: e2, node: a2 });
  return c2;
};
LexicalUtils_prod.$filter = function(a2, b2) {
  let c2 = [];
  for (let e2 = 0; e2 < a2.length; e2++) {
    let d2 = b2(a2[e2]);
    null !== d2 && c2.push(d2);
  }
  return c2;
};
LexicalUtils_prod.$findMatchingParent = H$4;
LexicalUtils_prod.$getNearestBlockElementAncestorOrThrow = function(a2) {
  let b2 = H$4(a2, (c2) => B$6.$isElementNode(c2) && !c2.isInline());
  B$6.$isElementNode(b2) || C$5(4, a2.__key);
  return b2;
};
LexicalUtils_prod.$getNearestNodeOfType = function(a2, b2) {
  for (; null != a2; ) {
    if (a2 instanceof b2)
      return a2;
    a2 = a2.getParent();
  }
  return null;
};
LexicalUtils_prod.$insertFirst = function(a2, b2) {
  let c2 = a2.getFirstChild();
  null !== c2 ? c2.insertBefore(b2) : a2.append(b2);
};
LexicalUtils_prod.$insertNodeToNearestRoot = function(a2) {
  var b2 = B$6.$getSelection() || B$6.$getPreviousSelection();
  if (B$6.$isRangeSelection(b2)) {
    var { focus: c2 } = b2;
    b2 = c2.getNode();
    c2 = c2.offset;
    if (B$6.$isRootOrShadowRoot(b2))
      c2 = b2.getChildAtIndex(c2), null == c2 ? b2.append(a2) : c2.insertBefore(a2), a2.selectNext();
    else {
      let e2, d2;
      B$6.$isTextNode(b2) ? (e2 = b2.getParentOrThrow(), d2 = b2.getIndexWithinParent(), 0 < c2 && (d2 += 1, b2.splitText(c2))) : (e2 = b2, d2 = c2);
      [, b2] = B$6.$splitNode(e2, d2);
      b2.insertBefore(a2);
      b2.selectStart();
    }
  } else
    null != b2 ? (b2 = b2.getNodes(), b2[b2.length - 1].getTopLevelElementOrThrow().insertAfter(a2)) : B$6.$getRoot().append(a2), b2 = B$6.$createParagraphNode(), a2.insertAfter(b2), b2.select();
  return a2.getLatest();
};
LexicalUtils_prod.$restoreEditorState = function(a2, b2) {
  let c2 = /* @__PURE__ */ new Map(), e2 = a2._pendingEditorState;
  for (let [d2, f2] of b2._nodeMap) {
    let g2 = k$8.$cloneWithProperties(f2);
    B$6.$isTextNode(g2) && (g2.__text = f2.__text);
    c2.set(d2, g2);
  }
  e2 && (e2._nodeMap = c2);
  a2._dirtyType = 2;
  a2 = b2._selection;
  B$6.$setSelection(null === a2 ? null : a2.clone());
};
LexicalUtils_prod.$wrapNodeInElement = function(a2, b2) {
  b2 = b2();
  a2.replace(b2);
  b2.append(a2);
  return b2;
};
LexicalUtils_prod.addClassNamesToElement = function(a2, ...b2) {
  b2.forEach((c2) => {
    "string" === typeof c2 && (c2 = c2.split(" ").filter((e2) => "" !== e2), a2.classList.add(...c2));
  });
};
LexicalUtils_prod.isMimeType = G$4;
LexicalUtils_prod.markSelection = function(a2, b2) {
  function c2(m2) {
    m2.read(() => {
      var h2 = B$6.$getSelection();
      if (B$6.$isRangeSelection(h2)) {
        var { anchor: t3, focus: A2 } = h2;
        h2 = t3.getNode();
        var p2 = h2.getKey(), z2 = t3.offset, q2 = A2.getNode(), r2 = q2.getKey(), w2 = A2.offset, l2 = a2.getElementByKey(p2), x3 = a2.getElementByKey(r2);
        p2 = null === e2 || null === l2 || z2 !== d2 || p2 !== e2.getKey() || h2 !== e2 && (!(e2 instanceof B$6.TextNode) || h2.updateDOM(e2, l2, a2._config));
        r2 = null === f2 || null === x3 || w2 !== g2 || r2 !== f2.getKey() || q2 !== f2 && (!(f2 instanceof B$6.TextNode) || q2.updateDOM(f2, x3, a2._config));
        if (p2 || r2) {
          l2 = a2.getElementByKey(t3.getNode().getKey());
          var u2 = a2.getElementByKey(A2.getNode().getKey());
          if (null !== l2 && null !== u2 && "SPAN" === l2.tagName && "SPAN" === u2.tagName) {
            r2 = document.createRange();
            A2.isBefore(t3) ? (p2 = u2, x3 = A2.offset, u2 = l2, l2 = t3.offset) : (p2 = l2, x3 = t3.offset, l2 = A2.offset);
            p2 = p2.firstChild;
            if (null === p2)
              throw Error("Expected text node to be first child of span");
            u2 = u2.firstChild;
            if (null === u2)
              throw Error("Expected text node to be first child of span");
            r2.setStart(p2, x3);
            r2.setEnd(u2, l2);
            n2();
            n2 = F$4(a2, r2, (y2) => {
              for (let I2 of y2) {
                let v3 = I2.style;
                "Highlight" !== v3.background && (v3.background = "Highlight");
                "HighlightText" !== v3.color && (v3.color = "HighlightText");
                "-1" !== v3.zIndex && (v3.zIndex = "-1");
                "none" !== v3.pointerEvents && (v3.pointerEvents = "none");
                "-1.5px" !== v3.marginTop && (v3.marginTop = "-1.5px");
                "4px" !== v3.paddingTop && (v3.paddingTop = "4px");
                "0px" !== v3.paddingBottom && (v3.paddingBottom = "0px");
              }
              void 0 !== b2 && b2(y2);
            });
          }
        }
        e2 = h2;
        d2 = z2;
        f2 = q2;
        g2 = w2;
      } else
        g2 = f2 = d2 = e2 = null, n2(), n2 = () => {
        };
    });
  }
  let e2 = null, d2 = null, f2 = null, g2 = null, n2 = () => {
  };
  c2(a2.getEditorState());
  return D$4(a2.registerUpdateListener(({ editorState: m2 }) => c2(m2)), n2, () => {
    n2();
  });
};
LexicalUtils_prod.mediaFileReader = function(a2, b2) {
  let c2 = a2[Symbol.iterator]();
  return new Promise((e2, d2) => {
    let f2 = [], g2 = () => {
      const { done: n2, value: m2 } = c2.next();
      if (n2)
        return e2(f2);
      const h2 = new FileReader();
      h2.addEventListener("error", d2);
      h2.addEventListener("load", () => {
        const t3 = h2.result;
        "string" === typeof t3 && f2.push({ file: m2, result: t3 });
        g2();
      });
      G$4(m2, b2) ? h2.readAsDataURL(m2) : g2();
    };
    g2();
  });
};
LexicalUtils_prod.mergeRegister = D$4;
LexicalUtils_prod.objectKlassEquals = function(a2, b2) {
  return null !== a2 ? Object.getPrototypeOf(a2).constructor.name === b2.name : false;
};
LexicalUtils_prod.positionNodeOnRange = F$4;
LexicalUtils_prod.registerNestedElementResolver = function(a2, b2, c2, e2) {
  return a2.registerNodeTransform(b2, (d2) => {
    a: {
      var f2 = d2.getChildren();
      for (var g2 = 0; g2 < f2.length; g2++)
        if (f2[g2] instanceof b2) {
          f2 = null;
          break a;
        }
      for (f2 = d2; null !== f2; )
        if (g2 = f2, f2 = f2.getParent(), f2 instanceof b2) {
          f2 = { child: g2, parent: f2 };
          break a;
        }
      f2 = null;
    }
    if (null !== f2) {
      const { child: n2, parent: m2 } = f2;
      if (n2.is(d2)) {
        e2(m2, d2);
        d2 = n2.getNextSiblings();
        f2 = d2.length;
        m2.insertAfter(n2);
        if (0 !== f2) {
          g2 = c2(m2);
          n2.insertAfter(g2);
          for (let h2 = 0; h2 < f2; h2++)
            g2.append(d2[h2]);
        }
        m2.canBeEmpty() || 0 !== m2.getChildrenSize() || m2.remove();
      }
    }
  });
};
LexicalUtils_prod.removeClassNamesFromElement = function(a2, ...b2) {
  b2.forEach((c2) => {
    "string" === typeof c2 && a2.classList.remove(...c2.split(" "));
  });
};
const LexicalUtils = LexicalUtils_prod;
var LexicalUtils_1 = LexicalUtils;
var c$5 = LexicalUtils_1, x$4 = Lexical_1;
function y$5(b2, a2, l2, h2, n2) {
  if (null === b2 || 0 === l2.size && 0 === h2.size && !n2)
    return 0;
  var f2 = a2._selection, d2 = b2._selection;
  if (n2)
    return 1;
  if (!(x$4.$isRangeSelection(f2) && x$4.$isRangeSelection(d2) && d2.isCollapsed() && f2.isCollapsed()))
    return 0;
  n2 = a2._nodeMap;
  let e2 = [];
  for (let m2 of l2)
    l2 = n2.get(m2), void 0 !== l2 && e2.push(l2);
  for (let [m2, p2] of h2)
    p2 && (h2 = n2.get(m2), void 0 === h2 || x$4.$isRootNode(h2) || e2.push(h2));
  if (0 === e2.length)
    return 0;
  if (1 < e2.length)
    return h2 = a2._nodeMap, a2 = h2.get(f2.anchor.key), d2 = h2.get(d2.anchor.key), a2 && d2 && !b2._nodeMap.has(a2.__key) && x$4.$isTextNode(a2) && 1 === a2.__text.length && 1 === f2.anchor.offset ? 2 : 0;
  a2 = e2[0];
  b2 = b2._nodeMap.get(a2.__key);
  if (!x$4.$isTextNode(b2) || !x$4.$isTextNode(a2) || b2.__mode !== a2.__mode)
    return 0;
  b2 = b2.__text;
  a2 = a2.__text;
  if (b2 === a2)
    return 0;
  f2 = f2.anchor;
  d2 = d2.anchor;
  if (f2.key !== d2.key || "text" !== f2.type)
    return 0;
  f2 = f2.offset;
  d2 = d2.offset;
  b2 = a2.length - b2.length;
  return 1 === b2 && d2 === f2 - 1 ? 2 : -1 === b2 && d2 === f2 + 1 ? 3 : -1 === b2 && d2 === f2 ? 4 : 0;
}
function z$5(b2, a2) {
  let l2 = Date.now(), h2 = 0;
  return (n2, f2, d2, e2, m2, p2) => {
    let r2 = Date.now();
    if (p2.has("historic"))
      return h2 = 0, l2 = r2, 2;
    let q2 = y$5(n2, f2, e2, m2, b2.isComposing()), v3 = (() => {
      var k2 = null === d2 || d2.editor === b2, g2 = p2.has("history-push");
      if (!g2 && k2 && p2.has("history-merge"))
        return 0;
      if (null === n2)
        return 1;
      var t3 = f2._selection;
      if (!(0 < e2.size || 0 < m2.size))
        return null !== t3 ? 0 : 2;
      if (false === g2 && 0 !== q2 && q2 === h2 && r2 < l2 + a2 && k2)
        return 0;
      if (1 === e2.size) {
        {
          g2 = Array.from(e2)[0];
          k2 = n2._nodeMap.get(g2);
          g2 = f2._nodeMap.get(g2);
          t3 = n2._selection;
          let u2 = f2._selection, w2 = false;
          x$4.$isRangeSelection(t3) && x$4.$isRangeSelection(u2) && (w2 = "element" === t3.anchor.type && "element" === t3.focus.type && "text" === u2.anchor.type && "text" === u2.focus.type);
          k2 = !w2 && x$4.$isTextNode(k2) && x$4.$isTextNode(g2) ? k2.__type === g2.__type && k2.__text === g2.__text && k2.__mode === g2.__mode && k2.__detail === g2.__detail && k2.__style === g2.__style && k2.__format === g2.__format && k2.__parent === g2.__parent : false;
        }
        if (k2)
          return 0;
      }
      return 1;
    })();
    l2 = r2;
    h2 = q2;
    return v3;
  };
}
LexicalHistory_prod.createEmptyHistoryState = function() {
  return { current: null, redoStack: [], undoStack: [] };
};
LexicalHistory_prod.registerHistory = function(b2, a2, l2) {
  let h2 = z$5(b2, l2);
  l2 = ({ editorState: d2, prevEditorState: e2, dirtyLeaves: m2, dirtyElements: p2, tags: r2 }) => {
    const q2 = a2.current, v3 = a2.redoStack, k2 = a2.undoStack, g2 = null === q2 ? null : q2.editorState;
    if (null === q2 || d2 !== g2) {
      e2 = h2(e2, d2, q2, m2, p2, r2);
      if (1 === e2)
        0 !== v3.length && (a2.redoStack = [], b2.dispatchCommand(x$4.CAN_REDO_COMMAND, false)), null !== q2 && (k2.push({ ...q2 }), b2.dispatchCommand(x$4.CAN_UNDO_COMMAND, true));
      else if (2 === e2)
        return;
      a2.current = { editor: b2, editorState: d2 };
    }
  };
  let n2 = c$5.mergeRegister(b2.registerCommand(
    x$4.UNDO_COMMAND,
    () => {
      let d2 = a2.redoStack, e2 = a2.undoStack;
      if (0 !== e2.length) {
        let m2 = a2.current, p2 = e2.pop();
        null !== m2 && (d2.push(m2), b2.dispatchCommand(x$4.CAN_REDO_COMMAND, true));
        0 === e2.length && b2.dispatchCommand(x$4.CAN_UNDO_COMMAND, false);
        a2.current = p2 || null;
        p2 && p2.editor.setEditorState(p2.editorState, { tag: "historic" });
      }
      return true;
    },
    x$4.COMMAND_PRIORITY_EDITOR
  ), b2.registerCommand(x$4.REDO_COMMAND, () => {
    let d2 = a2.redoStack;
    var e2 = a2.undoStack;
    if (0 !== d2.length) {
      let m2 = a2.current;
      null !== m2 && (e2.push(m2), b2.dispatchCommand(x$4.CAN_UNDO_COMMAND, true));
      e2 = d2.pop();
      0 === d2.length && b2.dispatchCommand(x$4.CAN_REDO_COMMAND, false);
      a2.current = e2 || null;
      e2 && e2.editor.setEditorState(e2.editorState, { tag: "historic" });
    }
    return true;
  }, x$4.COMMAND_PRIORITY_EDITOR), b2.registerCommand(x$4.CLEAR_EDITOR_COMMAND, () => {
    a2.undoStack = [];
    a2.redoStack = [];
    a2.current = null;
    return false;
  }, x$4.COMMAND_PRIORITY_EDITOR), b2.registerCommand(x$4.CLEAR_HISTORY_COMMAND, () => {
    a2.undoStack = [];
    a2.redoStack = [];
    a2.current = null;
    b2.dispatchCommand(x$4.CAN_REDO_COMMAND, false);
    b2.dispatchCommand(x$4.CAN_UNDO_COMMAND, false);
    return true;
  }, x$4.COMMAND_PRIORITY_EDITOR), b2.registerUpdateListener(l2)), f2 = b2.registerUpdateListener(l2);
  return () => {
    n2();
    f2();
  };
};
const LexicalHistory = LexicalHistory_prod;
var LexicalHistory_1 = LexicalHistory;
var c$4 = LexicalComposerContext_1, history = LexicalHistory_1, f$6 = reactExports;
function g$a(a2, b2, d2 = 1e3) {
  let e2 = f$6.useMemo(() => b2 || history.createEmptyHistoryState(), [b2]);
  f$6.useEffect(() => history.registerHistory(a2, e2, d2), [d2, a2, e2]);
}
LexicalHistoryPlugin_prod.createEmptyHistoryState = history.createEmptyHistoryState;
LexicalHistoryPlugin_prod.HistoryPlugin = function({ externalHistoryState: a2 }) {
  let [b2] = c$4.useLexicalComposerContext();
  g$a(b2, a2);
  return null;
};
const LexicalHistoryPlugin = LexicalHistoryPlugin_prod;
var LexicalHistoryPlugin_1 = LexicalHistoryPlugin;
var LexicalRichText_prod = {};
var LexicalClipboard_prod = {};
var LexicalHtml_prod = {};
var m$8 = LexicalSelection_1, p$8 = LexicalUtils_1, q$8 = Lexical_1;
function u$9(c2, e2, h2, a2 = null) {
  let f2 = null != a2 ? e2.isSelected(a2) : true, k2 = q$8.$isElementNode(e2) && e2.excludeFromCopy("html");
  var d2 = e2;
  null !== a2 && (d2 = m$8.$cloneWithProperties(e2), d2 = q$8.$isTextNode(d2) && null != a2 ? m$8.$sliceSelectedTextNodeContent(a2, d2) : d2);
  let g2 = q$8.$isElementNode(d2) ? d2.getChildren() : [];
  var b2 = c2._nodes.get(d2.getType());
  b2 = b2 && void 0 !== b2.exportDOM ? b2.exportDOM(c2, d2) : d2.exportDOM(c2);
  let { element: l2, after: r2 } = b2;
  if (!l2)
    return false;
  b2 = document.createDocumentFragment();
  for (let n2 = 0; n2 < g2.length; n2++) {
    let t3 = g2[n2], x3 = u$9(c2, t3, b2, a2);
    !f2 && q$8.$isElementNode(e2) && x3 && e2.extractWithChild(t3, a2, "html") && (f2 = true);
  }
  f2 && !k2 ? (p$8.isHTMLElement(l2) && l2.append(b2), h2.append(l2), r2 && (c2 = r2.call(d2, l2)) && l2.replaceWith(c2)) : h2.append(b2);
  return f2;
}
let v$6 = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
function w$5(c2, e2, h2 = /* @__PURE__ */ new Map(), a2) {
  let f2 = [];
  if (v$6.has(c2.nodeName))
    return f2;
  let k2 = null;
  var d2, { nodeName: g2 } = c2, b2 = e2._htmlConversions.get(g2.toLowerCase());
  g2 = null;
  if (void 0 !== b2)
    for (d2 of b2)
      b2 = d2(c2), null !== b2 && (null === g2 || g2.priority < b2.priority) && (g2 = b2);
  g2 = (d2 = null !== g2 ? g2.conversion : null) ? d2(c2) : null;
  d2 = null;
  if (null !== g2) {
    d2 = g2.after;
    b2 = g2.node;
    k2 = Array.isArray(b2) ? b2[b2.length - 1] : b2;
    if (null !== k2) {
      for (var [, l2] of h2)
        if (k2 = l2(k2, a2), !k2)
          break;
      k2 && f2.push(...Array.isArray(b2) ? b2 : [k2]);
    }
    null != g2.forChild && h2.set(c2.nodeName, g2.forChild);
  }
  c2 = c2.childNodes;
  a2 = [];
  for (l2 = 0; l2 < c2.length; l2++)
    a2.push(...w$5(c2[l2], e2, new Map(h2), k2));
  null != d2 && (a2 = d2(a2));
  null == k2 ? f2 = f2.concat(a2) : q$8.$isElementNode(k2) && k2.append(...a2);
  return f2;
}
LexicalHtml_prod.$generateHtmlFromNodes = function(c2, e2) {
  if ("undefined" === typeof document || "undefined" === typeof window)
    throw Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  let h2 = document.createElement("div"), a2 = q$8.$getRoot().getChildren();
  for (let f2 = 0; f2 < a2.length; f2++)
    u$9(c2, a2[f2], h2, e2);
  return h2.innerHTML;
};
LexicalHtml_prod.$generateNodesFromDOM = function(c2, e2) {
  e2 = e2.body ? e2.body.childNodes : [];
  let h2 = [];
  for (let f2 = 0; f2 < e2.length; f2++) {
    var a2 = e2[f2];
    v$6.has(a2.nodeName) || (a2 = w$5(a2, c2), null !== a2 && (h2 = h2.concat(a2)));
  }
  return h2;
};
const LexicalHtml = LexicalHtml_prod;
var LexicalHtml_1 = LexicalHtml;
var d$4 = LexicalHtml_1, q$7 = LexicalSelection_1, r$9 = LexicalUtils_1, u$8 = Lexical_1;
function z$4(a2) {
  let b2 = new URLSearchParams();
  b2.append("code", a2);
  for (let c2 = 1; c2 < arguments.length; c2++)
    b2.append("v", arguments[c2]);
  throw Error(`Minified Lexical error #${a2}; visit https://lexical.dev/docs/error?${b2} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
let A$1 = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement;
function B$5(a2) {
  let b2 = u$8.$getSelection();
  if (null == b2)
    throw Error("Expected valid LexicalSelection");
  return u$8.$isRangeSelection(b2) && b2.isCollapsed() || 0 === b2.getNodes().length ? "" : d$4.$generateHtmlFromNodes(a2, b2);
}
function C$4(a2) {
  let b2 = u$8.$getSelection();
  if (null == b2)
    throw Error("Expected valid LexicalSelection");
  return u$8.$isRangeSelection(b2) && b2.isCollapsed() || 0 === b2.getNodes().length ? null : JSON.stringify(D$3(a2, b2));
}
function E$3(a2, b2, c2) {
  let g2 = u$8.DEPRECATED_$isGridSelection(c2), e2 = u$8.$isRangeSelection(c2);
  (g2 || e2 && null !== r$9.$findMatchingParent(c2.anchor.getNode(), (h2) => u$8.DEPRECATED_$isGridCellNode(h2)) && null !== r$9.$findMatchingParent(c2.focus.getNode(), (h2) => u$8.DEPRECATED_$isGridCellNode(h2))) && 1 === b2.length && u$8.DEPRECATED_$isGridNode(b2[0]) ? F$3(b2, c2, false, a2) : c2.insertNodes(b2);
}
function F$3(a2, b2, c2, g2) {
  1 === a2.length && u$8.DEPRECATED_$isGridNode(a2[0]) || z$4(42);
  var e2 = a2[0];
  a2 = e2.getChildren();
  c2 = e2.getFirstChildOrThrow().getChildrenSize();
  var h2 = e2.getChildrenSize(), f2 = r$9.$findMatchingParent(b2.anchor.getNode(), (l2) => u$8.DEPRECATED_$isGridCellNode(l2));
  b2 = (e2 = f2 && r$9.$findMatchingParent(f2, (l2) => u$8.DEPRECATED_$isGridRowNode(l2))) && r$9.$findMatchingParent(e2, (l2) => u$8.DEPRECATED_$isGridNode(l2));
  u$8.DEPRECATED_$isGridCellNode(f2) && u$8.DEPRECATED_$isGridRowNode(e2) && u$8.DEPRECATED_$isGridNode(b2) || z$4(43);
  var k2 = e2.getIndexWithinParent(), m2 = Math.min(b2.getChildrenSize() - 1, k2 + h2 - 1);
  h2 = f2.getIndexWithinParent();
  f2 = Math.min(e2.getChildrenSize() - 1, h2 + c2 - 1);
  c2 = Math.min(h2, f2);
  e2 = Math.min(k2, m2);
  h2 = Math.max(h2, f2);
  k2 = Math.max(k2, m2);
  m2 = b2.getChildren();
  f2 = 0;
  let n2, p2;
  for (let l2 = e2; l2 <= k2; l2++) {
    var t3 = m2[l2];
    u$8.DEPRECATED_$isGridRowNode(t3) || z$4(24);
    var y2 = a2[f2];
    u$8.DEPRECATED_$isGridRowNode(y2) || z$4(24);
    t3 = t3.getChildren();
    y2 = y2.getChildren();
    let G2 = 0;
    for (let v3 = c2; v3 <= h2; v3++) {
      let w2 = t3[v3];
      u$8.DEPRECATED_$isGridCellNode(w2) || z$4(25);
      let H3 = y2[G2];
      u$8.DEPRECATED_$isGridCellNode(H3) || z$4(25);
      l2 === e2 && v3 === c2 ? n2 = w2.getKey() : l2 === k2 && v3 === h2 && (p2 = w2.getKey());
      let M2 = w2.getChildren();
      H3.getChildren().forEach((x3) => {
        u$8.$isTextNode(x3) && u$8.$createParagraphNode().append(x3);
        w2.append(x3);
      });
      M2.forEach((x3) => x3.remove());
      G2++;
    }
    f2++;
  }
  n2 && p2 && (a2 = u$8.DEPRECATED_$createGridSelection(), a2.set(b2.getKey(), n2, p2), u$8.$setSelection(a2), g2.dispatchCommand(u$8.SELECTION_CHANGE_COMMAND, void 0));
}
function I$4(a2, b2, c2, g2 = []) {
  let e2 = null != b2 ? c2.isSelected(b2) : true, h2 = u$8.$isElementNode(c2) && c2.excludeFromCopy("html");
  var f2 = c2;
  if (null !== b2) {
    var k2 = q$7.$cloneWithProperties(c2);
    f2 = k2 = u$8.$isTextNode(k2) && null != b2 ? q$7.$sliceSelectedTextNodeContent(b2, k2) : k2;
  }
  let m2 = u$8.$isElementNode(f2) ? f2.getChildren() : [];
  var n2 = f2;
  k2 = n2.exportJSON();
  var p2 = n2.constructor;
  k2.type !== p2.getType() && z$4(58, p2.name);
  let t3 = k2.children;
  u$8.$isElementNode(n2) && (Array.isArray(t3) || z$4(59, p2.name));
  u$8.$isTextNode(f2) && (f2 = f2.__text, 0 < f2.length ? k2.text = f2 : e2 = false);
  for (f2 = 0; f2 < m2.length; f2++)
    n2 = m2[f2], p2 = I$4(a2, b2, n2, k2.children), !e2 && u$8.$isElementNode(c2) && p2 && c2.extractWithChild(n2, b2, "clone") && (e2 = true);
  if (e2 && !h2)
    g2.push(k2);
  else if (Array.isArray(k2.children))
    for (a2 = 0; a2 < k2.children.length; a2++)
      g2.push(k2.children[a2]);
  return e2;
}
function D$3(a2, b2) {
  let c2 = [], g2 = u$8.$getRoot().getChildren();
  for (let e2 = 0; e2 < g2.length; e2++)
    I$4(a2, b2, g2[e2], c2);
  return { namespace: a2._config.namespace, nodes: c2 };
}
function J$3(a2) {
  let b2 = [];
  for (let c2 = 0; c2 < a2.length; c2++) {
    let g2 = u$8.$parseSerializedNode(a2[c2]);
    u$8.$isTextNode(g2) && q$7.$addNodeStyle(g2);
    b2.push(g2);
  }
  return b2;
}
let K$3 = null;
function L$3(a2, b2) {
  var c2 = A$1 ? (a2._window || window).getSelection() : null;
  if (!c2)
    return false;
  var g2 = c2.anchorNode;
  c2 = c2.focusNode;
  if (null !== g2 && null !== c2 && !u$8.isSelectionWithinEditor(a2, g2, c2))
    return false;
  b2.preventDefault();
  b2 = b2.clipboardData;
  g2 = u$8.$getSelection();
  if (null === b2 || null === g2)
    return false;
  c2 = B$5(a2);
  a2 = C$4(a2);
  let e2 = "";
  null !== g2 && (e2 = g2.getTextContent());
  null !== c2 && b2.setData("text/html", c2);
  null !== a2 && b2.setData("application/x-lexical-editor", a2);
  b2.setData("text/plain", e2);
  return true;
}
LexicalClipboard_prod.$generateJSONFromSelectedNodes = D$3;
LexicalClipboard_prod.$generateNodesFromSerializedNodes = J$3;
LexicalClipboard_prod.$getHtmlContent = B$5;
LexicalClipboard_prod.$getLexicalContent = C$4;
LexicalClipboard_prod.$insertDataTransferForPlainText = function(a2, b2) {
  a2 = a2.getData("text/plain") || a2.getData("text/uri-list");
  null != a2 && b2.insertRawText(a2);
};
LexicalClipboard_prod.$insertDataTransferForRichText = function(a2, b2, c2) {
  var g2 = a2.getData("application/x-lexical-editor");
  if (g2)
    try {
      let h2 = JSON.parse(g2);
      if (h2.namespace === c2._config.namespace && Array.isArray(h2.nodes)) {
        let f2 = J$3(h2.nodes);
        return E$3(c2, f2, b2);
      }
    } catch (h2) {
    }
  if (g2 = a2.getData("text/html"))
    try {
      var e2 = new DOMParser().parseFromString(g2, "text/html");
      let h2 = d$4.$generateNodesFromDOM(c2, e2);
      return E$3(c2, h2, b2);
    } catch (h2) {
    }
  a2 = a2.getData("text/plain") || a2.getData("text/uri-list");
  if (null != a2)
    if (u$8.$isRangeSelection(b2))
      for (a2 = a2.split(/(\r?\n|\t)/), "" === a2[a2.length - 1] && a2.pop(), c2 = 0; c2 < a2.length; c2++)
        e2 = a2[c2], "\n" === e2 || "\r\n" === e2 ? b2.insertParagraph() : "	" === e2 ? b2.insertNodes([u$8.$createTabNode()]) : b2.insertText(e2);
    else
      b2.insertRawText(a2);
};
LexicalClipboard_prod.$insertGeneratedNodes = E$3;
LexicalClipboard_prod.copyToClipboard = async function(a2, b2) {
  if (null !== K$3)
    return false;
  if (null !== b2)
    return new Promise((f2) => {
      a2.update(() => {
        f2(L$3(a2, b2));
      });
    });
  var c2 = a2.getRootElement();
  let g2 = null == a2._window ? window.document : a2._window.document, e2 = A$1 ? (a2._window || window).getSelection() : null;
  if (null === c2 || null === e2)
    return false;
  let h2 = g2.createElement("span");
  h2.style.cssText = "position: fixed; top: -1000px;";
  h2.append(g2.createTextNode("#"));
  c2.append(h2);
  c2 = new Range();
  c2.setStart(h2, 0);
  c2.setEnd(h2, 1);
  e2.removeAllRanges();
  e2.addRange(c2);
  return new Promise((f2) => {
    let k2 = a2.registerCommand(u$8.COPY_COMMAND, (m2) => {
      r$9.objectKlassEquals(m2, ClipboardEvent) && (k2(), null !== K$3 && (window.clearTimeout(K$3), K$3 = null), f2(L$3(a2, m2)));
      return true;
    }, u$8.COMMAND_PRIORITY_CRITICAL);
    K$3 = window.setTimeout(() => {
      k2();
      K$3 = null;
      f2(false);
    }, 50);
    g2.execCommand("copy");
    h2.remove();
  });
};
const LexicalClipboard = LexicalClipboard_prod;
var LexicalClipboard_1 = LexicalClipboard;
var c$3 = LexicalClipboard_1, g$9 = LexicalSelection_1, h$5 = LexicalUtils_1, k$7 = Lexical_1;
function l$4(b2, a2) {
  return "undefined" !== typeof document.caretRangeFromPoint ? (b2 = document.caretRangeFromPoint(b2, a2), null === b2 ? null : { node: b2.startContainer, offset: b2.startOffset }) : "undefined" !== document.caretPositionFromPoint ? (b2 = document.caretPositionFromPoint(b2, a2), null === b2 ? null : { node: b2.offsetNode, offset: b2.offset }) : null;
}
let n$8 = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement, p$7 = n$8 && "documentMode" in document ? document.documentMode : null;
let q$6 = n$8 && "InputEvent" in window && !p$7 ? "getTargetRanges" in new window.InputEvent("input") : false, r$8 = n$8 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), t$7 = n$8 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
let u$7 = n$8 && /^(?=.*Chrome).*/i.test(navigator.userAgent), v$5 = n$8 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !u$7, w$4 = k$7.createCommand("DRAG_DROP_PASTE_FILE");
let x$3 = class x extends k$7.ElementNode {
  static getType() {
    return "quote";
  }
  static clone(b2) {
    return new x(b2.__key);
  }
  constructor(b2) {
    super(b2);
  }
  createDOM(b2) {
    let a2 = document.createElement("blockquote");
    h$5.addClassNamesToElement(a2, b2.theme.quote);
    return a2;
  }
  updateDOM() {
    return false;
  }
  static importDOM() {
    return { blockquote: () => ({ conversion: y$4, priority: 0 }) };
  }
  exportDOM(b2) {
    ({ element: b2 } = super.exportDOM(b2));
    if (b2 && h$5.isHTMLElement(b2)) {
      this.isEmpty() && b2.append(document.createElement("br"));
      var a2 = this.getFormatType();
      b2.style.textAlign = a2;
      if (a2 = this.getDirection())
        b2.dir = a2;
    }
    return { element: b2 };
  }
  static importJSON(b2) {
    let a2 = z$3();
    a2.setFormat(b2.format);
    a2.setIndent(b2.indent);
    a2.setDirection(b2.direction);
    return a2;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "quote" };
  }
  insertNewAfter(b2, a2) {
    b2 = k$7.$createParagraphNode();
    let d2 = this.getDirection();
    b2.setDirection(d2);
    this.insertAfter(b2, a2);
    return b2;
  }
  collapseAtStart() {
    let b2 = k$7.$createParagraphNode();
    this.getChildren().forEach((a2) => b2.append(a2));
    this.replace(b2);
    return true;
  }
};
function z$3() {
  return k$7.$applyNodeReplacement(new x$3());
}
let B$4 = class B extends k$7.ElementNode {
  static getType() {
    return "heading";
  }
  static clone(b2) {
    return new B(b2.__tag, b2.__key);
  }
  constructor(b2, a2) {
    super(a2);
    this.__tag = b2;
  }
  getTag() {
    return this.__tag;
  }
  createDOM(b2) {
    let a2 = this.__tag, d2 = document.createElement(a2);
    b2 = b2.theme.heading;
    void 0 !== b2 && h$5.addClassNamesToElement(d2, b2[a2]);
    return d2;
  }
  updateDOM() {
    return false;
  }
  static importDOM() {
    return { h1: () => ({ conversion: C$3, priority: 0 }), h2: () => ({ conversion: C$3, priority: 0 }), h3: () => ({ conversion: C$3, priority: 0 }), h4: () => ({ conversion: C$3, priority: 0 }), h5: () => ({
      conversion: C$3,
      priority: 0
    }), h6: () => ({ conversion: C$3, priority: 0 }), p: (b2) => {
      b2 = b2.firstChild;
      return null !== b2 && D$2(b2) ? { conversion: () => ({ node: null }), priority: 3 } : null;
    }, span: (b2) => D$2(b2) ? { conversion: () => ({ node: E$2("h1") }), priority: 3 } : null };
  }
  exportDOM(b2) {
    ({ element: b2 } = super.exportDOM(b2));
    if (b2 && h$5.isHTMLElement(b2)) {
      this.isEmpty() && b2.append(document.createElement("br"));
      var a2 = this.getFormatType();
      b2.style.textAlign = a2;
      if (a2 = this.getDirection())
        b2.dir = a2;
    }
    return { element: b2 };
  }
  static importJSON(b2) {
    let a2 = E$2(b2.tag);
    a2.setFormat(b2.format);
    a2.setIndent(b2.indent);
    a2.setDirection(b2.direction);
    return a2;
  }
  exportJSON() {
    return { ...super.exportJSON(), tag: this.getTag(), type: "heading", version: 1 };
  }
  insertNewAfter(b2, a2 = true) {
    let d2 = b2 ? b2.anchor.offset : 0, e2 = d2 !== this.getTextContentSize() && b2 ? E$2(this.getTag()) : k$7.$createParagraphNode(), f2 = this.getDirection();
    e2.setDirection(f2);
    this.insertAfter(e2, a2);
    0 === d2 && !this.isEmpty() && b2 && (b2 = k$7.$createParagraphNode(), b2.select(), this.replace(b2, true));
    return e2;
  }
  collapseAtStart() {
    let b2 = this.isEmpty() ? k$7.$createParagraphNode() : E$2(this.getTag());
    this.getChildren().forEach((a2) => b2.append(a2));
    this.replace(b2);
    return true;
  }
  extractWithChild() {
    return true;
  }
};
function D$2(b2) {
  return "span" === b2.nodeName.toLowerCase() ? "26pt" === b2.style.fontSize : false;
}
function C$3(b2) {
  let a2 = b2.nodeName.toLowerCase(), d2 = null;
  if ("h1" === a2 || "h2" === a2 || "h3" === a2 || "h4" === a2 || "h5" === a2 || "h6" === a2)
    d2 = E$2(a2), null !== b2.style && d2.setFormat(b2.style.textAlign);
  return { node: d2 };
}
function y$4(b2) {
  let a2 = z$3();
  null !== b2.style && a2.setFormat(b2.style.textAlign);
  return { node: a2 };
}
function E$2(b2) {
  return k$7.$applyNodeReplacement(new B$4(b2));
}
function F$2(b2, a2) {
  b2.preventDefault();
  a2.update(() => {
    let d2 = k$7.$getSelection(), e2 = b2 instanceof InputEvent || b2 instanceof KeyboardEvent ? null : b2.clipboardData;
    null != e2 && k$7.$INTERNAL_isPointSelection(d2) && c$3.$insertDataTransferForRichText(e2, d2, a2);
  }, { tag: "paste" });
}
async function G$3(b2, a2) {
  await c$3.copyToClipboard(a2, h$5.objectKlassEquals(b2, ClipboardEvent) ? b2 : null);
  a2.update(() => {
    let d2 = k$7.$getSelection();
    k$7.$isRangeSelection(d2) ? d2.removeText() : k$7.$isNodeSelection(d2) && d2.getNodes().forEach((e2) => e2.remove());
  });
}
function H$3(b2) {
  let a2 = null;
  b2 instanceof DragEvent ? a2 = b2.dataTransfer : b2 instanceof ClipboardEvent && (a2 = b2.clipboardData);
  if (null === a2)
    return [false, [], false];
  var d2 = a2.types;
  b2 = d2.includes("Files");
  d2 = d2.includes("text/html") || d2.includes("text/plain");
  return [b2, Array.from(a2.files), d2];
}
function I$3(b2) {
  var a2 = k$7.$getSelection();
  if (!k$7.$isRangeSelection(a2))
    return false;
  let d2 = /* @__PURE__ */ new Set();
  a2 = a2.getNodes();
  for (let m2 = 0; m2 < a2.length; m2++) {
    var e2 = a2[m2], f2 = e2.getKey();
    d2.has(f2) || (e2 = h$5.$getNearestBlockElementAncestorOrThrow(e2), f2 = e2.getKey(), e2.canIndent() && !d2.has(f2) && (d2.add(f2), b2(e2)));
  }
  return 0 < d2.size;
}
function J$2(b2) {
  b2 = k$7.$getNearestNodeFromDOMNode(b2);
  return k$7.$isDecoratorNode(b2);
}
LexicalRichText_prod.$createHeadingNode = E$2;
LexicalRichText_prod.$createQuoteNode = z$3;
LexicalRichText_prod.$isHeadingNode = function(b2) {
  return b2 instanceof B$4;
};
LexicalRichText_prod.$isQuoteNode = function(b2) {
  return b2 instanceof x$3;
};
LexicalRichText_prod.DRAG_DROP_PASTE = w$4;
LexicalRichText_prod.HeadingNode = B$4;
LexicalRichText_prod.QuoteNode = x$3;
LexicalRichText_prod.eventFiles = H$3;
LexicalRichText_prod.registerRichText = function(b2) {
  return h$5.mergeRegister(
    b2.registerCommand(k$7.CLICK_COMMAND, () => {
      const a2 = k$7.$getSelection();
      return k$7.$isNodeSelection(a2) ? (a2.clear(), true) : false;
    }, 0),
    b2.registerCommand(k$7.DELETE_CHARACTER_COMMAND, (a2) => {
      const d2 = k$7.$getSelection();
      if (!k$7.$isRangeSelection(d2))
        return false;
      d2.deleteCharacter(a2);
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.DELETE_WORD_COMMAND, (a2) => {
      const d2 = k$7.$getSelection();
      if (!k$7.$isRangeSelection(d2))
        return false;
      d2.deleteWord(a2);
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.DELETE_LINE_COMMAND, (a2) => {
      const d2 = k$7.$getSelection();
      if (!k$7.$isRangeSelection(d2))
        return false;
      d2.deleteLine(a2);
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.CONTROLLED_TEXT_INSERTION_COMMAND, (a2) => {
      const d2 = k$7.$getSelection();
      if ("string" === typeof a2)
        k$7.$INTERNAL_isPointSelection(d2) && d2.insertText(a2);
      else {
        if (!k$7.$INTERNAL_isPointSelection(d2))
          return false;
        const e2 = a2.dataTransfer;
        null != e2 ? c$3.$insertDataTransferForRichText(e2, d2, b2) : k$7.$isRangeSelection(d2) && (a2 = a2.data) && d2.insertText(a2);
      }
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.REMOVE_TEXT_COMMAND, () => {
      const a2 = k$7.$getSelection();
      if (!k$7.$isRangeSelection(a2))
        return false;
      a2.removeText();
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.FORMAT_TEXT_COMMAND, (a2) => {
      const d2 = k$7.$getSelection();
      if (!k$7.$isRangeSelection(d2))
        return false;
      d2.formatText(a2);
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.FORMAT_ELEMENT_COMMAND, (a2) => {
      var d2 = k$7.$getSelection();
      if (!k$7.$isRangeSelection(d2) && !k$7.$isNodeSelection(d2))
        return false;
      d2 = d2.getNodes();
      for (const e2 of d2)
        d2 = h$5.$findMatchingParent(
          e2,
          (f2) => k$7.$isElementNode(f2) && !f2.isInline()
        ), null !== d2 && d2.setFormat(a2);
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.INSERT_LINE_BREAK_COMMAND, (a2) => {
      const d2 = k$7.$getSelection();
      if (!k$7.$isRangeSelection(d2))
        return false;
      d2.insertLineBreak(a2);
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.INSERT_PARAGRAPH_COMMAND, () => {
      const a2 = k$7.$getSelection();
      if (!k$7.$isRangeSelection(a2))
        return false;
      a2.insertParagraph();
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.INSERT_TAB_COMMAND, () => {
      k$7.$insertNodes([k$7.$createTabNode()]);
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.INDENT_CONTENT_COMMAND, () => I$3((a2) => {
      const d2 = a2.getIndent();
      a2.setIndent(d2 + 1);
    }), k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.OUTDENT_CONTENT_COMMAND, () => I$3((a2) => {
      const d2 = a2.getIndent();
      0 < d2 && a2.setIndent(d2 - 1);
    }), k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.KEY_ARROW_UP_COMMAND, (a2) => {
      var d2 = k$7.$getSelection();
      if (k$7.$isNodeSelection(d2) && !J$2(a2.target)) {
        if (a2 = d2.getNodes(), 0 < a2.length)
          return a2[0].selectPrevious(), true;
      } else if (k$7.$isRangeSelection(d2) && (d2 = k$7.$getAdjacentNode(
        d2.focus,
        true
      ), !a2.shiftKey && k$7.$isDecoratorNode(d2) && !d2.isIsolated() && !d2.isInline()))
        return d2.selectPrevious(), a2.preventDefault(), true;
      return false;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.KEY_ARROW_DOWN_COMMAND, (a2) => {
      var d2 = k$7.$getSelection();
      if (k$7.$isNodeSelection(d2)) {
        if (a2 = d2.getNodes(), 0 < a2.length)
          return a2[0].selectNext(0, 0), true;
      } else if (k$7.$isRangeSelection(d2)) {
        let e2 = d2.focus;
        if ("root" === e2.key && e2.offset === k$7.$getRoot().getChildrenSize())
          return a2.preventDefault(), true;
        d2 = k$7.$getAdjacentNode(d2.focus, false);
        if (!a2.shiftKey && k$7.$isDecoratorNode(d2) && !d2.isIsolated() && !d2.isInline())
          return d2.selectNext(), a2.preventDefault(), true;
      }
      return false;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.KEY_ARROW_LEFT_COMMAND, (a2) => {
      const d2 = k$7.$getSelection();
      if (k$7.$isNodeSelection(d2)) {
        var e2 = d2.getNodes();
        if (0 < e2.length)
          return a2.preventDefault(), e2[0].selectPrevious(), true;
      }
      return k$7.$isRangeSelection(d2) ? g$9.$shouldOverrideDefaultCharacterSelection(d2, true) ? (e2 = a2.shiftKey, a2.preventDefault(), g$9.$moveCharacter(d2, e2, true), true) : false : false;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(
      k$7.KEY_ARROW_RIGHT_COMMAND,
      (a2) => {
        const d2 = k$7.$getSelection();
        if (k$7.$isNodeSelection(d2) && !J$2(a2.target)) {
          var e2 = d2.getNodes();
          if (0 < e2.length)
            return a2.preventDefault(), e2[0].selectNext(0, 0), true;
        }
        if (!k$7.$isRangeSelection(d2))
          return false;
        e2 = a2.shiftKey;
        return g$9.$shouldOverrideDefaultCharacterSelection(d2, false) ? (a2.preventDefault(), g$9.$moveCharacter(d2, e2, false), true) : false;
      },
      k$7.COMMAND_PRIORITY_EDITOR
    ),
    b2.registerCommand(k$7.KEY_BACKSPACE_COMMAND, (a2) => {
      if (J$2(a2.target))
        return false;
      const d2 = k$7.$getSelection();
      if (!k$7.$isRangeSelection(d2))
        return false;
      a2.preventDefault();
      ({ anchor: a2 } = d2);
      const e2 = a2.getNode();
      return d2.isCollapsed() && 0 === a2.offset && !k$7.$isRootNode(e2) && 0 < h$5.$getNearestBlockElementAncestorOrThrow(e2).getIndent() ? b2.dispatchCommand(k$7.OUTDENT_CONTENT_COMMAND, void 0) : b2.dispatchCommand(k$7.DELETE_CHARACTER_COMMAND, true);
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.KEY_DELETE_COMMAND, (a2) => {
      if (J$2(a2.target))
        return false;
      const d2 = k$7.$getSelection();
      if (!k$7.$isRangeSelection(d2))
        return false;
      a2.preventDefault();
      return b2.dispatchCommand(k$7.DELETE_CHARACTER_COMMAND, false);
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(
      k$7.KEY_ENTER_COMMAND,
      (a2) => {
        const d2 = k$7.$getSelection();
        if (!k$7.$isRangeSelection(d2))
          return false;
        if (null !== a2) {
          if ((t$7 || r$8 || v$5) && q$6)
            return false;
          a2.preventDefault();
          if (a2.shiftKey)
            return b2.dispatchCommand(k$7.INSERT_LINE_BREAK_COMMAND, false);
        }
        return b2.dispatchCommand(k$7.INSERT_PARAGRAPH_COMMAND, void 0);
      },
      k$7.COMMAND_PRIORITY_EDITOR
    ),
    b2.registerCommand(k$7.KEY_ESCAPE_COMMAND, () => {
      const a2 = k$7.$getSelection();
      if (!k$7.$isRangeSelection(a2))
        return false;
      b2.blur();
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.DROP_COMMAND, (a2) => {
      const [, d2] = H$3(a2);
      if (0 < d2.length) {
        var e2 = l$4(a2.clientX, a2.clientY);
        if (null !== e2) {
          const { offset: m2, node: K2 } = e2;
          var f2 = k$7.$getNearestNodeFromDOMNode(K2);
          if (null !== f2) {
            e2 = k$7.$createRangeSelection();
            if (k$7.$isTextNode(f2))
              e2.anchor.set(f2.getKey(), m2, "text"), e2.focus.set(f2.getKey(), m2, "text");
            else {
              const A2 = f2.getParentOrThrow().getKey();
              f2 = f2.getIndexWithinParent() + 1;
              e2.anchor.set(A2, f2, "element");
              e2.focus.set(A2, f2, "element");
            }
            e2 = k$7.$normalizeSelection__EXPERIMENTAL(e2);
            k$7.$setSelection(e2);
          }
          b2.dispatchCommand(w$4, d2);
        }
        a2.preventDefault();
        return true;
      }
      a2 = k$7.$getSelection();
      return k$7.$isRangeSelection(a2) ? true : false;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.DRAGSTART_COMMAND, (a2) => {
      [a2] = H$3(a2);
      const d2 = k$7.$getSelection();
      return a2 && !k$7.$isRangeSelection(d2) ? false : true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.DRAGOVER_COMMAND, (a2) => {
      var [d2] = H$3(a2);
      const e2 = k$7.$getSelection();
      if (d2 && !k$7.$isRangeSelection(e2))
        return false;
      d2 = l$4(a2.clientX, a2.clientY);
      null !== d2 && (d2 = k$7.$getNearestNodeFromDOMNode(d2.node), k$7.$isDecoratorNode(d2) && a2.preventDefault());
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.SELECT_ALL_COMMAND, () => {
      k$7.$selectAll();
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.COPY_COMMAND, (a2) => {
      c$3.copyToClipboard(b2, h$5.objectKlassEquals(a2, ClipboardEvent) ? a2 : null);
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.CUT_COMMAND, (a2) => {
      G$3(a2, b2);
      return true;
    }, k$7.COMMAND_PRIORITY_EDITOR),
    b2.registerCommand(k$7.PASTE_COMMAND, (a2) => {
      const [, d2, e2] = H$3(a2);
      if (0 < d2.length && !e2)
        return b2.dispatchCommand(w$4, d2), true;
      if (k$7.isSelectionCapturedInDecoratorInput(a2.target))
        return false;
      const f2 = k$7.$getSelection();
      return k$7.$INTERNAL_isPointSelection(f2) ? (F$2(a2, b2), true) : false;
    }, k$7.COMMAND_PRIORITY_EDITOR)
  );
};
const LexicalRichText = LexicalRichText_prod;
var LexicalRichText_1 = LexicalRichText;
const own$2 = {}.hasOwnProperty;
function zwitch(key, options) {
  const settings = options || {};
  function one2(value, ...parameters) {
    let fn = one2.invalid;
    const handlers = one2.handlers;
    if (value && own$2.call(value, key)) {
      const id2 = String(value[key]);
      fn = own$2.call(handlers, id2) ? handlers[id2] : one2.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}
function configure$1(base, extension2) {
  let index2 = -1;
  let key;
  if (extension2.extensions) {
    while (++index2 < extension2.extensions.length) {
      configure$1(base, extension2.extensions[index2]);
    }
  }
  for (key in extension2) {
    if (key === "extensions")
      ;
    else if (key === "unsafe" || key === "join") {
      base[key] = [...base[key] || [], ...extension2[key] || []];
    } else if (key === "handlers") {
      base[key] = Object.assign(base[key], extension2[key] || {});
    } else {
      base.options[key] = extension2[key];
    }
  }
  return base;
}
function blockquote(node2, _, state, info) {
  const exit2 = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map$1
  );
  exit2();
  return value;
}
function map$1(line, _, blank) {
  return ">" + (blank ? "" : " ") + line;
}
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list2, none) {
  if (typeof list2 === "string") {
    list2 = [list2];
  }
  if (!list2 || list2.length === 0) {
    return none;
  }
  let index2 = -1;
  while (++index2 < list2.length) {
    if (stack.includes(list2[index2])) {
      return true;
    }
  }
  return false;
}
function hardBreak(_, _1, state, info) {
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}
function longestStreak(value, substring) {
  const source = String(value);
  let index2 = source.indexOf(substring);
  let expected = index2;
  let count = 0;
  let max = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index2 !== -1) {
    if (index2 === expected) {
      if (++count > max) {
        max = count;
      }
    } else {
      count = 1;
    }
    expected = index2 + substring.length;
    index2 = source.indexOf(substring, expected);
  }
  return max;
}
function formatCodeAsIndented(node2, state) {
  return Boolean(
    !state.options.fences && node2.value && // If there’s no info…
    !node2.lang && // And there’s a non-whitespace character…
    /[^ \r\n]/.test(node2.value) && // And the value doesn’t start or end in a blank…
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
  );
}
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}
function code$1(node2, _, state, info) {
  const marker = checkFence(state);
  const raw = node2.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit3 = state.enter("codeIndented");
    const value2 = state.indentLines(raw, map);
    exit3();
    return value2;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
  const exit2 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node2.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node2.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw) {
    value += tracker.move(raw + "\n");
  }
  value += tracker.move(sequence);
  exit2();
  return value;
}
function map(line, _, blank) {
  return (blank ? "" : "    ") + line;
}
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}
function definition$1(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If there’s no url, or…
    !node2.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit2();
  return value;
}
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}
emphasis.peek = emphasisPeek;
function emphasis(node2, _, state, info) {
  const marker = checkEmphasis(state);
  const exit2 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker);
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker);
  exit2();
  return value;
}
function emphasisPeek(_, _1, state) {
  return state.options.emphasis || "*";
}
const convert = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return ok;
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all2);
  function all2(node2) {
    let key;
    for (key in check) {
      if (node2[key] !== check[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function ok() {
  return true;
}
function color$1(d2) {
  return d2;
}
const CONTINUE$1 = true;
const EXIT$1 = false;
const SKIP$1 = "skip";
const visitParents = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    const is = convert(test);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node2, index2, parents) {
      const value = node2 && typeof node2 === "object" ? node2 : {};
      if (typeof value.type === "string") {
        const name = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color$1(node2.type + (name ? "<" + name + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = [];
        let subresult;
        let offset;
        let grandparents;
        if (!test || is(node2, index2, parents[parents.length - 1] || null)) {
          result = toResult$1(visitor(node2, parents));
          if (result[0] === EXIT$1) {
            return result;
          }
        }
        if (node2.children && result[0] !== SKIP$1) {
          offset = (reverse ? node2.children.length : -1) + step;
          grandparents = parents.concat(node2);
          while (offset > -1 && offset < node2.children.length) {
            subresult = factory(node2.children[offset], offset, grandparents)();
            if (subresult[0] === EXIT$1) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
        return result;
      }
    }
  }
);
function toResult$1(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE$1, value];
  }
  return [value];
}
const visit$1 = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      return visitor(
        node2,
        parent ? parent.children.indexOf(node2) : null,
        parent
      );
    }
  }
);
const emptyOptions = {};
function toString(value, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one(values[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit$1(node2, (node3) => {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT$1;
    }
  });
  return Boolean(
    (!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak)
  );
}
function heading(node2, _, state, info) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node2, state)) {
    const exit3 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit3();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size…
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit2 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node2, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit2();
  return value;
}
html.peek = htmlPeek;
function html(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}
image.peek = imagePeek;
function image(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function imagePeek() {
  return "!";
}
imageReference.peek = imageReferencePeek;
function imageReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit2 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}
function patternCompile(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp(
      (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
      "g"
    );
  }
  return pattern._compiled;
}
inlineCode.peek = inlineCodePeek;
function inlineCode(node2, _, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    const expression = patternCompile(pattern);
    let match;
    if (!pattern.atBreak)
      continue;
    while (match = expression.exec(value)) {
      let position2 = match.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}
function formatLinkAsAutolink(node2, state) {
  const raw = toString(node2);
  return Boolean(
    !state.options.resourceLink && // If there’s a url…
    node2.url && // And there’s a no title…
    !node2.title && // And the content of `node` is a single text node…
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content…
    (raw === node2.url || "mailto:" + raw === node2.url) && // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work), space, or angle brackets…
    !/[\0- <>\u007F]/.test(node2.url)
  );
}
link.peek = linkPeek;
function link(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit2;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit2 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit2();
    state.stack = stack;
    return value2;
  }
  exit2 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function linkPeek(node2, _, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}
linkReference.peek = linkReferencePeek;
function linkReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit2 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text2 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text2 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type === "full" || !text2 || text2 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}
function checkBulletOrderedOther(state) {
  const bulletOrdered = checkBulletOrdered(state);
  const bulletOrderedOther = state.options.bulletOrderedOther;
  if (!bulletOrderedOther) {
    return bulletOrdered === "." ? ")" : ".";
  }
  if (bulletOrderedOther !== "." && bulletOrderedOther !== ")") {
    throw new Error(
      "Cannot serialize items with `" + bulletOrderedOther + "` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOrderedOther === bulletOrdered) {
    throw new Error(
      "Expected `bulletOrdered` (`" + bulletOrdered + "`) and `bulletOrderedOther` (`" + bulletOrderedOther + "`) to be different"
    );
  }
  return bulletOrderedOther;
}
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}
function list$1(node2, parent, state, info) {
  const exit2 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? checkBulletOrderedOther(state) : checkBulletOther(state);
  const bulletLastUsed = state.bulletLastUsed;
  let useDifferentMarker = false;
  if (parent && // Explicit `other` set.
  (node2.ordered ? state.options.bulletOrderedOther : state.options.bulletOther) && bulletLastUsed && bullet === bulletLastUsed) {
    useDifferentMarker = true;
  }
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index2 = -1;
      while (++index2 < node2.children.length) {
        const item = node2.children[index2];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node2, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit2();
  return value;
}
function checkListItemIndent(state) {
  const style = state.options.listItemIndent || "tab";
  if (style === 1 || style === "1") {
    return "one";
  }
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style;
}
function listItem(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size - bullet.length));
  tracker.shift(size);
  const exit2 = state.enter("listItem");
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map2
  );
  exit2();
  return value;
  function map2(line, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
  }
}
function paragraph(node2, _, state, info) {
  const exit2 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node2, info);
  subexit();
  exit2();
  return value;
}
const phrasing = (
  /** @type {AssertPredicatePhrasing} */
  convert([
    "break",
    "delete",
    "emphasis",
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    "link",
    "linkReference",
    "strong",
    "text"
  ])
);
function root(node2, _, state, info) {
  const hasPhrasing = node2.children.some((d2) => phrasing(d2));
  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return fn.call(state, node2, info);
}
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}
strong.peek = strongPeek;
function strong(node2, _, state, info) {
  const marker = checkStrong(state);
  const exit2 = state.enter("strong");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker + marker);
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker + marker);
  exit2();
  return value;
}
function strongPeek(_, _1, state) {
  return state.options.strong || "*";
}
function text$2(node2, _, state, info) {
  return state.safe(node2.value, info);
}
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}
function thematicBreak$1(_, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}
const handle = {
  blockquote,
  break: hardBreak,
  code: code$1,
  definition: definition$1,
  emphasis,
  hardBreak,
  heading,
  html,
  image,
  imageReference,
  inlineCode,
  link,
  linkReference,
  list: list$1,
  listItem,
  paragraph,
  root,
  strong,
  text: text$2,
  thematicBreak: thematicBreak$1
};
const join = [joinDefaults];
function joinDefaults(left, right, parent, state) {
  if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
    return false;
  }
  if (left.type === "list" && left.type === right.type && Boolean(left.ordered) === Boolean(right.ordered) && !(left.ordered ? state.options.bulletOrderedOther : state.options.bulletOther)) {
    return false;
  }
  if ("spread" in parent && typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && // Two paragraphs.
    (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
    right.type === "heading" && formatHeadingAsSetext(right, state))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}
const fullPhrasingSpans = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
const unsafe = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
  { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A plus sign could start a list item.
  { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
  // A dot could start a list item.
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: true, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: true, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: true, character: "~" }
];
const element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const char = element.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}
function decodeNumericCharacterReference(value, base) {
  const code2 = Number.parseInt(value, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
    code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
    code2 > 55295 && code2 < 57344 || // Noncharacters.
    code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || // Out of range
    code2 > 1114111
  ) {
    return "�";
  }
  return String.fromCharCode(code2);
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}
function association(node2) {
  if (node2.label || !node2.identifier) {
    return node2.label || "";
  }
  return decodeString(node2.identifier);
}
function containerPhrasing(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  let before = info.before;
  indexStack.push(-1);
  let tracker = state.createTracker(info);
  while (++index2 < children.length) {
    const child = children[index2];
    let after;
    indexStack[indexStack.length - 1] = index2;
    if (index2 + 1 < children.length) {
      let handle2 = state.handle.handlers[children[index2 + 1].type];
      if (handle2 && handle2.peek)
        handle2 = handle2.peek;
      after = handle2 ? handle2(children[index2 + 1], parent, state, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after = info.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        " "
      );
      before = " ";
      tracker = state.createTracker(info);
      tracker.move(results.join(""));
    }
    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          ...tracker.current(),
          before,
          after
        })
      )
    );
    before = results[results.length - 1].slice(-1);
  }
  indexStack.pop();
  return results.join("");
}
function containerFlow$1(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const tracker = state.createTracker(info);
  const results = [];
  let index2 = -1;
  indexStack.push(-1);
  while (++index2 < children.length) {
    const child = children[index2];
    indexStack[indexStack.length - 1] = index2;
    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          before: "\n",
          after: "\n",
          ...tracker.current()
        })
      )
    );
    if (child.type !== "list") {
      state.bulletLastUsed = void 0;
    }
    if (index2 < children.length - 1) {
      results.push(
        tracker.move(between(child, children[index2 + 1], parent, state))
      );
    }
  }
  indexStack.pop();
  return results.join("");
}
function between(left, right, parent, state) {
  let index2 = state.join.length;
  while (index2--) {
    const result = state.join[index2](left, right, parent, state);
    if (result === true || result === 1) {
      break;
    }
    if (typeof result === "number") {
      return "\n".repeat(1 + result);
    }
    if (result === false) {
      return "\n\n<!---->\n\n";
    }
  }
  return "\n\n";
}
const eol = /\r?\n|\r/g;
function indentLines(value, map2) {
  const result = [];
  let start2 = 0;
  let line = 0;
  let match;
  while (match = eol.exec(value)) {
    one2(value.slice(start2, match.index));
    result.push(match[0]);
    start2 = match.index + match[0].length;
    line++;
  }
  one2(value.slice(start2));
  return result.join("");
  function one2(value2) {
    result.push(map2(value2, line, !value2));
  }
}
function safe(state, input, config) {
  const value = (config.before || "") + (input || "") + (config.after || "");
  const positions = [];
  const result = [];
  const infos = {};
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    if (!patternInScope(state.stack, pattern)) {
      continue;
    }
    const expression = patternCompile(pattern);
    let match;
    while (match = expression.exec(value)) {
      const before = "before" in pattern || Boolean(pattern.atBreak);
      const after = "after" in pattern;
      const position2 = match.index + (before ? match[1].length : 0);
      if (positions.includes(position2)) {
        if (infos[position2].before && !before) {
          infos[position2].before = false;
        }
        if (infos[position2].after && !after) {
          infos[position2].after = false;
        }
      } else {
        positions.push(position2);
        infos[position2] = { before, after };
      }
    }
  }
  positions.sort(numerical);
  let start2 = config.before ? config.before.length : 0;
  const end = value.length - (config.after ? config.after.length : 0);
  index2 = -1;
  while (++index2 < positions.length) {
    const position2 = positions[index2];
    if (position2 < start2 || position2 >= end) {
      continue;
    }
    if (position2 + 1 < end && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index2 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
      continue;
    }
    if (start2 !== position2) {
      result.push(escapeBackslashes(value.slice(start2, position2), "\\"));
    }
    start2 = position2;
    if (/[!-/:-@[-`{-~]/.test(value.charAt(position2)) && (!config.encode || !config.encode.includes(value.charAt(position2)))) {
      result.push("\\");
    } else {
      result.push(
        "&#x" + value.charCodeAt(position2).toString(16).toUpperCase() + ";"
      );
      start2++;
    }
  }
  result.push(escapeBackslashes(value.slice(start2, end), config.after));
  return result.join("");
}
function numerical(a2, b2) {
  return a2 - b2;
}
function escapeBackslashes(value, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value + after;
  let index2 = -1;
  let start2 = 0;
  let match;
  while (match = expression.exec(whole)) {
    positions.push(match.index);
  }
  while (++index2 < positions.length) {
    if (start2 !== positions[index2]) {
      results.push(value.slice(start2, positions[index2]));
    }
    results.push("\\");
    start2 = positions[index2];
  }
  results.push(value.slice(start2));
  return results.join("");
}
function track(config) {
  const options = config || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;
  return { move, current, shift };
  function current() {
    return { now: { line, column }, lineShift };
  }
  function shift(value) {
    lineShift += value;
  }
  function move(input) {
    const value = input || "";
    const chunks = value.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value;
  }
}
function toMarkdown(tree, options = {}) {
  const state = {
    enter,
    indentLines,
    associationId: association,
    containerPhrasing: containerPhrasingBound,
    containerFlow: containerFlowBound,
    createTracker: track,
    safe: safeBound,
    stack: [],
    unsafe: [],
    join: [],
    // @ts-expect-error: we’ll fill it next.
    handlers: {},
    options: {},
    indexStack: [],
    // @ts-expect-error: we’ll add `handle` later.
    handle: void 0
  };
  configure$1(state, { unsafe, join, handlers: handle });
  configure$1(state, options);
  if (state.options.tightDefinitions) {
    configure$1(state, { join: [joinDefinition] });
  }
  state.handle = zwitch("type", {
    invalid,
    unknown,
    handlers: state.handlers
  });
  let result = state.handle(tree, void 0, state, {
    before: "\n",
    after: "\n",
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
    result += "\n";
  }
  return result;
  function enter(name) {
    state.stack.push(name);
    return exit2;
    function exit2() {
      state.stack.pop();
    }
  }
}
function invalid(value) {
  throw new Error("Cannot handle value `" + value + "`, expected node");
}
function unknown(node2) {
  throw new Error("Cannot handle unknown node `" + node2.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}
function containerPhrasingBound(parent, info) {
  return containerPhrasing(parent, this, info);
}
function containerFlowBound(parent, info) {
  return containerFlow$1(parent, this, info);
}
function safeBound(value, config) {
  return safe(this, value, config);
}
const MDX_NODE_TYPES = ["mdxJsxTextElement", "mdxJsxFlowElement"];
function isMdastHTMLNode(node2) {
  var _a;
  return MDX_NODE_TYPES.includes(node2.type) && htmlTags.includes(((_a = node2.name) == null ? void 0 : _a.toLowerCase()) ?? "");
}
const htmlTags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  // 'img',
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
function mergeStyleAttributes(style1, style2) {
  const styleObject1 = styleToObject(style1);
  const styleObject2 = styleToObject(style2);
  const mergedStyleObject = { ...styleObject1, ...styleObject2 };
  const mergedStyleString = objectToStyle(mergedStyleObject);
  return mergedStyleString;
}
function styleToObject(style) {
  const styleObject = {};
  const stylePairs = style.split(";").filter((pair) => pair.trim() !== "");
  stylePairs.forEach((pair) => {
    const [key, value] = pair.split(":").map((part) => part.trim());
    styleObject[key] = value;
  });
  return styleObject;
}
function objectToStyle(styleObject) {
  return Object.entries(styleObject).map(([key, value]) => `${key}: ${value}`).join("; ");
}
function isParent$1(node2) {
  return node2.children instanceof Array;
}
function exportLexicalTreeToMdast({
  root: root2,
  visitors,
  jsxComponentDescriptors,
  jsxIsAvailable,
  addImportStatements = true
}) {
  let unistRoot = null;
  const referredComponents = /* @__PURE__ */ new Set();
  visitors = visitors.sort((a2, b2) => (b2.priority ?? 0) - (a2.priority ?? 0));
  visit2(root2, null);
  function registerReferredComponent(componentName) {
    referredComponents.add(componentName);
  }
  function appendToParent(parentNode, node2) {
    if (unistRoot === null) {
      unistRoot = node2;
      return unistRoot;
    }
    if (!isParent$1(parentNode)) {
      throw new Error("Attempting to append children to a non-parent");
    }
    const siblings = parentNode.children;
    const prevSibling = siblings.at(-1);
    if (prevSibling) {
      const joinVisitor = visitors.find((visitor) => {
        var _a;
        return (_a = visitor.shouldJoin) == null ? void 0 : _a.call(visitor, prevSibling, node2);
      });
      if (joinVisitor) {
        const joinedNode = joinVisitor.join(prevSibling, node2);
        siblings.splice(siblings.length - 1, 1, joinedNode);
        return joinedNode;
      }
    }
    siblings.push(node2);
    return node2;
  }
  function visitChildren(lexicalNode, parentNode) {
    lexicalNode.getChildren().forEach((lexicalChild) => {
      visit2(lexicalChild, parentNode);
    });
  }
  function visit2(lexicalNode, mdastParent) {
    var _a;
    const visitor = visitors.find((visitor2) => {
      var _a2;
      return (_a2 = visitor2.testLexicalNode) == null ? void 0 : _a2.call(visitor2, lexicalNode);
    });
    if (!visitor) {
      throw new Error(`no lexical visitor found for ${lexicalNode.getType()}`, {
        cause: lexicalNode
      });
    }
    (_a = visitor.visitLexicalNode) == null ? void 0 : _a.call(visitor, {
      lexicalNode,
      mdastParent,
      actions: {
        addAndStepInto(type, props = {}, hasChildren = true) {
          const newNode = {
            type,
            ...props,
            ...hasChildren ? { children: [] } : {}
          };
          appendToParent(mdastParent, newNode);
          if (Lexical_1.$isElementNode(lexicalNode) && hasChildren) {
            visitChildren(lexicalNode, newNode);
          }
        },
        appendToParent,
        visitChildren,
        registerReferredComponent
      }
    });
  }
  if (unistRoot === null) {
    throw new Error("traversal ended with no root element");
  }
  const importsMap = /* @__PURE__ */ new Map();
  const defaultImportsMap = /* @__PURE__ */ new Map();
  for (const componentName of referredComponents) {
    const descriptor = jsxComponentDescriptors.find((descriptor2) => descriptor2.name === componentName);
    if (!descriptor) {
      throw new Error(`Component ${componentName} is used but not imported`);
    }
    if (!descriptor.source) {
      continue;
    }
    if (descriptor.defaultExport) {
      defaultImportsMap.set(componentName, descriptor.source);
    } else {
      const { source } = descriptor;
      const existing = importsMap.get(source);
      if (existing) {
        existing.push(componentName);
      } else {
        importsMap.set(source, [componentName]);
      }
    }
  }
  const imports = Array.from(importsMap).map(([source, componentNames]) => {
    return {
      type: "mdxjsEsm",
      value: `import { ${componentNames.join(", ")} } from '${source}'`
    };
  });
  imports.push(
    ...Array.from(defaultImportsMap).map(([componentName, source]) => {
      return {
        type: "mdxjsEsm",
        value: `import ${componentName} from '${source}'`
      };
    })
  );
  const typedRoot = unistRoot;
  const frontmatter = typedRoot.children.find((child) => child.type === "yaml");
  if (addImportStatements) {
    if (frontmatter) {
      typedRoot.children.splice(typedRoot.children.indexOf(frontmatter) + 1, 0, ...imports);
    } else {
      typedRoot.children.unshift(...imports);
    }
  }
  fixWrappingWhitespace(typedRoot, []);
  collapseNestedHtmlTags(typedRoot);
  if (!jsxIsAvailable) {
    convertUnderlineJsxToHtml(typedRoot);
  }
  return typedRoot;
}
function collapseNestedHtmlTags(node2) {
  if ("children" in node2 && node2.children) {
    if (isMdastHTMLNode(node2) && node2.children.length === 1) {
      const onlyChild = node2.children[0];
      if (onlyChild.type === "mdxJsxTextElement" && onlyChild.name === "span") {
        (onlyChild.attributes || []).forEach((attribute) => {
          var _a;
          if (attribute.type === "mdxJsxAttribute") {
            const parentAttribute = (_a = node2.attributes) == null ? void 0 : _a.find((attr) => attr.type === "mdxJsxAttribute" && attr.name === attribute.name);
            if (parentAttribute) {
              if (attribute.name === "className") {
                const mergedClassesSet = /* @__PURE__ */ new Set([
                  ...parentAttribute.value.split(" "),
                  ...attribute.value.split(" ")
                ]);
                parentAttribute.value = Array.from(mergedClassesSet).join(" ");
              } else if (attribute.name === "style") {
                parentAttribute.value = mergeStyleAttributes(parentAttribute.value, attribute.value);
              }
            } else {
              node2.attributes.push(attribute);
            }
          }
        });
        node2.children = onlyChild.children;
      }
    }
    node2.children.forEach((child) => collapseNestedHtmlTags(child));
  }
}
function convertUnderlineJsxToHtml(node2) {
  if (Object.hasOwn(node2, "children")) {
    const nodeAsParent = node2;
    const newChildren = [];
    nodeAsParent.children.forEach((child) => {
      if (child.type === "mdxJsxTextElement" && child.name === "u") {
        newChildren.push(...[{ type: "html", value: "<u>" }, ...child.children, { type: "html", value: "</u>" }]);
      } else {
        newChildren.push(child);
        convertUnderlineJsxToHtml(child);
      }
    });
    nodeAsParent.children = newChildren;
  }
}
const TRAILING_WHITESPACE_REGEXP = /\s+$/;
const LEADING_WHITESPACE_REGEXP = /^\s+/;
function fixWrappingWhitespace(node2, parentChain) {
  if (node2.type === "strong" || node2.type === "emphasis") {
    const lastChild = node2.children.at(-1);
    if ((lastChild == null ? void 0 : lastChild.type) === "text") {
      const trailingWhitespace = lastChild.value.match(TRAILING_WHITESPACE_REGEXP);
      if (trailingWhitespace) {
        lastChild.value = lastChild.value.replace(TRAILING_WHITESPACE_REGEXP, "");
        const parent = parentChain.at(-1);
        if (parent) {
          parent.children.splice(parent.children.indexOf(node2) + 1, 0, {
            type: "text",
            value: trailingWhitespace[0]
          });
          fixWrappingWhitespace(parent, parentChain.slice(0, -1));
        }
      }
    }
    const firstChild = node2.children.at(0);
    if ((firstChild == null ? void 0 : firstChild.type) === "text") {
      const leadingWhitespace = firstChild.value.match(LEADING_WHITESPACE_REGEXP);
      if (leadingWhitespace) {
        firstChild.value = firstChild.value.replace(LEADING_WHITESPACE_REGEXP, "");
        const parent = parentChain.at(-1);
        if (parent) {
          parent.children.splice(parent.children.indexOf(node2), 0, {
            type: "text",
            value: leadingWhitespace[0]
          });
          fixWrappingWhitespace(parent, parentChain.slice(0, -1));
        }
      }
    }
  }
  if ("children" in node2 && node2.children) {
    const nodeAsParent = node2;
    nodeAsParent.children.forEach((child) => fixWrappingWhitespace(child, [...parentChain, nodeAsParent]));
  }
}
function exportMarkdownFromLexical({
  root: root2,
  toMarkdownOptions,
  toMarkdownExtensions,
  visitors,
  jsxComponentDescriptors,
  jsxIsAvailable
}) {
  return toMarkdown(exportLexicalTreeToMdast({ root: root2, visitors, jsxComponentDescriptors, jsxIsAvailable }), {
    extensions: toMarkdownExtensions,
    ...toMarkdownOptions
  });
}
function splice(list2, start2, remove, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start2 < 0) {
    start2 = -start2 > end ? 0 : end + start2;
  } else {
    start2 = start2 > end ? end : start2;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start2, remove);
    list2.splice(...parameters);
  } else {
    if (remove)
      list2.splice(start2, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start2, 0);
      list2.splice(...parameters);
      chunkStart += 1e4;
      start2 += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty.call(left, code2))
          left[code2] = [];
        const value = right[code2];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code2],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice(existing, 0, 0, before);
}
const unicodePunctuationRegex = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
const asciiAlpha = regexCheck(/[A-Za-z]/);
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < 32 || code2 === 127)
  );
}
const asciiDigit = regexCheck(/\d/);
const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
const unicodePunctuation = regexCheck(unicodePunctuationRegex);
const unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && regex.test(String.fromCharCode(code2));
  }
}
function factorySpace(effects, ok2, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start2;
  function start2(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok2(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok2(code2);
  }
}
const content$1 = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}
const document$2 = {
  tokenize: initializeDocument
};
const containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start2;
  function start2(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start2(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start2;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self2.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index2][1].start.offset < lineStartOffset && // …and either is not ended yet…
          (!childFlow.events[index2][1].end || // …or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen2;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen2) {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen2 = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok2, nok),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}
const attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text2;
  let openingSequence;
  let closingSequence;
  let use2;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use2 = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start2 = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start2, -use2);
          movePoint(end, use2);
          openingSequence = {
            type: use2 > 1 ? "strongSequence" : "emphasisSequence",
            start: start2,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use2 > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text2 = {
            type: use2 > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use2 > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text2, context]
          ]);
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text2, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start2;
  function start2(code2) {
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
    token._open = Boolean(marker === 42 ? open : open && (before || !close));
    token._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point2, offset) {
  point2.column += offset;
  point2.offset += offset;
  point2._bufferIndex += offset;
}
const autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 0;
  return start2;
  function start2(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
      size = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      size = 0;
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
      const next = code2 === 45 ? emailValue : emailLabel;
      effects.consume(code2);
      return next;
    }
    return nok(code2);
  }
}
const blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return start2;
  function start2(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (code2 === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  const self2 = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        contBefore,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok2, nok)(code2);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start2;
  function start2(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test;
  return start2;
  function start2(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    if (code2 === 59 && size) {
      const token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code2) && size++ < max) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}
const nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
const codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this;
  const closeStart = {
    tokenize: tokenizeCloseStart,
    partial: true
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start2;
  function start2(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code2);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFencedFence");
      return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, metaBefore, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return infoBefore(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(
      effects,
      beforeContentChunk,
      "linePrefix",
      initialPrefix + 1
    )(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeCloseStart(effects2, ok3, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return start3;
    }
    function start3(code2) {
      effects2.enter("codeFencedFence");
      return markdownSpace(code2) ? factorySpace(
        effects2,
        beforeSequenceClose,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
const furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeFurtherStart(effects, ok2, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}
const codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  let sizeOpen = 0;
  let size;
  let token;
  return start2;
  function start2(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between2(code2);
  }
  function between2(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between2;
    }
    if (code2 === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return between2;
    }
    effects.enter("codeTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return between2(code2);
    }
    effects.consume(code2);
    return data;
  }
  function sequenceClose(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token.type = "codeTextData";
    return data(code2);
  }
}
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start2 = 0;
  const breaks = [start2];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      start2 = index2 + 1;
      breaks.push(start2);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start3 = startPositions.pop();
    jumps.unshift([start3, start3 + slice.length - 1]);
    splice(events, start3, 2, slice);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}
const content = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
const continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
  }
}
function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start2;
  function start2(code2) {
    if (code2 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw(code2) {
    if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code2);
    }
    if (balance < limit && code2 === 40) {
      effects.consume(code2);
      balance++;
      return raw;
    }
    if (code2 === 41) {
      effects.consume(code2);
      balance--;
      return raw;
    }
    if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? rawEscape : raw;
  }
  function rawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return raw;
    }
    return raw(code2);
  }
}
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen2;
  return start2;
  function start2(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen2 || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen2)
      seen2 = !markdownSpace(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
}
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
  let marker;
  return start2;
  function start2(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === 40 ? 41 : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? escape2 : inside;
  }
  function escape2(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}
function factoryWhitespace(effects, ok2) {
  let seen2;
  return start2;
  function start2(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen2 = true;
      return start2;
    }
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        start2,
        seen2 ? "linePrefix" : "lineSuffix"
      )(code2);
    }
    return ok2(code2);
  }
}
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
const titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier;
  return start2;
  function start2(code2) {
    effects.enter("definition");
    return before(code2);
  }
  function before(code2) {
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      self2.parser.defined.push(identifier);
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok2, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start2;
  function start2(code2) {
    effects.enter("hardBreakEscape");
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content2;
  let text2;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content2 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text2 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content2, context],
      ["enter", text2, context],
      ["exit", text2, context],
      ["exit", content2, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  let size = 0;
  return start2;
  function start2(code2) {
    effects.enter("atxHeading");
    return before(code2);
  }
  function before(code2) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 35 && size++ < 6) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return atBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}
const htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
const htmlRawNames = ["pre", "script", "style", "textarea"];
const htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
const blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: true
};
const nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index2;
  let markerB;
  return start2;
  function start2(code2) {
    return before(code2);
  }
  function before(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      marker = 3;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      marker = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      marker = 5;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      marker = 4;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      if (index2 === value.length) {
        return self2.interrupt ? ok2 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === 47;
      const name = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = 1;
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      marker = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuation(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && marker === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && marker === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && marker === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && marker === 5) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code2);
  }
  function continuationStartNonLazy(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationStart(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62) {
      const name = buffer.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha(code2) && buffer.length < 8) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok2, nok) {
  return start2;
  function start2(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return effects.attempt(blankLine, ok2, nok);
  }
}
const htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start2;
  function start2(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment(code2);
  }
  function commentEnd(code2) {
    return code2 === 62 ? end(code2) : code2 === 45 ? commentClose(code2) : comment(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === null || code2 === 62) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    return markdownSpace(code2) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
}
const labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
const resourceConstruct = {
  tokenize: tokenizeResource
};
const referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
const referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text2 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text2, context]]);
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text2, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start2;
  function start2(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({
          start: labelStart.end,
          end: self2.now()
        })
      )
    );
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code2) {
    if (code2 === 40) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code2);
    }
    if (code2 === 91) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code2);
  }
  function labelEndOk(code2) {
    return ok2(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === 41) {
      return resourceEnd(code2);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        "resourceTitle",
        "resourceTitleMarker",
        "resourceTitleString"
      )(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok2, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      "reference",
      "referenceMarker",
      "referenceString"
    )(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok2(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start2;
  function start2(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}
const thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start2;
  function start2(code2) {
    effects.enter("thematicBreak");
    return before(code2);
  }
  function before(code2) {
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (size >= 3 && (code2 === null || markdownLineEnding(code2))) {
      effects.exit("thematicBreak");
      return ok2(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
  }
}
const list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
const listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
const indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start2;
  function start2(code2) {
    const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(
      blankLine,
      // Can’t be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code2) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok2,
      "listItemIndent",
      self2.containerState.size + 1
    )(code2);
  }
  function notBlank(code2) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace(
      effects,
      effects.attempt(list, ok2, nok),
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code2);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemIndent",
    self2.containerState.size + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemPrefixWhitespace",
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content2;
  let text2;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content2 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text2 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading2 = {
    type: "setextHeading",
    start: Object.assign({}, events[text2][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text2][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text2, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
    events[content2][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content2][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let marker;
  return start2;
  function start2(code2) {
    let index2 = self2.events.length;
    let paragraph2;
    while (index2--) {
      if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
        paragraph2 = self2.events[index2][1].type === "paragraph";
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter("setextHeadingLineSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const flow$1 = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content, afterConstruct)
        ),
        "linePrefix"
      )
    )
  );
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}
const resolver = {
  resolveAll: createResolver()
};
const string$1 = initializeFactory("string");
const text$1 = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text2 = effects.attempt(constructs2, start2, notText);
    return start2;
    function start2(code2) {
      return atBreak(code2) ? text2(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text2(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1)
          ;
        else {
          index2++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}
function createTokenizer(parser, initialize, from) {
  let point2 = Object.assign(
    from ? Object.assign({}, from) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks$1(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { line, column, offset, _index, _bufferIndex } = point2;
    return {
      line,
      column,
      offset,
      _index,
      _bufferIndex
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code2;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? (
        // @ts-expect-error Looks like a construct.
        handleListOfConstructs([constructs2])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map2) {
        return start2;
        function start2(code2) {
          const def = code2 !== null && map2[code2];
          const all2 = code2 !== null && map2.null;
          const list2 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start2;
        function start2(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok();
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok2,
            nok
          )(code2);
        }
      }
      function ok2(code2) {
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks$1(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}
const document$1 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
const contentInitial = {
  [91]: definition
};
const flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
const flow = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
const string = {
  [38]: characterReference,
  [92]: characterEscape
};
const text = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
const insideSpan = {
  null: [attention, resolver]
};
const attentionMarkers = {
  null: [42, 95]
};
const disable = {
  null: []
};
const defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers,
  contentInitial,
  disable,
  document: document$1,
  flow,
  flowInitial,
  insideSpan,
  string,
  text
}, Symbol.toStringTag, { value: "Module" }));
function parse(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([defaultConstructs, ...settings.extensions || []])
  );
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create(content$1),
    document: create(document$2),
    flow: create(flow$1),
    string: create(string$1),
    text: create(text$1)
  };
  return parser;
  function create(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}
const search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start2 = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer + value.toString(encoding);
    startPosition = 0;
    buffer = "";
    if (start2) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start2 = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer)
        chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point$1(value);
  }
  return "";
}
function point$1(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
const own$1 = {}.hasOwnProperty;
const fromMarkdown = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding | Options | null | undefined} [encoding]
   * @param {Options | null | undefined} [options]
   * @returns {Root}
   */
  function(value, encoding, options) {
    if (typeof encoding !== "string") {
      options = encoding;
      encoding = void 0;
    }
    return compiler(options)(
      postprocess(
        parse(options).document().write(preprocess()(value, encoding, true))
      )
    );
  }
);
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer,
      resume,
      setData,
      getData
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own$1.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            {
              sliceSerialize: events[index2][2].sliceSerialize
            },
            context
          ),
          events[index2][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point(
        events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: point(
        events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start2, length) {
    let index2 = start2 - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace")
        ;
      else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
              ;
            else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem3 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          events.splice(index2, 0, ["enter", listItem3, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start2][1]._spread = listSpread;
    return length;
  }
  function setData(key, value) {
    data[key] = value;
  }
  function getData(key) {
    return data[key];
  }
  function opener(create, and) {
    return open;
    function open(token) {
      enter.call(this, create(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    parent.children.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler]);
    node2.position = {
      start: point(token.start)
    };
    return node2;
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and)
        and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({
          start: token.start,
          end: token.end
        }) + "): it’s not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node2.position.end = point(token.end);
    return node2;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside"))
      return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    let tail = node2.children[node2.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text2();
      tail.position = {
        start: point(token.start)
      };
      node2.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    const string2 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string2);
    ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    setData("inReference", true);
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = getData("characterReferenceType");
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data2,
        type === "characterReferenceMarkerNumeric" ? 10 : 16
      );
      setData("characterReferenceType");
    } else {
      const result = decodeNamedCharacterReference(data2);
      value = result;
    }
    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text2() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function point(d2) {
  return {
    line: d2.line,
    column: d2.column,
    offset: d2.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own$1.call(extension2, key)) {
      if (key === "canContainEols") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "transforms") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "enter" || key === "exit") {
        const right = extension2[key];
        if (right) {
          Object.assign(combined[key], right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is still open"
    );
  }
}
function isParent(node2) {
  return node2.children instanceof Array;
}
class MarkdownParseError extends Error {
  constructor(message, cause) {
    super(message);
    this.name = "MarkdownParseError";
    this.cause = cause;
  }
}
class UnrecognizedMarkdownConstructError extends Error {
  constructor(message) {
    super(message);
    this.name = "UnrecognizedMarkdownConstructError";
  }
}
function importMarkdownToLexical({ root: root2, markdown, visitors, syntaxExtensions, mdastExtensions }) {
  var _a;
  let mdastRoot;
  try {
    mdastRoot = fromMarkdown(markdown, {
      extensions: syntaxExtensions,
      mdastExtensions
    });
  } catch (e2) {
    if (e2 instanceof Error) {
      throw new MarkdownParseError(`Error parsing markdown: ${e2.message}`, e2);
    } else {
      throw new MarkdownParseError(`Error parsing markdown: ${e2}`, e2);
    }
  }
  if (mdastRoot.children.length === 0) {
    mdastRoot.children.push({ type: "paragraph", children: [] });
  }
  if (((_a = mdastRoot.children.at(-1)) == null ? void 0 : _a.type) !== "paragraph") {
    mdastRoot.children.push({ type: "paragraph", children: [] });
  }
  importMdastTreeToLexical({ root: root2, mdastRoot, visitors });
}
function importMdastTreeToLexical({ root: root2, mdastRoot, visitors }) {
  const formattingMap = /* @__PURE__ */ new WeakMap();
  visitors = visitors.sort((a2, b2) => (b2.priority ?? 0) - (a2.priority ?? 0));
  function visitChildren(mdastNode, lexicalParent) {
    if (!isParent(mdastNode)) {
      throw new Error("Attempting to visit children of a non-parent");
    }
    mdastNode.children.forEach((child) => visit2(child, lexicalParent, mdastNode));
  }
  function visit2(mdastNode, lexicalParent, mdastParent) {
    const visitor = visitors.find((visitor2) => {
      if (typeof visitor2.testNode === "string") {
        return visitor2.testNode === mdastNode.type;
      }
      return visitor2.testNode(mdastNode);
    });
    if (!visitor) {
      throw new UnrecognizedMarkdownConstructError(`Unsupported markdown syntax: ${toMarkdown(mdastNode)}`);
    }
    visitor.visitNode({
      //@ts-expect-error root type is glitching
      mdastNode,
      lexicalParent,
      mdastParent,
      actions: {
        visitChildren,
        addAndStepInto(lexicalNode) {
          lexicalParent.append(lexicalNode);
          if (isParent(mdastNode)) {
            visitChildren(mdastNode, lexicalNode);
          }
        },
        addFormatting(format, node2 = mdastNode) {
          formattingMap.set(node2, format | (formattingMap.get(mdastParent) ?? 0));
        },
        removeFormatting(format, node2 = mdastNode) {
          formattingMap.set(node2, format ^ (formattingMap.get(mdastParent) ?? 0));
        },
        getParentFormatting() {
          return formattingMap.get(mdastParent) ?? 0;
        }
      }
    });
  }
  visit2(mdastRoot, root2, null);
}
const LexicalLinebreakVisitor = {
  testLexicalNode: Lexical_1.$isLineBreakNode,
  visitLexicalNode: ({ mdastParent, actions }) => {
    actions.appendToParent(mdastParent, { type: "text", value: "\n" });
  }
};
const LexicalParagraphVisitor = {
  testLexicalNode: Lexical_1.$isParagraphNode,
  visitLexicalNode: ({ actions }) => {
    actions.addAndStepInto("paragraph");
  }
};
const LexicalRootVisitor = {
  testLexicalNode: Lexical_1.$isRootNode,
  visitLexicalNode: ({ actions }) => {
    actions.addAndStepInto("root");
  }
};
const IS_BOLD = 1;
const IS_ITALIC = 2;
const IS_UNDERLINE = 8;
const IS_CODE = 16;
function isMdastText(mdastNode) {
  return mdastNode.type === "text";
}
const JOINABLE_TAGS = ["u", "span"];
const LexicalTextVisitor = {
  shouldJoin: (prevNode, currentNode) => {
    if (["text", "emphasis", "strong"].includes(prevNode.type)) {
      return prevNode.type === currentNode.type;
    }
    if (prevNode.type === "mdxJsxTextElement" && currentNode.type === "mdxJsxTextElement" && JOINABLE_TAGS.includes(currentNode.name)) {
      const currentMdxNode = currentNode;
      return prevNode.name === currentMdxNode.name && JSON.stringify(prevNode.attributes) === JSON.stringify(currentMdxNode.attributes);
    }
    return false;
  },
  join(prevNode, currentNode) {
    if (isMdastText(prevNode) && isMdastText(currentNode)) {
      return {
        type: "text",
        value: prevNode.value + currentNode.value
      };
    } else {
      return {
        ...prevNode,
        children: [...prevNode.children, ...currentNode.children]
      };
    }
  },
  testLexicalNode: Lexical_1.$isTextNode,
  visitLexicalNode: ({ lexicalNode, mdastParent, actions }) => {
    const previousSibling = lexicalNode.getPreviousSibling();
    const prevFormat = Lexical_1.$isTextNode(previousSibling) ? previousSibling.getFormat() : 0;
    const textContent = lexicalNode.getTextContent();
    const format = lexicalNode.getFormat() ?? 0;
    const style = lexicalNode.getStyle();
    if (format & IS_CODE) {
      actions.addAndStepInto("inlineCode", {
        value: textContent
      });
      return;
    }
    let localParentNode = mdastParent;
    if (style) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "span",
        children: [],
        attributes: [{ type: "mdxJsxAttribute", name: "style", value: style }]
      });
    }
    if (prevFormat & format & IS_ITALIC) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "emphasis",
        children: []
      });
    }
    if (prevFormat & format & IS_BOLD) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "strong",
        children: []
      });
    }
    if (prevFormat & format & IS_UNDERLINE) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "u",
        children: [],
        attributes: []
      });
    }
    if (format & IS_ITALIC && !(prevFormat & IS_ITALIC)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "emphasis",
        children: []
      });
    }
    if (format & IS_BOLD && !(prevFormat & IS_BOLD)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "strong",
        children: []
      });
    }
    if (format & IS_UNDERLINE && !(prevFormat & IS_UNDERLINE)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "u",
        children: [],
        attributes: []
      });
    }
    actions.appendToParent(localParentNode, {
      type: "text",
      value: textContent
    });
  }
};
function isOpeningUnderlineNode(node2) {
  return node2.type === "html" && node2.value === "<u>";
}
function isClosingUnderlineNode(node2) {
  return node2.type === "html" && node2.value === "</u>";
}
function isJsxUnderlineNode(node2) {
  return node2.type === "mdxJsxTextElement" && node2.name === "u";
}
const MdastFormattingVisitor = {
  testNode(mdastNode) {
    return mdastNode.type === "emphasis" || mdastNode.type === "strong" || isJsxUnderlineNode(mdastNode) || isOpeningUnderlineNode(mdastNode) || isClosingUnderlineNode(mdastNode);
  },
  visitNode({ mdastNode, lexicalParent, actions, mdastParent }) {
    if (isOpeningUnderlineNode(mdastNode)) {
      actions.addFormatting(IS_UNDERLINE, mdastParent);
      return;
    }
    if (isClosingUnderlineNode(mdastNode)) {
      actions.removeFormatting(IS_UNDERLINE, mdastParent);
      return;
    }
    if (mdastNode.type === "emphasis") {
      actions.addFormatting(IS_ITALIC);
    } else if (mdastNode.type === "strong") {
      actions.addFormatting(IS_BOLD);
    } else if (isJsxUnderlineNode(mdastNode)) {
      actions.addFormatting(IS_UNDERLINE);
    }
    actions.visitChildren(mdastNode, lexicalParent);
  }
};
function isOpeningCodeNode(node2) {
  return node2.type === "html" && node2.value === "<code>";
}
function isClosingCodeNode(node2) {
  return node2.type === "html" && node2.value === "</code>";
}
const MdastInlineCodeVisitor = {
  testNode: (node2) => {
    return node2.type === "inlineCode" || isOpeningCodeNode(node2) || isClosingCodeNode(node2);
  },
  visitNode({ mdastNode, actions, mdastParent }) {
    if (isOpeningCodeNode(mdastNode)) {
      actions.addFormatting(IS_CODE, mdastParent);
      return;
    }
    if (isClosingCodeNode(mdastNode)) {
      actions.removeFormatting(IS_CODE, mdastParent);
      return;
    }
    actions.addAndStepInto(Lexical_1.$createTextNode(mdastNode.value).setFormat(IS_CODE));
  }
};
const lexicalTypesThatShouldSkipParagraphs = ["listitem", "quote", "admonition"];
const MdastParagraphVisitor = {
  testNode: "paragraph",
  visitNode: function({ mdastNode, lexicalParent, actions }) {
    if (lexicalTypesThatShouldSkipParagraphs.includes(lexicalParent.getType())) {
      actions.visitChildren(mdastNode, lexicalParent);
    } else {
      actions.addAndStepInto(Lexical_1.$createParagraphNode());
    }
  }
};
const MdastRootVisitor = {
  testNode: "root",
  visitNode({ actions, mdastNode, lexicalParent }) {
    actions.visitChildren(mdastNode, lexicalParent);
  }
};
const MdastTextVisitor = {
  testNode: "text",
  visitNode({ mdastNode, actions }) {
    actions.addAndStepInto(Lexical_1.$createTextNode(mdastNode.value).setFormat(actions.getParentFormatting()));
  }
};
const SharedHistoryPlugin = () => {
  const [historyState] = corePluginHooks.useEmitterValues("historyState");
  return /* @__PURE__ */ React__default.createElement(LexicalHistoryPlugin_1.HistoryPlugin, { externalHistoryState: historyState });
};
function tap(arg, proc) {
  proc(arg);
  return arg;
}
function noop() {
}
const CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
function controlOrMeta(metaKey, ctrlKey) {
  if (IS_APPLE) {
    return metaKey;
  }
  return ctrlKey;
}
const MdastBreakVisitor = {
  testNode: "break",
  visitNode: function({ lexicalParent }) {
    lexicalParent.append(Lexical_1.$createLineBreakNode());
  }
};
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character, index2 + character.length);
  }
  return count;
}
const characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];
const characterReferenceInvalid = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};
function isDecimal(character) {
  const code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 48 && code2 <= 57;
}
function isHexadecimal(character) {
  const code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 97 && code2 <= 102 || code2 >= 65 && code2 <= 70 || code2 >= 48 && code2 <= 57;
}
function isAlphabetical(character) {
  const code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
}
function isAlphanumerical(character) {
  return isAlphabetical(character) || isDecimal(character);
}
const fromCharCode = String.fromCharCode;
const messages = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function parseEntities(value, options = {}) {
  const additional = typeof options.additional === "string" ? options.additional.charCodeAt(0) : options.additional;
  const result = [];
  let index2 = 0;
  let lines = -1;
  let queue = "";
  let point2;
  let indent2;
  if (options.position) {
    if ("start" in options.position || "indent" in options.position) {
      indent2 = options.position.indent;
      point2 = options.position.start;
    } else {
      point2 = options.position;
    }
  }
  let line = (point2 ? point2.line : 0) || 1;
  let column = (point2 ? point2.column : 0) || 1;
  let previous2 = now();
  let character;
  index2--;
  while (++index2 <= value.length) {
    if (character === 10) {
      column = (indent2 ? indent2[lines] : 0) || 1;
    }
    character = value.charCodeAt(index2);
    if (character === 38) {
      const following = value.charCodeAt(index2 + 1);
      if (following === 9 || following === 10 || following === 12 || following === 32 || following === 38 || following === 60 || Number.isNaN(following) || additional && following === additional) {
        queue += fromCharCode(character);
        column++;
        continue;
      }
      const start2 = index2 + 1;
      let begin = start2;
      let end = start2;
      let type;
      if (following === 35) {
        end = ++begin;
        const following2 = value.charCodeAt(end);
        if (following2 === 88 || following2 === 120) {
          type = "hexadecimal";
          end = ++begin;
        } else {
          type = "decimal";
        }
      } else {
        type = "named";
      }
      let characterReferenceCharacters = "";
      let characterReference2 = "";
      let characters = "";
      const test = type === "named" ? isAlphanumerical : type === "decimal" ? isDecimal : isHexadecimal;
      end--;
      while (++end <= value.length) {
        const following2 = value.charCodeAt(end);
        if (!test(following2)) {
          break;
        }
        characters += fromCharCode(following2);
        if (type === "named" && characterEntitiesLegacy.includes(characters)) {
          characterReferenceCharacters = characters;
          characterReference2 = decodeNamedCharacterReference(characters);
        }
      }
      let terminated = value.charCodeAt(end) === 59;
      if (terminated) {
        end++;
        const namedReference = type === "named" ? decodeNamedCharacterReference(characters) : false;
        if (namedReference) {
          characterReferenceCharacters = characters;
          characterReference2 = namedReference;
        }
      }
      let diff = 1 + end - start2;
      let reference = "";
      if (!terminated && options.nonTerminated === false)
        ;
      else if (!characters) {
        if (type !== "named") {
          warning(4, diff);
        }
      } else if (type === "named") {
        if (terminated && !characterReference2) {
          warning(5, 1);
        } else {
          if (characterReferenceCharacters !== characters) {
            end = begin + characterReferenceCharacters.length;
            diff = 1 + end - begin;
            terminated = false;
          }
          if (!terminated) {
            const reason = characterReferenceCharacters ? 1 : 3;
            if (options.attribute) {
              const following2 = value.charCodeAt(end);
              if (following2 === 61) {
                warning(reason, diff);
                characterReference2 = "";
              } else if (isAlphanumerical(following2)) {
                characterReference2 = "";
              } else {
                warning(reason, diff);
              }
            } else {
              warning(reason, diff);
            }
          }
        }
        reference = characterReference2;
      } else {
        if (!terminated) {
          warning(2, diff);
        }
        let referenceCode = Number.parseInt(
          characters,
          type === "hexadecimal" ? 16 : 10
        );
        if (prohibited(referenceCode)) {
          warning(7, diff);
          reference = fromCharCode(
            65533
            /* `�` */
          );
        } else if (referenceCode in characterReferenceInvalid) {
          warning(6, diff);
          reference = characterReferenceInvalid[referenceCode];
        } else {
          let output = "";
          if (disallowed(referenceCode)) {
            warning(6, diff);
          }
          if (referenceCode > 65535) {
            referenceCode -= 65536;
            output += fromCharCode(referenceCode >>> (10 & 1023) | 55296);
            referenceCode = 56320 | referenceCode & 1023;
          }
          reference = output + fromCharCode(referenceCode);
        }
      }
      if (reference) {
        flush();
        previous2 = now();
        index2 = end - 1;
        column += end - start2 + 1;
        result.push(reference);
        const next = now();
        next.offset++;
        if (options.reference) {
          options.reference.call(
            options.referenceContext,
            reference,
            { start: previous2, end: next },
            value.slice(start2 - 1, end)
          );
        }
        previous2 = next;
      } else {
        characters = value.slice(start2 - 1, end);
        queue += characters;
        column += characters.length;
        index2 = end - 1;
      }
    } else {
      if (character === 10) {
        line++;
        lines++;
        column = 0;
      }
      if (Number.isNaN(character)) {
        flush();
      } else {
        queue += fromCharCode(character);
        column++;
      }
    }
  }
  return result.join("");
  function now() {
    return {
      line,
      column,
      offset: index2 + ((point2 ? point2.offset : 0) || 0)
    };
  }
  function warning(code2, offset) {
    let position2;
    if (options.warning) {
      position2 = now();
      position2.column += offset;
      position2.offset += offset;
      options.warning.call(
        options.warningContext,
        messages[code2],
        position2,
        code2
      );
    }
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (options.text) {
        options.text.call(options.textContext, queue, {
          start: previous2,
          end: now()
        });
      }
      queue = "";
    }
  }
}
function prohibited(code2) {
  return code2 >= 55296 && code2 <= 57343 || code2 > 1114111;
}
function disallowed(code2) {
  return code2 >= 1 && code2 <= 8 || code2 === 11 || code2 >= 13 && code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 64976 && code2 <= 65007 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(reason, place, origin) {
    const parts = [null, null];
    let position2 = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin = place;
      place = void 0;
    }
    if (typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index2);
        parts[1] = origin.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position2 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position2 = place;
      } else if ("line" in place || "column" in place) {
        position2.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = "";
    if (typeof reason === "object" && reason.stack) {
      this.stack = reason.stack;
    }
    this.reason = this.message;
    this.fatal;
    this.line = position2.start.line;
    this.column = position2.start.column;
    this.position = position2;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.file;
    this.actual;
    this.expected;
    this.url;
    this.note;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;
function core(value, options) {
  value = value.replace(
    options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g,
    basic
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    basic
  );
  function surrogate(pair, index2, all2) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all2.charCodeAt(index2 + 2),
      options
    );
  }
  function basic(character, index2, all2) {
    return options.format(
      character.charCodeAt(0),
      all2.charCodeAt(index2 + 1),
      options
    );
  }
}
function charactersToExpression(subset) {
  const groups = [];
  let index2 = -1;
  while (++index2 < subset.length) {
    groups.push(subset[index2].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}
function formatBasic(code2) {
  return "&#x" + code2.toString(16).toUpperCase() + ";";
}
function stringifyEntitiesLight(value, options) {
  return core(value, Object.assign({ format: formatBasic }, options));
}
const indent = "  ";
function mdxJsxFromMarkdown() {
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: enterMdxJsxTag,
      mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagAttributeValueLiteral: buffer,
      mdxJsxFlowTagAttributeValueExpression: buffer,
      mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: enterMdxJsxTag,
      mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxTextTagAttributeValueLiteral: buffer,
      mdxJsxTextTagAttributeValueExpression: buffer,
      mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker
    },
    exit: {
      mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagExpressionAttributeValue: data,
      mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxFlowTagAttributeValueLiteralValue: data,
      mdxJsxFlowTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxFlowTagAttributeValueExpressionValue: data,
      mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxFlowTag: exitMdxJsxTag,
      mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxTextTagExpressionAttributeValue: data,
      mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxTextTagAttributeValueLiteralValue: data,
      mdxJsxTextTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxTextTagAttributeValueExpressionValue: data,
      mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: exitMdxJsxTag
    }
  };
  function buffer() {
    this.buffer();
  }
  function data(token) {
    this.config.enter.data.call(this, token);
    this.config.exit.data.call(this, token);
  }
  function enterMdxJsxTag(token) {
    const tag = {
      name: void 0,
      attributes: [],
      close: false,
      selfClosing: false,
      start: token.start,
      end: token.end
    };
    if (!this.getData("mdxJsxTagStack"))
      this.setData("mdxJsxTagStack", []);
    this.setData("mdxJsxTag", tag);
    this.buffer();
  }
  function enterMdxJsxTagClosingMarker(token) {
    const stack = (
      /** @type {Array<Tag>} */
      this.getData("mdxJsxTagStack")
    );
    if (stack.length === 0) {
      throw new VFileMessage(
        "Unexpected closing slash `/` in tag, expected an open tag first",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-closing-slash"
      );
    }
  }
  function enterMdxJsxTagAnyAttribute(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    if (tag.close) {
      throw new VFileMessage(
        "Unexpected attribute in closing tag, expected the end of the tag",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-attribute"
      );
    }
  }
  function enterMdxJsxTagSelfClosingMarker(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    if (tag.close) {
      throw new VFileMessage(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash"
      );
    }
  }
  function exitMdxJsxTagClosingMarker() {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.close = true;
  }
  function exitMdxJsxTagNamePrimary(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.name = this.sliceSerialize(token);
  }
  function exitMdxJsxTagNameMember(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.name += "." + this.sliceSerialize(token);
  }
  function exitMdxJsxTagNameLocal(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.name += ":" + this.sliceSerialize(token);
  }
  function enterMdxJsxTagAttribute(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    enterMdxJsxTagAnyAttribute.call(this, token);
    tag.attributes.push({ type: "mdxJsxAttribute", name: "", value: null });
  }
  function enterMdxJsxTagExpressionAttribute(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    enterMdxJsxTagAnyAttribute.call(this, token);
    tag.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" });
    this.buffer();
  }
  function exitMdxJsxTagExpressionAttribute(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const tail = (
      /** @type {MdxJsxExpressionAttribute} */
      tag.attributes[tag.attributes.length - 1]
    );
    const estree = token.estree;
    tail.value = this.resume();
    if (estree) {
      tail.data = { estree };
    }
  }
  function exitMdxJsxTagAttributeNamePrimary(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const node2 = (
      /** @type {MdxJsxAttribute} */
      tag.attributes[tag.attributes.length - 1]
    );
    node2.name = this.sliceSerialize(token);
  }
  function exitMdxJsxTagAttributeNameLocal(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const node2 = (
      /** @type {MdxJsxAttribute} */
      tag.attributes[tag.attributes.length - 1]
    );
    node2.name += ":" + this.sliceSerialize(token);
  }
  function exitMdxJsxTagAttributeValueLiteral() {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.attributes[tag.attributes.length - 1].value = parseEntities(
      this.resume(),
      { nonTerminated: false }
    );
  }
  function exitMdxJsxTagAttributeValueExpression(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const tail = (
      /** @type {MdxJsxAttribute} */
      tag.attributes[tag.attributes.length - 1]
    );
    const node2 = { type: "mdxJsxAttributeValueExpression", value: this.resume() };
    const estree = token.estree;
    if (estree) {
      node2.data = { estree };
    }
    tail.value = node2;
  }
  function exitMdxJsxTagSelfClosingMarker() {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.selfClosing = true;
  }
  function exitMdxJsxTag(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const stack = (
      /** @type {Array<Tag>} */
      this.getData("mdxJsxTagStack")
    );
    const tail = stack[stack.length - 1];
    if (tag.close && tail.name !== tag.name) {
      throw new VFileMessage(
        "Unexpected closing tag `" + serializeAbbreviatedTag(tag) + "`, expected corresponding closing tag for `" + serializeAbbreviatedTag(tail) + "` (" + stringifyPosition(tail) + ")",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    }
    this.resume();
    if (tag.close) {
      stack.pop();
    } else {
      this.enter(
        {
          type: token.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
          name: tag.name || null,
          attributes: tag.attributes,
          children: []
        },
        token,
        onErrorRightIsTag
      );
    }
    if (tag.selfClosing || tag.close) {
      this.exit(token, onErrorLeftIsTag);
    } else {
      stack.push(tag);
    }
  }
  function onErrorRightIsTag(closing, open) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const place = closing ? " before the end of `" + closing.type + "`" : "";
    const position2 = closing ? { start: closing.start, end: closing.end } : void 0;
    throw new VFileMessage(
      "Expected a closing tag for `" + serializeAbbreviatedTag(tag) + "` (" + stringifyPosition({ start: open.start, end: open.end }) + ")" + place,
      position2,
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function onErrorLeftIsTag(a2, b2) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    throw new VFileMessage(
      "Expected the closing tag `" + serializeAbbreviatedTag(tag) + "` either after the end of `" + b2.type + "` (" + stringifyPosition(b2.end) + ") or another opening tag after the start of `" + b2.type + "` (" + stringifyPosition(b2.start) + ")",
      { start: a2.start, end: a2.end },
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function serializeAbbreviatedTag(tag) {
    return "<" + (tag.close ? "/" : "") + (tag.name || "") + ">";
  }
}
function mdxJsxToMarkdown(options) {
  const options_ = options || {};
  const quote = options_.quote || '"';
  const quoteSmart = options_.quoteSmart || false;
  const tightSelfClosing = options_.tightSelfClosing || false;
  const printWidth = options_.printWidth || Number.POSITIVE_INFINITY;
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error(
      "Cannot serialize attribute values with `" + quote + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  mdxElement.peek = peekElement;
  return {
    handlers: {
      mdxJsxFlowElement: mdxElement,
      mdxJsxTextElement: mdxElement
    },
    unsafe: [
      { character: "<", inConstruct: ["phrasing"] },
      { atBreak: true, character: "<" }
    ],
    // Always generate fenced code (never indented code).
    fences: true,
    // Always generate links with resources (never autolinks).
    resourceLink: true
  };
  function mdxElement(node2, _, context, safeOptions) {
    const flow2 = node2.type === "mdxJsxFlowElement";
    const selfClosing = node2.name ? !node2.children || node2.children.length === 0 : false;
    const depth = inferDepth(context);
    const currentIndent = createIndent(depth);
    const trackerOneLine = track(safeOptions);
    const trackerMultiLine = track(safeOptions);
    const serializedAttributes = [];
    const prefix = (flow2 ? currentIndent : "") + "<" + (node2.name || "");
    const exit2 = context.enter(node2.type);
    trackerOneLine.move(prefix);
    trackerMultiLine.move(prefix);
    if (node2.attributes && node2.attributes.length > 0) {
      if (!node2.name) {
        throw new Error("Cannot serialize fragment w/ attributes");
      }
      let index2 = -1;
      while (++index2 < node2.attributes.length) {
        const attribute = node2.attributes[index2];
        let result;
        if (attribute.type === "mdxJsxExpressionAttribute") {
          result = "{" + (attribute.value || "") + "}";
        } else {
          if (!attribute.name) {
            throw new Error("Cannot serialize attribute w/o name");
          }
          const value2 = attribute.value;
          const left = attribute.name;
          let right = "";
          if (value2 === void 0 || value2 === null)
            ;
          else if (typeof value2 === "object") {
            right = "{" + (value2.value || "") + "}";
          } else {
            const appliedQuote = quoteSmart && ccount(value2, quote) > ccount(value2, alternative) ? alternative : quote;
            right = appliedQuote + stringifyEntitiesLight(value2, { subset: [appliedQuote] }) + appliedQuote;
          }
          result = left + (right ? "=" : "") + right;
        }
        serializedAttributes.push(result);
      }
    }
    let attributesOnTheirOwnLine = false;
    const attributesOnOneLine = serializedAttributes.join(" ");
    if (
      // Block:
      flow2 && // Including a line ending (expressions).
      (/\r?\n|\r/.test(attributesOnOneLine) || // Current position (including `<tag`).
      trackerOneLine.current().now.column + // -1 because columns, +1 for ` ` before attributes.
      // Attributes joined by spaces.
      attributesOnOneLine.length + // ` />`.
      (selfClosing ? tightSelfClosing ? 2 : 3 : 1) > printWidth)
    ) {
      attributesOnTheirOwnLine = true;
    }
    let tracker = trackerOneLine;
    let value = prefix;
    if (attributesOnTheirOwnLine) {
      tracker = trackerMultiLine;
      let index2 = -1;
      while (++index2 < serializedAttributes.length) {
        serializedAttributes[index2] = currentIndent + indent + serializedAttributes[index2];
      }
      value += tracker.move(
        "\n" + serializedAttributes.join("\n") + "\n" + currentIndent
      );
    } else if (attributesOnOneLine) {
      value += tracker.move(" " + attributesOnOneLine);
    }
    if (selfClosing) {
      value += tracker.move(
        (tightSelfClosing || attributesOnTheirOwnLine ? "" : " ") + "/"
      );
    }
    value += tracker.move(">");
    if (node2.children && node2.children.length > 0) {
      if (node2.type === "mdxJsxTextElement") {
        value += tracker.move(
          containerPhrasing(node2, context, {
            ...tracker.current(),
            before: ">",
            after: "<"
          })
        );
      } else {
        tracker.shift(2);
        value += tracker.move("\n");
        value += tracker.move(containerFlow(node2, context, tracker.current()));
        value += tracker.move("\n");
      }
    }
    if (!selfClosing) {
      value += tracker.move(
        (flow2 ? currentIndent : "") + "</" + (node2.name || "") + ">"
      );
    }
    exit2();
    return value;
  }
}
function containerFlow(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children;
  const tracker = state.createTracker(info);
  const currentIndent = createIndent(inferDepth(state));
  const results = [];
  let index2 = -1;
  indexStack.push(-1);
  while (++index2 < children.length) {
    const child = children[index2];
    indexStack[indexStack.length - 1] = index2;
    const childInfo = { before: "\n", after: "\n", ...tracker.current() };
    const result = state.handle(child, parent, state, childInfo);
    const serializedChild = child.type === "mdxJsxFlowElement" ? result : indentLines(result, function(line, _, blank) {
      return (blank ? "" : currentIndent) + line;
    });
    results.push(tracker.move(serializedChild));
    if (child.type !== "list") {
      state.bulletLastUsed = void 0;
    }
    if (index2 < children.length - 1) {
      results.push(tracker.move("\n\n"));
    }
  }
  indexStack.pop();
  return results.join("");
}
function inferDepth(context) {
  let depth = 0;
  for (const x3 of context.stack) {
    if (x3 === "mdxJsxFlowElement") {
      depth++;
    }
  }
  return depth;
}
function createIndent(depth) {
  return indent.repeat(depth);
}
function peekElement() {
  return "<";
}
const start$1 = /[$A-Z_a-z\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
const cont$1 = /[\d\u00B7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F]/;
function start(code2) {
  return start$1.test(String.fromCharCode(code2));
}
function cont(code2) {
  const character = String.fromCharCode(code2);
  return start$1.test(character) || cont$1.test(character);
}
function color(d2) {
  return d2;
}
const own = {}.hasOwnProperty;
const CONTINUE = Symbol("continue");
const EXIT = Symbol("exit");
const SKIP = Symbol("skip");
function visit(tree, visitor) {
  let enter;
  let leave;
  if (typeof visitor === "function") {
    enter = visitor;
  } else if (visitor && typeof visitor === "object") {
    if (visitor.enter)
      enter = visitor.enter;
    if (visitor.leave)
      leave = visitor.leave;
  }
  build(tree, null, null, [])();
  function build(node2, key, index2, parents) {
    if (nodelike(node2)) {
      visit2.displayName = "node (" + color(node2.type) + ")";
    }
    return visit2;
    function visit2() {
      const result = enter ? toResult(enter(node2, key, index2, parents)) : [];
      if (result[0] === EXIT) {
        return result;
      }
      if (result[0] !== SKIP) {
        let cKey;
        for (cKey in node2) {
          if (own.call(node2, cKey) && node2[cKey] && typeof node2[cKey] === "object" && // @ts-expect-error: custom esast extension.
          cKey !== "data" && // @ts-expect-error: custom esast extension.
          cKey !== "position") {
            const grandparents = parents.concat(node2);
            const value = node2[cKey];
            if (Array.isArray(value)) {
              const nodes = (
                /** @type {Array<unknown>} */
                value
              );
              let cIndex = 0;
              while (cIndex > -1 && cIndex < nodes.length) {
                const subvalue = nodes[cIndex];
                if (nodelike(subvalue)) {
                  const subresult = build(
                    subvalue,
                    cKey,
                    cIndex,
                    grandparents
                  )();
                  if (subresult[0] === EXIT)
                    return subresult;
                  cIndex = typeof subresult[1] === "number" ? subresult[1] : cIndex + 1;
                } else {
                  cIndex++;
                }
              }
            } else if (nodelike(value)) {
              const subresult = build(value, cKey, null, grandparents)();
              if (subresult[0] === EXIT)
                return subresult;
            }
          }
        }
      }
      return leave ? toResult(leave(node2, key, index2, parents)) : result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}
function nodelike(value) {
  return Boolean(
    value && typeof value === "object" && "type" in value && typeof value.type === "string" && value.type.length > 0
  );
}
function eventsToAcorn(events, options) {
  const prefix = options.prefix || "";
  const suffix = options.suffix || "";
  const acornOptions = Object.assign({}, options.acornOptions);
  const comments = [];
  const tokens = [];
  const onComment = acornOptions.onComment;
  const onToken = acornOptions.onToken;
  let swallow = false;
  let estree;
  let exception;
  const acornConfig = Object.assign({}, acornOptions, {
    onComment: comments,
    preserveParens: true
  });
  if (onToken) {
    acornConfig.onToken = tokens;
  }
  const collection = collect(events, [
    "lineEnding",
    // To do: these should be passed by users in parameters.
    "expressionChunk",
    // From tests.
    "mdxFlowExpressionChunk",
    // Flow chunk.
    "mdxTextExpressionChunk",
    // Text chunk.
    // JSX:
    "mdxJsxTextTagExpressionAttributeValue",
    "mdxJsxTextTagAttributeValueExpressionValue",
    "mdxJsxFlowTagExpressionAttributeValue",
    "mdxJsxFlowTagAttributeValueExpressionValue",
    // ESM:
    "mdxjsEsmData"
  ]);
  const source = collection.value;
  const value = prefix + source + suffix;
  const isEmptyExpression = options.expression && empty(source);
  if (isEmptyExpression && !options.allowEmpty) {
    throw new VFileMessage(
      "Unexpected empty expression",
      parseOffsetToUnistPoint(0),
      "micromark-extension-mdx-expression:unexpected-empty-expression"
    );
  }
  try {
    estree = options.expression && !isEmptyExpression ? options.acorn.parseExpressionAt(value, 0, acornConfig) : options.acorn.parse(value, acornConfig);
  } catch (error_) {
    const error = (
      /** @type {AcornError} */
      error_
    );
    const point2 = parseOffsetToUnistPoint(error.pos);
    error.message = String(error.message).replace(/ \(\d+:\d+\)$/, "");
    error.pos = point2.offset;
    error.loc = {
      line: point2.line,
      column: point2.column - 1
    };
    exception = error;
    swallow = error.raisedAt >= prefix.length + source.length || // Broken comments are raised at their start, not their end.
    error.message === "Unterminated comment";
  }
  if (estree && options.expression && !isEmptyExpression) {
    if (empty(value.slice(estree.end, value.length - suffix.length))) {
      estree = {
        type: "Program",
        start: 0,
        end: prefix.length + source.length,
        // @ts-expect-error: It’s good.
        body: [
          {
            type: "ExpressionStatement",
            expression: estree,
            start: 0,
            end: prefix.length + source.length
          }
        ],
        sourceType: "module",
        comments: []
      };
    } else {
      const point2 = parseOffsetToUnistPoint(estree.end);
      const error = (
        /** @type {AcornError} */
        new Error("Unexpected content after expression")
      );
      error.pos = point2.offset;
      error.loc = {
        line: point2.line,
        column: point2.column - 1
      };
      exception = error;
      estree = void 0;
    }
  }
  if (estree) {
    estree.comments = comments;
    visit(estree, (esnode, field, index2, parents) => {
      let context = (
        /** @type {AcornNode | Array<AcornNode>} */
        parents[parents.length - 1]
      );
      let prop = field;
      if (esnode.type === "ParenthesizedExpression" && context && prop) {
        if (typeof index2 === "number") {
          context = context[prop];
          prop = index2;
        }
        context[prop] = esnode.expression;
      }
      fixPosition(esnode);
    });
    if (Array.isArray(onComment)) {
      onComment.push(...comments);
    } else if (typeof onComment === "function") {
      for (const comment of comments) {
        onComment(
          comment.type === "Block",
          comment.value,
          comment.start,
          comment.end,
          comment.loc.start,
          comment.loc.end
        );
      }
    }
    for (const token of tokens) {
      if (token.end <= prefix.length || token.start - prefix.length >= source.length) {
        continue;
      }
      fixPosition(token);
      if (Array.isArray(onToken)) {
        onToken.push(token);
      } else {
        onToken(token);
      }
    }
  }
  return {
    estree,
    error: exception,
    swallow
  };
  function fixPosition(nodeOrToken) {
    const pointStart = parseOffsetToUnistPoint(nodeOrToken.start);
    const pointEnd = parseOffsetToUnistPoint(nodeOrToken.end);
    nodeOrToken.start = pointStart.offset;
    nodeOrToken.end = pointEnd.offset;
    nodeOrToken.loc = {
      start: {
        line: pointStart.line,
        column: pointStart.column - 1,
        offset: pointStart.offset
      },
      end: {
        line: pointEnd.line,
        column: pointEnd.column - 1,
        offset: pointEnd.offset
      }
    };
    nodeOrToken.range = [nodeOrToken.start, nodeOrToken.end];
  }
  function parseOffsetToUnistPoint(acornOffset) {
    let sourceOffset = acornOffset - prefix.length;
    if (sourceOffset < 0) {
      sourceOffset = 0;
    } else if (sourceOffset > source.length) {
      sourceOffset = source.length;
    }
    let point2 = relativeToPoint(collection.stops, sourceOffset);
    if (!point2) {
      point2 = {
        line: options.start.line,
        column: options.start.column,
        offset: options.start.offset
      };
    }
    return point2;
  }
}
function empty(value) {
  return /^\s*$/.test(
    value.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, "")
  );
}
function collect(events, names) {
  const result = {
    value: "",
    stops: []
  };
  let index2 = -1;
  while (++index2 < events.length) {
    const event = events[index2];
    if (event[0] === "enter" && names.includes(event[1].type)) {
      const chunks = event[2].sliceStream(event[1]);
      while (chunks.length > 0 && chunks[0] === -1) {
        chunks.shift();
      }
      const value = serializeChunks(chunks);
      result.stops.push([result.value.length, event[1].start]);
      result.value += value;
      result.stops.push([result.value.length, event[1].end]);
    }
  }
  return result;
}
function relativeToPoint(stops, relative) {
  let index2 = 0;
  while (index2 < stops.length && stops[index2][0] <= relative) {
    index2 += 1;
  }
  if (index2 === 0) {
    return void 0;
  }
  const [stopRelative, stopAbsolute] = stops[index2 - 1];
  const rest = relative - stopRelative;
  return {
    line: stopAbsolute.line,
    column: stopAbsolute.column + rest,
    offset: stopAbsolute.offset + rest
  };
}
function serializeChunks(chunks) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = "	";
          break;
        }
        case -1: {
          if (atTab)
            continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}
function positionFromEstree(node2) {
  const nodeLike = node2 || {};
  const loc = nodeLike.loc || {};
  const range = nodeLike.range || [0, 0];
  const startColumn = loc.start ? numberOrUndefined(loc.start.column) : void 0;
  const endColumn = loc.end ? numberOrUndefined(loc.end.column) : void 0;
  return {
    start: {
      // @ts-expect-error: return no point / no position next major.
      line: loc.start ? numberOrUndefined(loc.start.line) : void 0,
      // @ts-expect-error: return no point / no position next major.
      column: startColumn === void 0 ? void 0 : startColumn + 1,
      offset: numberOrUndefined(range[0] || nodeLike.start)
    },
    end: {
      // @ts-expect-error: return no point / no position next major.
      line: loc.end ? numberOrUndefined(loc.end.line) : void 0,
      // @ts-expect-error: return no point / no position next major.
      column: endColumn === void 0 ? void 0 : endColumn + 1,
      offset: numberOrUndefined(range[1] || nodeLike.end)
    }
  };
}
function numberOrUndefined(value) {
  return typeof value === "number" && value > -1 ? value : void 0;
}
function factoryMdxExpression(effects, ok2, type, markerType, chunkType, acorn, acornOptions, addResult, spread, allowEmpty, allowLazy) {
  const self2 = this;
  const eventStart = this.events.length + 3;
  let size = 0;
  let pointStart;
  let lastCrash;
  return start2;
  function start2(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    pointStart = self2.now();
    return before;
  }
  function before(code2) {
    if (code2 === null) {
      throw lastCrash || new VFileMessage(
        "Unexpected end of file in expression, expected a corresponding closing brace for `{`",
        self2.now(),
        "micromark-extension-mdx-expression:unexpected-eof"
      );
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return eolAfter;
    }
    if (code2 === 125 && size === 0) {
      const next = acorn ? mdxExpressionParse.call(
        self2,
        acorn,
        acornOptions,
        eventStart,
        pointStart,
        allowEmpty || false,
        spread || false
      ) : {
        type: "ok",
        estree: void 0
      };
      if (next.type === "ok") {
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        const token = effects.exit(type);
        if (addResult && next.estree) {
          Object.assign(token, {
            estree: next.estree
          });
        }
        return ok2;
      }
      lastCrash = next.message;
      effects.enter(chunkType);
      effects.consume(code2);
      return inside;
    }
    effects.enter(chunkType);
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === 125 && size === 0 || code2 === null || markdownLineEnding(code2)) {
      effects.exit(chunkType);
      return before(code2);
    }
    if (code2 === 123 && !acorn) {
      size += 1;
    } else if (code2 === 125) {
      size -= 1;
    }
    effects.consume(code2);
    return inside;
  }
  function eolAfter(code2) {
    const now = self2.now();
    if (now.line !== pointStart.line && !allowLazy && self2.parser.lazy[now.line]) {
      throw new VFileMessage(
        "Unexpected end of file in expression, expected a corresponding closing brace for `{`",
        self2.now(),
        "micromark-extension-mdx-expression:unexpected-eof"
      );
    }
    return before(code2);
  }
}
function mdxExpressionParse(acorn, acornOptions, eventStart, pointStart, allowEmpty, spread) {
  const result = eventsToAcorn(this.events.slice(eventStart), {
    acorn,
    acornOptions,
    start: pointStart,
    expression: true,
    allowEmpty,
    prefix: spread ? "({" : "",
    suffix: spread ? "})" : ""
  });
  const estree = result.estree;
  if (spread && estree) {
    const head = estree.body[0];
    if (head.type !== "ExpressionStatement" || head.expression.type !== "ObjectExpression") {
      throw new VFileMessage(
        "Unexpected `" + head.type + "` in code: expected an object spread (`{...spread}`)",
        positionFromEstree(head).start,
        "micromark-extension-mdx-expression:non-spread"
      );
    } else if (head.expression.properties[1]) {
      throw new VFileMessage(
        "Unexpected extra content in spread: only a single spread is supported",
        positionFromEstree(head.expression.properties[1]).start,
        "micromark-extension-mdx-expression:spread-extra"
      );
    } else if (head.expression.properties[0] && head.expression.properties[0].type !== "SpreadElement") {
      throw new VFileMessage(
        "Unexpected `" + head.expression.properties[0].type + "` in code: only spread elements are supported",
        positionFromEstree(head.expression.properties[0]).start,
        "micromark-extension-mdx-expression:non-spread"
      );
    }
  }
  if (result.error) {
    return {
      type: "nok",
      message: new VFileMessage(
        "Could not parse expression with acorn: " + result.error.message,
        {
          line: result.error.loc.line,
          column: result.error.loc.column + 1,
          offset: result.error.pos
        },
        "micromark-extension-mdx-expression:acorn"
      )
    };
  }
  return {
    type: "ok",
    estree
  };
}
function factoryTag(effects, ok2, nok, acorn, acornOptions, addResult, allowLazy, tagType, tagMarkerType, tagClosingMarkerType, tagSelfClosingMarker, tagNameType, tagNamePrimaryType, tagNameMemberMarkerType, tagNameMemberType, tagNamePrefixMarkerType, tagNameLocalType, tagExpressionAttributeType, tagExpressionAttributeMarkerType, tagExpressionAttributeValueType, tagAttributeType, tagAttributeNameType, tagAttributeNamePrimaryType, tagAttributeNamePrefixMarkerType, tagAttributeNameLocalType, tagAttributeInitializerMarkerType, tagAttributeValueLiteralType, tagAttributeValueLiteralMarkerType, tagAttributeValueLiteralValueType, tagAttributeValueExpressionType, tagAttributeValueExpressionMarkerType, tagAttributeValueExpressionValueType) {
  const self2 = this;
  let returnState;
  let marker;
  return start$12;
  function start$12(code2) {
    effects.enter(tagType);
    effects.enter(tagMarkerType);
    effects.consume(code2);
    effects.exit(tagMarkerType);
    return startAfter;
  }
  function startAfter(code2) {
    if (markdownLineEndingOrSpace(code2)) {
      return nok(code2);
    }
    returnState = nameBefore;
    return esWhitespaceStart(code2);
  }
  function nameBefore(code2) {
    if (code2 === 47) {
      effects.enter(tagClosingMarkerType);
      effects.consume(code2);
      effects.exit(tagClosingMarkerType);
      returnState = closingTagNameBefore;
      return esWhitespaceStart;
    }
    if (code2 === 62) {
      return tagEnd(code2);
    }
    if (code2 !== null && start(code2)) {
      effects.enter(tagNameType);
      effects.enter(tagNamePrimaryType);
      effects.consume(code2);
      return primaryName;
    }
    crash(
      code2,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code2 === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : "")
    );
  }
  function closingTagNameBefore(code2) {
    if (code2 === 62) {
      return tagEnd(code2);
    }
    if (code2 !== null && start(code2)) {
      effects.enter(tagNameType);
      effects.enter(tagNamePrimaryType);
      effects.consume(code2);
      return primaryName;
    }
    crash(
      code2,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code2 === 42 || code2 === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function primaryName(code2) {
    if (code2 === 45 || code2 !== null && cont(code2)) {
      effects.consume(code2);
      return primaryName;
    }
    if (code2 === 46 || code2 === 47 || code2 === 58 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      effects.exit(tagNamePrimaryType);
      returnState = primaryNameAfter;
      return esWhitespaceStart(code2);
    }
    crash(
      code2,
      "in name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code2 === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function primaryNameAfter(code2) {
    if (code2 === 46) {
      effects.enter(tagNameMemberMarkerType);
      effects.consume(code2);
      effects.exit(tagNameMemberMarkerType);
      returnState = memberNameBefore;
      return esWhitespaceStart;
    }
    if (code2 === 58) {
      effects.enter(tagNamePrefixMarkerType);
      effects.consume(code2);
      effects.exit(tagNamePrefixMarkerType);
      returnState = localNameBefore;
      return esWhitespaceStart;
    }
    if (code2 === 47 || code2 === 62 || code2 === 123 || code2 !== null && start(code2)) {
      effects.exit(tagNameType);
      return attributeBefore(code2);
    }
    crash(
      code2,
      "after name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function memberNameBefore(code2) {
    if (code2 !== null && start(code2)) {
      effects.enter(tagNameMemberType);
      effects.consume(code2);
      return memberName;
    }
    crash(
      code2,
      "before member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function memberName(code2) {
    if (code2 === 45 || code2 !== null && cont(code2)) {
      effects.consume(code2);
      return memberName;
    }
    if (code2 === 46 || code2 === 47 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      effects.exit(tagNameMemberType);
      returnState = memberNameAfter;
      return esWhitespaceStart(code2);
    }
    crash(
      code2,
      "in member name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code2 === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function memberNameAfter(code2) {
    if (code2 === 46) {
      effects.enter(tagNameMemberMarkerType);
      effects.consume(code2);
      effects.exit(tagNameMemberMarkerType);
      returnState = memberNameBefore;
      return esWhitespaceStart;
    }
    if (code2 === 47 || code2 === 62 || code2 === 123 || code2 !== null && start(code2)) {
      effects.exit(tagNameType);
      return attributeBefore(code2);
    }
    crash(
      code2,
      "after member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function localNameBefore(code2) {
    if (code2 !== null && start(code2)) {
      effects.enter(tagNameLocalType);
      effects.consume(code2);
      return localName;
    }
    crash(
      code2,
      "before local name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code2 === 43 || code2 !== null && code2 > 46 && code2 < 58 ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function localName(code2) {
    if (code2 === 45 || code2 !== null && cont(code2)) {
      effects.consume(code2);
      return localName;
    }
    if (code2 === 47 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      effects.exit(tagNameLocalType);
      returnState = localNameAfter;
      return esWhitespaceStart(code2);
    }
    crash(
      code2,
      "in local name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function localNameAfter(code2) {
    if (code2 === 47 || code2 === 62 || code2 === 123 || code2 !== null && start(code2)) {
      effects.exit(tagNameType);
      return attributeBefore(code2);
    }
    crash(
      code2,
      "after local name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeBefore(code2) {
    if (code2 === 47) {
      effects.enter(tagSelfClosingMarker);
      effects.consume(code2);
      effects.exit(tagSelfClosingMarker);
      returnState = selfClosing;
      return esWhitespaceStart;
    }
    if (code2 === 62) {
      return tagEnd(code2);
    }
    if (code2 === 123) {
      return factoryMdxExpression.call(
        self2,
        effects,
        attributeExpressionAfter,
        tagExpressionAttributeType,
        tagExpressionAttributeMarkerType,
        tagExpressionAttributeValueType,
        acorn,
        acornOptions,
        addResult,
        true,
        false,
        allowLazy
      )(code2);
    }
    if (code2 !== null && start(code2)) {
      effects.enter(tagAttributeType);
      effects.enter(tagAttributeNameType);
      effects.enter(tagAttributeNamePrimaryType);
      effects.consume(code2);
      return attributePrimaryName;
    }
    crash(
      code2,
      "before attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeExpressionAfter(code2) {
    returnState = attributeBefore;
    return esWhitespaceStart(code2);
  }
  function attributePrimaryName(code2) {
    if (code2 === 45 || code2 !== null && cont(code2)) {
      effects.consume(code2);
      return attributePrimaryName;
    }
    if (code2 === 47 || code2 === 58 || code2 === 61 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      effects.exit(tagAttributeNamePrimaryType);
      returnState = attributePrimaryNameAfter;
      return esWhitespaceStart(code2);
    }
    crash(
      code2,
      "in attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function attributePrimaryNameAfter(code2) {
    if (code2 === 58) {
      effects.enter(tagAttributeNamePrefixMarkerType);
      effects.consume(code2);
      effects.exit(tagAttributeNamePrefixMarkerType);
      returnState = attributeLocalNameBefore;
      return esWhitespaceStart;
    }
    if (code2 === 61) {
      effects.exit(tagAttributeNameType);
      effects.enter(tagAttributeInitializerMarkerType);
      effects.consume(code2);
      effects.exit(tagAttributeInitializerMarkerType);
      returnState = attributeValueBefore;
      return esWhitespaceStart;
    }
    if (code2 === 47 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== null && start(code2)) {
      effects.exit(tagAttributeNameType);
      effects.exit(tagAttributeType);
      returnState = attributeBefore;
      return esWhitespaceStart(code2);
    }
    crash(
      code2,
      "after attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeLocalNameBefore(code2) {
    if (code2 !== null && start(code2)) {
      effects.enter(tagAttributeNameLocalType);
      effects.consume(code2);
      return attributeLocalName;
    }
    crash(
      code2,
      "before local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeLocalName(code2) {
    if (code2 === 45 || code2 !== null && cont(code2)) {
      effects.consume(code2);
      return attributeLocalName;
    }
    if (code2 === 47 || code2 === 61 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      effects.exit(tagAttributeNameLocalType);
      effects.exit(tagAttributeNameType);
      returnState = attributeLocalNameAfter;
      return esWhitespaceStart(code2);
    }
    crash(
      code2,
      "in local attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeLocalNameAfter(code2) {
    if (code2 === 61) {
      effects.enter(tagAttributeInitializerMarkerType);
      effects.consume(code2);
      effects.exit(tagAttributeInitializerMarkerType);
      returnState = attributeValueBefore;
      return esWhitespaceStart;
    }
    if (code2 === 47 || code2 === 62 || code2 === 123 || code2 !== null && start(code2)) {
      effects.exit(tagAttributeType);
      return attributeBefore(code2);
    }
    crash(
      code2,
      "after local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeValueBefore(code2) {
    if (code2 === 34 || code2 === 39) {
      effects.enter(tagAttributeValueLiteralType);
      effects.enter(tagAttributeValueLiteralMarkerType);
      effects.consume(code2);
      effects.exit(tagAttributeValueLiteralMarkerType);
      marker = code2;
      return attributeValueQuotedStart;
    }
    if (code2 === 123) {
      return factoryMdxExpression.call(
        self2,
        effects,
        attributeValueExpressionAfter,
        tagAttributeValueExpressionType,
        tagAttributeValueExpressionMarkerType,
        tagAttributeValueExpressionValueType,
        acorn,
        acornOptions,
        addResult,
        false,
        false,
        allowLazy
      )(code2);
    }
    crash(
      code2,
      "before attribute value",
      "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (code2 === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : "")
    );
  }
  function attributeValueExpressionAfter(code2) {
    effects.exit(tagAttributeType);
    returnState = attributeBefore;
    return esWhitespaceStart(code2);
  }
  function attributeValueQuotedStart(code2) {
    if (code2 === null) {
      crash(
        code2,
        "in attribute value",
        "a corresponding closing quote `" + String.fromCodePoint(marker) + "`"
      );
    }
    if (code2 === marker) {
      effects.enter(tagAttributeValueLiteralMarkerType);
      effects.consume(code2);
      effects.exit(tagAttributeValueLiteralMarkerType);
      effects.exit(tagAttributeValueLiteralType);
      effects.exit(tagAttributeType);
      marker = void 0;
      returnState = attributeBefore;
      return esWhitespaceStart;
    }
    if (markdownLineEnding(code2)) {
      returnState = attributeValueQuotedStart;
      return esWhitespaceStart(code2);
    }
    effects.enter(tagAttributeValueLiteralValueType);
    return attributeValueQuoted(code2);
  }
  function attributeValueQuoted(code2) {
    if (code2 === null || code2 === marker || markdownLineEnding(code2)) {
      effects.exit(tagAttributeValueLiteralValueType);
      return attributeValueQuotedStart(code2);
    }
    effects.consume(code2);
    return attributeValueQuoted;
  }
  function selfClosing(code2) {
    if (code2 === 62) {
      return tagEnd(code2);
    }
    crash(
      code2,
      "after self-closing slash",
      "`>` to end the tag" + (code2 === 42 || code2 === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function tagEnd(code2) {
    effects.enter(tagMarkerType);
    effects.consume(code2);
    effects.exit(tagMarkerType);
    effects.exit(tagType);
    return ok2;
  }
  function esWhitespaceStart(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return esWhitespaceEolAfter;
    }
    if (markdownSpace(code2) || unicodeWhitespace(code2)) {
      effects.enter("esWhitespace");
      return esWhitespaceInside(code2);
    }
    return returnState(code2);
  }
  function esWhitespaceInside(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("esWhitespace");
      return esWhitespaceStart(code2);
    }
    if (markdownSpace(code2) || unicodeWhitespace(code2)) {
      effects.consume(code2);
      return esWhitespaceInside;
    }
    effects.exit("esWhitespace");
    return returnState(code2);
  }
  function esWhitespaceEolAfter(code2) {
    if (!allowLazy && self2.parser.lazy[self2.now().line]) {
      throw new VFileMessage(
        "Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        self2.now(),
        "micromark-extension-mdx-jsx:unexpected-eof"
      );
    }
    return esWhitespaceStart(code2);
  }
  function crash(code2, at, expect) {
    throw new VFileMessage(
      "Unexpected " + (code2 === null ? "end of file" : "character `" + (code2 === 96 ? "` ` `" : String.fromCodePoint(code2)) + "` (" + serializeCharCode(code2) + ")") + " " + at + ", expected " + expect,
      self2.now(),
      "micromark-extension-mdx-jsx:unexpected-" + (code2 === null ? "eof" : "character")
    );
  }
}
function serializeCharCode(code2) {
  return "U+" + code2.toString(16).toUpperCase().padStart(4, "0");
}
function jsxText(acorn, acornOptions, addResult) {
  return {
    tokenize: tokenizeJsxText
  };
  function tokenizeJsxText(effects, ok2, nok) {
    return factoryTag.call(
      this,
      effects,
      ok2,
      nok,
      acorn,
      acornOptions,
      addResult,
      true,
      "mdxJsxTextTag",
      "mdxJsxTextTagMarker",
      "mdxJsxTextTagClosingMarker",
      "mdxJsxTextTagSelfClosingMarker",
      "mdxJsxTextTagName",
      "mdxJsxTextTagNamePrimary",
      "mdxJsxTextTagNameMemberMarker",
      "mdxJsxTextTagNameMember",
      "mdxJsxTextTagNamePrefixMarker",
      "mdxJsxTextTagNameLocal",
      "mdxJsxTextTagExpressionAttribute",
      "mdxJsxTextTagExpressionAttributeMarker",
      "mdxJsxTextTagExpressionAttributeValue",
      "mdxJsxTextTagAttribute",
      "mdxJsxTextTagAttributeName",
      "mdxJsxTextTagAttributeNamePrimary",
      "mdxJsxTextTagAttributeNamePrefixMarker",
      "mdxJsxTextTagAttributeNameLocal",
      "mdxJsxTextTagAttributeInitializerMarker",
      "mdxJsxTextTagAttributeValueLiteral",
      "mdxJsxTextTagAttributeValueLiteralMarker",
      "mdxJsxTextTagAttributeValueLiteralValue",
      "mdxJsxTextTagAttributeValueExpression",
      "mdxJsxTextTagAttributeValueExpressionMarker",
      "mdxJsxTextTagAttributeValueExpressionValue"
    );
  }
}
function jsxFlow(acorn, acornOptions, addResult) {
  return {
    tokenize: tokenizeJsxFlow,
    concrete: true
  };
  function tokenizeJsxFlow(effects, ok2, nok) {
    const self2 = this;
    return start2;
    function start2(code2) {
      return before(code2);
    }
    function before(code2) {
      return factoryTag.call(
        self2,
        effects,
        after,
        nok,
        acorn,
        acornOptions,
        addResult,
        false,
        "mdxJsxFlowTag",
        "mdxJsxFlowTagMarker",
        "mdxJsxFlowTagClosingMarker",
        "mdxJsxFlowTagSelfClosingMarker",
        "mdxJsxFlowTagName",
        "mdxJsxFlowTagNamePrimary",
        "mdxJsxFlowTagNameMemberMarker",
        "mdxJsxFlowTagNameMember",
        "mdxJsxFlowTagNamePrefixMarker",
        "mdxJsxFlowTagNameLocal",
        "mdxJsxFlowTagExpressionAttribute",
        "mdxJsxFlowTagExpressionAttributeMarker",
        "mdxJsxFlowTagExpressionAttributeValue",
        "mdxJsxFlowTagAttribute",
        "mdxJsxFlowTagAttributeName",
        "mdxJsxFlowTagAttributeNamePrimary",
        "mdxJsxFlowTagAttributeNamePrefixMarker",
        "mdxJsxFlowTagAttributeNameLocal",
        "mdxJsxFlowTagAttributeInitializerMarker",
        "mdxJsxFlowTagAttributeValueLiteral",
        "mdxJsxFlowTagAttributeValueLiteralMarker",
        "mdxJsxFlowTagAttributeValueLiteralValue",
        "mdxJsxFlowTagAttributeValueExpression",
        "mdxJsxFlowTagAttributeValueExpressionMarker",
        "mdxJsxFlowTagAttributeValueExpressionValue"
      )(code2);
    }
    function after(code2) {
      return markdownSpace(code2) ? factorySpace(effects, end, "whitespace")(code2) : end(code2);
    }
    function end(code2) {
      return code2 === 60 ? start2(code2) : code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
    }
  }
}
function mdxJsx(options) {
  const settings = options || {};
  const acorn = settings.acorn;
  let acornOptions;
  if (acorn) {
    if (!acorn.parse || !acorn.parseExpressionAt) {
      throw new Error(
        "Expected a proper `acorn` instance passed in as `options.acorn`"
      );
    }
    acornOptions = Object.assign(
      {
        ecmaVersion: 2020,
        sourceType: "module"
      },
      settings.acornOptions,
      {
        locations: true
      }
    );
  } else if (settings.acornOptions || settings.addResult) {
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  }
  return {
    flow: {
      [60]: jsxFlow(
        acorn || void 0,
        acornOptions,
        settings.addResult || false
      )
    },
    text: {
      [60]: jsxText(
        acorn || void 0,
        acornOptions,
        settings.addResult || false
      )
    }
  };
}
var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const TYPE_NAME = "generic-html";
class GenericHTMLNode extends Lexical_1.ElementNode {
  constructor(tag, type, attributes, key) {
    super(key);
    __publicField$2(this, "__tag");
    __publicField$2(this, "__nodeType");
    __publicField$2(this, "__attributes");
    this.__tag = tag;
    this.__nodeType = type;
    this.__attributes = attributes;
  }
  static getType() {
    return TYPE_NAME;
  }
  static clone(node2) {
    return new GenericHTMLNode(node2.__tag, node2.__nodeType, node2.__attributes, node2.__key);
  }
  getTag() {
    return this.__tag;
  }
  getNodeType() {
    return this.__nodeType;
  }
  getAttributes() {
    return this.__attributes;
  }
  updateAttributes(attributes) {
    const self2 = this.getWritable();
    self2.__attributes = attributes;
  }
  getStyle() {
    var _a;
    return (_a = this.__attributes.find((attribute) => attribute.name === "style")) == null ? void 0 : _a.value;
  }
  // View
  createDOM() {
    const tag = this.__tag;
    const element2 = document.createElement(tag);
    this.__attributes.forEach((attribute) => {
      element2.setAttribute(attribute.name, attribute.value);
    });
    return element2;
  }
  updateDOM() {
    return false;
  }
  static importDOM() {
    return {};
  }
  exportDOM(editor) {
    const { element: element2 } = super.exportDOM(editor);
    return {
      element: element2
    };
  }
  static importJSON(serializedNode) {
    const node2 = $createGenericHTMLNode(serializedNode.tag, serializedNode.mdxType, serializedNode.attributes);
    node2.setFormat(serializedNode.format);
    node2.setIndent(serializedNode.indent);
    node2.setDirection(serializedNode.direction);
    return node2;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      tag: this.getTag(),
      attributes: this.__attributes,
      mdxType: this.__nodeType,
      type: TYPE_NAME,
      version: 1
    };
  }
  /*
    // Mutation
    insertNewAfter(selection?: RangeSelection, restoreSelection = true): ParagraphNode | GenericHTMLNode {
      const anchorOffet = selection ? selection.anchor.offset : 0
      const newElement =
        anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : $createParagraphNode()
      const direction = this.getDirection()
      newElement.setDirection(direction)
      this.insertAfter(newElement, restoreSelection)
      return newElement
    }
  
    collapseAtStart(): true {
      const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode()
      const children = this.getChildren()
      children.forEach((child) => newElement.append(child))
      this.replace(newElement)
      return true
    }*/
  extractWithChild() {
    return true;
  }
  isInline() {
    return this.__nodeType === "mdxJsxTextElement";
  }
}
function $createGenericHTMLNode(tag, type, attributes) {
  return Lexical_1.$applyNodeReplacement(new GenericHTMLNode(tag, type, attributes));
}
function $isGenericHTMLNode(node2) {
  return node2 instanceof GenericHTMLNode;
}
const MdastHTMLVisitor = {
  testNode: isMdastHTMLNode,
  visitNode: function({ mdastNode, actions }) {
    actions.addAndStepInto($createGenericHTMLNode(mdastNode.name, mdastNode.type, mdastNode.attributes));
  },
  priority: -100
};
const LexicalGenericHTMLVisitor = {
  testLexicalNode: $isGenericHTMLNode,
  visitLexicalNode({ actions, lexicalNode }) {
    actions.addAndStepInto("mdxJsxTextElement", {
      name: lexicalNode.getTag(),
      type: lexicalNode.getNodeType(),
      attributes: lexicalNode.getAttributes()
    });
  },
  priority: -100
};
function uuidv4() {
  const hex = [...Array(256).keys()].map((index2) => index2.toString(16).padStart(2, "0"));
  const r2 = crypto.getRandomValues(new Uint8Array(16));
  r2[6] = r2[6] & 15 | 64;
  r2[8] = r2[8] & 63 | 128;
  return [...r2.entries()].map(([index2, int]) => [4, 6, 8, 10].includes(index2) ? `-${hex[int]}` : hex[int]).join("");
}
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function defaultComparator(current, next) {
  return current === next;
}
class SetMap {
  constructor() {
    __publicField$1(this, "map", /* @__PURE__ */ new Map());
  }
  getOrCreate(key) {
    let record = this.map.get(key);
    if (!record) {
      record = /* @__PURE__ */ new Set();
      this.map.set(key, record);
    }
    return record;
  }
  get(key) {
    return this.map.get(key);
  }
  use(key, cb2) {
    const set = this.get(key);
    if (set !== void 0) {
      cb2(set);
    }
  }
  delete(key) {
    return this.map.delete(key);
  }
}
class RefCount {
  constructor(map2 = /* @__PURE__ */ new Map()) {
    __publicField$1(this, "map");
    this.map = map2;
  }
  clone() {
    return new RefCount(new Map(this.map));
  }
  increment(key) {
    const counter = this.map.get(key) ?? 0;
    this.map.set(key, counter + 1);
  }
  decrement(key, ifZero) {
    let counter = this.map.get(key);
    if (counter !== void 0) {
      counter -= 1;
      this.map.set(key, counter);
      if (counter === 0) {
        ifZero();
      }
    }
  }
}
const NO_VALUE = Symbol("NO_VALUE");
function realm() {
  const subscriptions = new SetMap();
  const singletonSubscriptions = /* @__PURE__ */ new Map();
  const graph = new SetMap();
  const state = /* @__PURE__ */ new Map();
  const distinctNodes = /* @__PURE__ */ new Map();
  const labels = {};
  function node2(value = NO_VALUE, distinct = false) {
    const key = uuidv4();
    if (value !== NO_VALUE) {
      state.set(key, value);
    }
    if (distinct !== false) {
      distinctNodes.set(key, distinct === true ? defaultComparator : distinct);
    }
    return { key, toString: () => key };
  }
  function subSingle({ key }, subscription) {
    const nodeSubscriptions = subscriptions.getOrCreate(key);
    nodeSubscriptions.add(subscription);
    return () => nodeSubscriptions.delete(subscription);
  }
  function singletonSub({ key }, subscription) {
    if (!subscription) {
      singletonSubscriptions.delete(key);
    } else {
      singletonSubscriptions.set(key, subscription);
    }
    return () => singletonSubscriptions.delete(key);
  }
  function singletonSubKey(key, subscription) {
    return singletonSub(labels[key], subscription);
  }
  function resetSingletonSubs() {
    singletonSubscriptions.clear();
  }
  function subMultiple(sources, cb2) {
    const sink = node2();
    connect({
      map: (done) => (...args) => {
        done(args);
      },
      sink,
      sources
    });
    return subSingle(sink, cb2);
  }
  function sub(...args) {
    const [subscription] = args.slice(-1);
    const nodes = args.slice(0, -1);
    if (nodes.length === 1) {
      return subSingle(nodes[0], subscription);
    } else {
      return subMultiple(nodes, subscription);
    }
  }
  function calculateExecutionMap(keys) {
    const participatingNodeKeys = [];
    const visitedNodes = /* @__PURE__ */ new Set();
    const pendingPulls = new SetMap();
    const refCount = new RefCount();
    const projections = new SetMap();
    function visit2(key, insertIndex = 0) {
      refCount.increment(key);
      if (visitedNodes.has(key)) {
        return;
      }
      pendingPulls.use(key, (pulls) => {
        insertIndex = Math.max(...Array.from(pulls).map((key2) => participatingNodeKeys.indexOf(key2))) + 1;
      });
      graph.use(key, (sinkProjections) => {
        sinkProjections.forEach((projection) => {
          if (projection.sources.has(key)) {
            projections.getOrCreate(projection.sink).add(projection);
            visit2(projection.sink, insertIndex);
          } else {
            pendingPulls.getOrCreate(projection.sink).add(key);
          }
        });
      });
      visitedNodes.add(key);
      participatingNodeKeys.splice(insertIndex, 0, key);
    }
    keys.forEach((key) => visit2(key));
    return { participatingNodeKeys, pendingPulls, projections, refCount };
  }
  const executionMaps = /* @__PURE__ */ new Map();
  function pubIn(values) {
    var _a;
    const keys = Object.keys(values);
    const executionMapKey = keys.join(",");
    if (!executionMaps.has(executionMapKey)) {
      executionMaps.set(executionMapKey, calculateExecutionMap(keys));
    }
    const map22 = executionMaps.get(executionMapKey);
    const refCount = map22.refCount.clone();
    const participatingNodeKeys = map22.participatingNodeKeys.slice();
    const transientState = new Map(state);
    function nodeWillNotEmit(key) {
      graph.use(key, (projections) => {
        projections.forEach(({ sources, sink }) => {
          if (sources.has(key)) {
            refCount.decrement(sink, () => {
              participatingNodeKeys.splice(participatingNodeKeys.indexOf(sink), 1);
              nodeWillNotEmit(sink);
            });
          }
        });
      });
    }
    let nodeKey;
    while (nodeKey = participatingNodeKeys.shift()) {
      let resolved = false;
      const done = (value) => {
        if (distinctNodes.has(nodeKey) && distinctNodes.get(nodeKey)(state.get(nodeKey), value)) {
          resolved = false;
          return;
        }
        resolved = true;
        transientState.set(nodeKey, value);
        if (state.has(nodeKey)) {
          state.set(nodeKey, value);
        }
      };
      if (Object.prototype.hasOwnProperty.call(values, nodeKey)) {
        done(values[nodeKey]);
      } else {
        map22.projections.use(nodeKey, (nodeProjections) => {
          nodeProjections.forEach((projection) => {
            const args = [...Array.from(projection.sources), ...Array.from(projection.pulls)].map((id2) => transientState.get(id2));
            projection.map(done)(...args);
          });
        });
      }
      if (resolved) {
        const value = transientState.get(nodeKey);
        subscriptions.use(nodeKey, (nodeSubscriptions) => {
          nodeSubscriptions.forEach((subscription) => subscription(value));
        });
        (_a = singletonSubscriptions.get(nodeKey)) == null ? void 0 : _a(value);
      } else {
        nodeWillNotEmit(nodeKey);
      }
    }
  }
  function nodesToKeySet(nodes) {
    return new Set(nodes.map((s) => s.key));
  }
  function connect({ sources, pulls = [], map: map22, sink: { key: sink } }) {
    const dependency = {
      map: map22,
      pulls: nodesToKeySet(pulls),
      sink,
      sources: nodesToKeySet(sources)
    };
    [...sources, ...pulls].forEach(({ key: sourceKey }) => {
      graph.getOrCreate(sourceKey).add(dependency);
    });
    executionMaps.clear();
  }
  function pub(...args) {
    const map22 = {};
    for (let index2 = 0; index2 < args.length; index2 += 2) {
      const node22 = args[index2];
      map22[node22.key] = args[index2 + 1];
    }
    pubIn(map22);
  }
  function label(newLabels) {
    Object.assign(labels, newLabels);
  }
  function pipe(source, ...operators) {
    for (const operator of operators) {
      source = operator(source);
    }
    return source;
  }
  function spread(source, initialValues) {
    return initialValues.map((initialValue, index2) => {
      return tap(node2(initialValue, true), (sink) => {
        connect({
          map: (done) => (sourceValue) => {
            done(sourceValue[index2]);
          },
          sink,
          sources: [source]
        });
      });
    });
  }
  function link2(source, sink) {
    connect({ map: (done) => (value) => done(value), sink, sources: [source] });
  }
  function derive(source, initial) {
    return tap(node2(initial, true), (sink) => {
      connect({ map: (done) => (value) => done(value), sink, sources: [source] });
    });
  }
  function map2(mapFunction) {
    return (source) => {
      const sink = node2();
      connect({
        map: (done) => (value) => {
          done(mapFunction(value));
        },
        sink,
        sources: [source]
      });
      return sink;
    };
  }
  function mapTo(value) {
    return (source) => {
      const sink = node2();
      connect({ map: (done) => () => done(value), sink, sources: [source] });
      return sink;
    };
  }
  function filter(predicate) {
    return (source) => {
      const sink = node2();
      connect({ map: (done) => (value) => predicate(value) && done(value), sink, sources: [source] });
      return sink;
    };
  }
  function once() {
    return (source) => {
      const sink = node2();
      let passed = false;
      connect({
        map: (done) => (value) => {
          if (!passed) {
            passed = true;
            done(value);
          }
        },
        sink,
        sources: [source]
      });
      return sink;
    };
  }
  function scan(accumulator, seed) {
    return (source) => {
      const sink = node2();
      connect({ map: (done) => (value) => done(seed = accumulator(seed, value)), sink, sources: [source] });
      return sink;
    };
  }
  function throttleTime(delay) {
    return (source) => {
      const sink = node2();
      let currentValue;
      let timeout;
      sub(source, (value) => {
        currentValue = value;
        if (timeout) {
          return;
        }
        timeout = setTimeout(() => {
          timeout = void 0;
          pub(sink, currentValue);
        }, delay);
      });
      return sink;
    };
  }
  function delayWithMicrotask() {
    return (source) => {
      const sink = node2();
      sub(source, (value) => queueMicrotask(() => pub(sink, value)));
      return sink;
    };
  }
  function debounceTime(delay) {
    return (source) => {
      const sink = node2();
      let currentValue;
      let timeout;
      sub(source, (value) => {
        currentValue = value;
        if (timeout) {
          clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
          pub(sink, currentValue);
        }, delay);
      });
      return sink;
    };
  }
  function onNext(bufNode) {
    return (source) => {
      const sink = node2();
      let pendingValue = NO_VALUE;
      sub(source, (value) => pendingValue = value);
      connect({
        map: (done) => (value) => {
          if (pendingValue !== NO_VALUE) {
            done([pendingValue, value]);
            pendingValue = NO_VALUE;
          }
        },
        sink,
        sources: [bufNode]
      });
      return sink;
    };
  }
  function passOnlyAfterNodeHasEmittedBefore(starterNode, durationNode) {
    return (source) => {
      const sink = node2();
      let startTime = 0;
      sub(starterNode, () => startTime = Date.now());
      connect({
        map: (done) => (value) => {
          if (Date.now() < startTime + state.get(durationNode.key)) {
            done(value);
          }
        },
        sink,
        sources: [source]
      });
      return sink;
    };
  }
  function withLatestFrom(...nodes) {
    return (source) => {
      const sink = node2();
      connect({
        map: (done) => (...args) => done(args),
        pulls: nodes,
        sink,
        sources: [source]
      });
      return sink;
    };
  }
  function combine(...nodes) {
    const sink = node2();
    connect({
      map: (done) => (...args) => done(args),
      sink,
      sources: nodes
    });
    return sink;
  }
  function subKey(key, subscription) {
    return sub(labels[key], subscription);
  }
  function subKeys(keys, subscription) {
    const nodes = keys.map((key) => labels[key]);
    return sub(...nodes.concat(subscription));
  }
  function pubKey(key, value) {
    pubKeys({ [key]: value });
  }
  function pubKeys(values) {
    const valuesWithInternalKeys = Object.entries(values).reduce(
      (acc, [key, value]) => tap(acc, (acc2) => {
        const label2 = labels[key];
        if (!label2) {
          throw new Error(`No label for key ${key}. Do you miss a plugin?`);
        }
        acc2[label2.key] = value;
        return value;
      }),
      {}
    );
    pubIn(valuesWithInternalKeys);
  }
  function getKeyValue(key) {
    return state.get(labels[key].key);
  }
  function getValue(node22) {
    return state.get(node22.key);
  }
  function getKeyValues(keys) {
    return keys.map((key) => {
      const label2 = labels[key];
      if (!label2) {
        throw new Error(`No label for key ${key}. Do you miss a plugin?`);
      }
      return state.get(label2.key);
    });
  }
  return {
    combine,
    connect,
    derive,
    getKeyValue,
    getValue,
    getKeyValues,
    label,
    labels,
    link: link2,
    node: node2,
    o: {
      delayWithMicrotask,
      debounceTime,
      filter,
      map: map2,
      mapTo,
      onNext,
      scan,
      throttleTime,
      withLatestFrom,
      once,
      passOnlyAfterNodeHasEmittedBefore
    },
    pipe,
    pub,
    pubIn,
    pubKey,
    pubKeys,
    resetSingletonSubs,
    singletonSub,
    singletonSubKey,
    spread,
    sub,
    subKey,
    subKeys
  };
}
function system(constructor, dependencies = []) {
  return {
    constructor,
    dependencies,
    id: uuidv4()
  };
}
function realmFactory(...specs) {
  const singletons = /* @__PURE__ */ new Map();
  const r2 = realm();
  const _init = ({ id: id2, constructor, dependencies }) => {
    if (singletons.has(id2)) {
      return singletons.get(id2);
    }
    const system2 = constructor(r2, dependencies.map((t3) => _init(specs.find((spec) => spec.id === t3.id))));
    r2.label(system2);
    singletons.set(id2, system2);
    return system2;
  };
  specs.forEach(_init);
  return r2;
}
const useIsomorphicLayoutEffect = typeof document !== "undefined" ? React__default.useLayoutEffect : React__default.useEffect;
const GurxContext = React__default.createContext(void 0);
function sysHooks() {
  const Context = GurxContext;
  const usePublisher = (key) => {
    const realm2 = React__default.useContext(Context);
    return React__default.useCallback(
      (value) => {
        realm2.pubKey(key, value);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [key, realm2]
    );
  };
  const useEmitterValues = (...keys) => {
    const realm2 = React__default.useContext(Context);
    const [values, setValues] = React__default.useState(() => realm2.getKeyValues(keys));
    reactExports.useEffect(
      () => realm2 == null ? void 0 : realm2.subKeys(keys, (newValues) => {
        const setter = () => {
          if (keys.length === 1) {
            newValues = [newValues];
          }
          for (let i = 0; i < keys.length; i++) {
            if (newValues[i] !== values[i]) {
              setValues(newValues);
            }
          }
        };
        setter();
      }),
      [keys, realm2, values]
    );
    return values;
  };
  const usePubKeys = () => {
    return React__default.useContext(Context).pubKeys;
  };
  const useEmitter = (key, callback) => {
    const realm2 = React__default.useContext(Context);
    useIsomorphicLayoutEffect(() => realm2.subKey(key, callback), [callback]);
  };
  const useRealmContext = () => {
    return React__default.useContext(Context);
  };
  return {
    useRealmContext,
    useEmitter,
    useEmitterValues,
    usePubKeys,
    usePublisher
  };
}
const UsedPluginsContext = React__default.createContext(/* @__PURE__ */ new Set());
function realmPlugin(params) {
  const plugin = (pluginParams) => {
    return {
      systemSpec: params.systemSpec,
      pluginParams,
      applyParamsToSystem: params.applyParamsToSystem,
      init: params.init,
      id: params.id,
      dependencies: params.dependencies
    };
  };
  return [plugin, sysHooks()];
}
const RealmPluginInitializer = function({
  plugins,
  children
}) {
  const validPlugins = React__default.useMemo(() => {
    const availablePlugins = plugins.map((plugin) => plugin.id);
    const validPlugins2 = plugins.filter((plugin) => {
      if (plugin.dependencies) {
        if (plugin.dependencies.some((dep) => !availablePlugins.includes(dep))) {
          console.warn("MDXEditor plugin", plugin.id, "has some missing dependencies", plugin.dependencies, ", skipping");
          return false;
        }
      }
      return true;
    });
    return validPlugins2;
  }, [plugins]);
  const realm2 = React__default.useMemo(() => {
    const specs = validPlugins.map((plugin) => plugin.systemSpec);
    const pluginIds = validPlugins.map((plugin) => plugin.id);
    const realm22 = realmFactory(...specs);
    validPlugins.forEach((plugin) => {
      var _a, _b;
      (_a = plugin.init) == null ? void 0 : _a.call(plugin, realm22, plugin.pluginParams, pluginIds);
      (_b = plugin.applyParamsToSystem) == null ? void 0 : _b.call(plugin, realm22, plugin.pluginParams);
    });
    return realm22;
  }, []);
  React__default.useEffect(() => {
    validPlugins.forEach((plugin) => {
      var _a;
      (_a = plugin.applyParamsToSystem) == null ? void 0 : _a.call(plugin, realm2, plugin.pluginParams);
    });
  }, [realm2, validPlugins]);
  const Context = GurxContext;
  return React__default.createElement(
    Context.Provider,
    { value: realm2 },
    React__default.createElement(UsedPluginsContext.Provider, { value: new Set(plugins.map((plugin) => plugin.id)) }, children)
  );
};
function useHasPlugin(id2) {
  const usedPlugins = React__default.useContext(UsedPluginsContext);
  return usedPlugins.has(id2);
}
const NESTED_EDITOR_UPDATED_COMMAND = Lexical_1.createCommand("NESTED_EDITOR_UPDATED_COMMAND");
const coreSystem = system((r2) => {
  function createAppendNodeFor(node2) {
    const appendNode = r2.node();
    r2.link(
      r2.pipe(
        appendNode,
        r2.o.withLatestFrom(node2),
        r2.o.map(([newValue, values]) => {
          if (values.includes(newValue)) {
            return values;
          }
          return [...values, newValue];
        })
      ),
      node2
    );
    return appendNode;
  }
  const rootEditor = r2.node(null);
  const activeEditor = r2.node(null, true);
  const contentEditableClassName = r2.node("");
  const readOnly = r2.node(false);
  const placeholder2 = r2.node("");
  const autoFocus = r2.node(false);
  const inFocus = r2.node(false, true);
  const currentFormat = r2.node(0, true);
  const markdownProcessingError = r2.node(null);
  const markdownErrorSignal = r2.node();
  r2.link(
    r2.pipe(
      markdownProcessingError,
      r2.o.filter((e2) => e2 !== null)
    ),
    markdownErrorSignal
  );
  const applyFormat = r2.node();
  const currentSelection = r2.node(null);
  const activeEditorSubscriptions = r2.node([]);
  const rootEditorSubscriptions = r2.node([]);
  const editorInFocus = r2.node(null);
  const onBlur = r2.node();
  const iconComponentFor = r2.node((name) => {
    throw new Error(`No icon component for ${name}`);
  });
  const rebind = () => r2.o.scan((teardowns, [subs, activeEditorValue]) => {
    teardowns.forEach((teardown) => {
      if (!teardown) {
        throw new Error("You have a subscription that does not return a teardown");
      }
      teardown();
    });
    return activeEditorValue ? subs.map((s) => s(activeEditorValue)) : [];
  }, []);
  r2.pipe(r2.combine(activeEditorSubscriptions, activeEditor), rebind());
  r2.pipe(r2.combine(rootEditorSubscriptions, rootEditor), rebind());
  const createRootEditorSubscription = createAppendNodeFor(rootEditorSubscriptions);
  const createActiveEditorSubscription = createAppendNodeFor(activeEditorSubscriptions);
  function handleSelectionChange() {
    const selection = Lexical_1.$getSelection();
    if (Lexical_1.$isRangeSelection(selection)) {
      r2.pubKeys({
        currentSelection: selection,
        currentFormat: selection.format
      });
    }
  }
  r2.pub(createRootEditorSubscription, (theRootEditor) => {
    return theRootEditor.registerCommand(
      Lexical_1.SELECTION_CHANGE_COMMAND,
      (_, theActiveEditor) => {
        r2.pubIn({
          [activeEditor.key]: theActiveEditor,
          [inFocus.key]: true
        });
        if (theActiveEditor._parentEditor === null) {
          theActiveEditor.getEditorState().read(() => {
            r2.pub(editorInFocus, {
              rootNode: Lexical_1.$getRoot(),
              editorType: "lexical"
            });
          });
        }
        handleSelectionChange();
        return false;
      },
      Lexical_1.COMMAND_PRIORITY_CRITICAL
    );
  });
  r2.pub(createRootEditorSubscription, (theRootEditor) => {
    return theRootEditor.registerUpdateListener(({ dirtyElements, dirtyLeaves, editorState }) => {
      const err = r2.getValue(markdownProcessingError);
      if (err !== null) {
        return;
      }
      if (dirtyElements.size === 0 && dirtyLeaves.size === 0) {
        return;
      }
      let theNewMarkdownValue;
      editorState.read(() => {
        theNewMarkdownValue = exportMarkdownFromLexical({
          root: Lexical_1.$getRoot(),
          visitors: r2.getValue(exportVisitors),
          jsxComponentDescriptors: r2.getValue(jsxComponentDescriptors),
          toMarkdownExtensions: r2.getValue(toMarkdownExtensions),
          toMarkdownOptions: r2.getValue(toMarkdownOptions),
          jsxIsAvailable: r2.getValue(jsxIsAvailable)
        });
      });
      r2.pub(markdown, theNewMarkdownValue.trim());
    });
  });
  const initialMarkdown = r2.node("");
  const markdown = r2.node("", true);
  const markdownSignal = r2.node();
  r2.link(markdown, markdownSignal);
  r2.link(initialMarkdown, markdown);
  const importVisitors = r2.node([]);
  const syntaxExtensions = r2.node([]);
  const mdastExtensions = r2.node([]);
  const usedLexicalNodes = r2.node([]);
  const exportVisitors = r2.node([]);
  const toMarkdownExtensions = r2.node([]);
  const toMarkdownOptions = r2.node({}, true);
  const jsxIsAvailable = r2.node(false);
  const jsxComponentDescriptors = r2.node([]);
  const editorRootElementRef = r2.node(null);
  const addLexicalNode = createAppendNodeFor(usedLexicalNodes);
  const addImportVisitor = createAppendNodeFor(importVisitors);
  const addSyntaxExtension = createAppendNodeFor(syntaxExtensions);
  const addMdastExtension = createAppendNodeFor(mdastExtensions);
  const addExportVisitor = createAppendNodeFor(exportVisitors);
  const addToMarkdownExtension = createAppendNodeFor(toMarkdownExtensions);
  const setMarkdown = r2.node();
  function tryImportingMarkdown(markdownValue) {
    try {
      importMarkdownToLexical({
        root: Lexical_1.$getRoot(),
        visitors: r2.getValue(importVisitors),
        mdastExtensions: r2.getValue(mdastExtensions),
        markdown: markdownValue,
        syntaxExtensions: r2.getValue(syntaxExtensions)
      });
      r2.pub(markdownProcessingError, null);
    } catch (e2) {
      if (e2 instanceof MarkdownParseError || e2 instanceof UnrecognizedMarkdownConstructError) {
        r2.pubIn({
          [markdown.key]: markdownValue,
          [markdownProcessingError.key]: {
            error: e2.message,
            source: markdown
          }
        });
      } else {
        throw e2;
      }
    }
  }
  r2.sub(
    r2.pipe(
      setMarkdown,
      r2.o.withLatestFrom(markdown, rootEditor, inFocus),
      r2.o.filter(([newMarkdown, oldMarkdown]) => {
        return newMarkdown.trim() !== oldMarkdown.trim();
      })
    ),
    ([theNewMarkdownValue, , editor, inFocus2]) => {
      editor == null ? void 0 : editor.update(() => {
        Lexical_1.$getRoot().clear();
        tryImportingMarkdown(theNewMarkdownValue);
        if (!inFocus2) {
          Lexical_1.$setSelection(null);
        } else {
          editor.focus();
        }
      });
    }
  );
  const initialRootEditorState = r2.node((theRootEditor) => {
    r2.pub(rootEditor, theRootEditor);
    r2.pub(activeEditor, theRootEditor);
    tryImportingMarkdown(r2.getValue(initialMarkdown));
    const autoFocusValue = r2.getValue(autoFocus);
    if (autoFocusValue) {
      if (autoFocusValue === true) {
        setTimeout(() => theRootEditor.focus(noop, { defaultSelection: "rootStart" }));
        return;
      }
      setTimeout(
        () => theRootEditor.focus(noop, {
          defaultSelection: autoFocusValue.defaultSelection ?? "rootStart"
        })
      );
    }
  });
  r2.pub(createActiveEditorSubscription, (editor) => {
    return editor.registerUpdateListener(({ editorState }) => {
      editorState.read(() => {
        handleSelectionChange();
      });
    });
  });
  r2.pub(createActiveEditorSubscription, (theEditor) => {
    return theEditor.registerCommand(
      Lexical_1.BLUR_COMMAND,
      (payload) => {
        var _a;
        const theRootEditor = r2.getValue(rootEditor);
        if (theRootEditor) {
          const movingOutside = !((_a = theRootEditor.getRootElement()) == null ? void 0 : _a.contains(payload.relatedTarget));
          if (movingOutside) {
            r2.pubIn({
              [inFocus.key]: false,
              [onBlur.key]: payload
            });
          }
        }
        return false;
      },
      Lexical_1.COMMAND_PRIORITY_CRITICAL
    );
  });
  r2.pub(createRootEditorSubscription, (theEditor) => {
    return theEditor.registerCommand(
      Lexical_1.FOCUS_COMMAND,
      () => {
        r2.pub(inFocus, true);
        return false;
      },
      Lexical_1.COMMAND_PRIORITY_CRITICAL
    );
  });
  r2.pub(createRootEditorSubscription, (theRootEditor) => {
    return theRootEditor.registerCommand(
      Lexical_1.KEY_DOWN_COMMAND,
      (event) => {
        const { keyCode, ctrlKey, metaKey } = event;
        if (keyCode === 65 && controlOrMeta(metaKey, ctrlKey)) {
          let shouldOverride = false;
          theRootEditor.getEditorState().read(() => {
            shouldOverride = Lexical_1.$isDecoratorNode(Lexical_1.$getRoot().getFirstChild()) || Lexical_1.$isDecoratorNode(Lexical_1.$getRoot().getLastChild());
          });
          if (shouldOverride) {
            event.preventDefault();
            event.stopImmediatePropagation();
            theRootEditor.update(() => {
              var _a;
              const rootElement = theRootEditor.getRootElement();
              (_a = window.getSelection()) == null ? void 0 : _a.selectAllChildren(rootElement);
              rootElement.focus({
                preventScroll: true
              });
            });
            return true;
          }
        }
        return false;
      },
      Lexical_1.COMMAND_PRIORITY_CRITICAL
    );
  });
  const composerChildren = r2.node([]);
  const addComposerChild = createAppendNodeFor(composerChildren);
  const topAreaChildren = r2.node([]);
  const addTopAreaChild = createAppendNodeFor(topAreaChildren);
  const editorWrappers = r2.node([]);
  const addEditorWrapper = createAppendNodeFor(editorWrappers);
  const nestedEditorChildren = r2.node([]);
  const addNestedEditorChild = createAppendNodeFor(nestedEditorChildren);
  const historyState = r2.node(LexicalHistoryPlugin_1.createEmptyHistoryState());
  r2.sub(r2.pipe(applyFormat, r2.o.withLatestFrom(activeEditor)), ([format, theEditor]) => {
    theEditor == null ? void 0 : theEditor.dispatchCommand(Lexical_1.FORMAT_TEXT_COMMAND, format);
  });
  const currentBlockType = r2.node("");
  const applyBlockType = r2.node();
  r2.sub(r2.pipe(currentSelection, r2.o.withLatestFrom(activeEditor)), ([selection, theEditor]) => {
    if (!selection || !theEditor) {
      return;
    }
    const anchorNode = selection.anchor.getNode();
    let element2 = anchorNode.getKey() === "root" ? anchorNode : LexicalUtils_1.$findMatchingParent(anchorNode, (e2) => {
      const parent = e2.getParent();
      return parent !== null && Lexical_1.$isRootOrShadowRoot(parent);
    });
    if (element2 === null) {
      element2 = anchorNode.getTopLevelElementOrThrow();
    }
    const elementKey = element2.getKey();
    const elementDOM = theEditor.getElementByKey(elementKey);
    if (elementDOM !== null) {
      const blockType = LexicalRichText_1.$isHeadingNode(element2) ? element2.getTag() : element2.getType();
      r2.pub(currentBlockType, blockType);
    }
  });
  const convertSelectionToNode = r2.node();
  r2.sub(r2.pipe(convertSelectionToNode, r2.o.withLatestFrom(activeEditor)), ([factory, editor]) => {
    editor == null ? void 0 : editor.update(() => {
      const selection = Lexical_1.$getSelection();
      if (Lexical_1.$isRangeSelection(selection)) {
        LexicalSelection_1.$setBlocksType(selection, factory);
        setTimeout(() => {
          editor.focus();
        });
      }
    });
  });
  const insertDecoratorNode = r2.node();
  r2.sub(r2.pipe(insertDecoratorNode, r2.o.withLatestFrom(activeEditor)), ([nodeFactory, theEditor]) => {
    theEditor == null ? void 0 : theEditor.focus(
      () => {
        theEditor.getEditorState().read(() => {
          const selection = Lexical_1.$getSelection();
          if (Lexical_1.$isRangeSelection(selection)) {
            const focusNode = selection.focus.getNode();
            if (focusNode !== null) {
              theEditor.update(() => {
                const node2 = nodeFactory();
                if (node2.isInline()) {
                  Lexical_1.$insertNodes([node2]);
                  if (Lexical_1.$isRootOrShadowRoot(node2.getParentOrThrow())) {
                    LexicalUtils_1.$wrapNodeInElement(node2, Lexical_1.$createParagraphNode).selectEnd();
                  }
                } else {
                  LexicalUtils_1.$insertNodeToNearestRoot(node2);
                }
                if ("select" in node2 && typeof node2.select === "function") {
                  setTimeout(() => node2.select());
                }
              });
              setTimeout(() => {
                theEditor.dispatchCommand(NESTED_EDITOR_UPDATED_COMMAND, void 0);
              });
            }
          }
        });
      },
      { defaultSelection: "rootEnd" }
    );
  });
  r2.sub(r2.pipe(readOnly, r2.o.withLatestFrom(rootEditor)), ([readOnly2, theRootEditor]) => {
    theRootEditor == null ? void 0 : theRootEditor.setEditable(!readOnly2);
  });
  return {
    // state
    activeEditor,
    inFocus,
    historyState,
    currentSelection,
    // jsx
    jsxIsAvailable,
    jsxComponentDescriptors,
    // lexical editor
    initialRootEditorState,
    rootEditor,
    createRootEditorSubscription,
    createActiveEditorSubscription,
    // import
    importVisitors,
    syntaxExtensions,
    mdastExtensions,
    usedLexicalNodes,
    addImportVisitor,
    addLexicalNode,
    addSyntaxExtension,
    addMdastExtension,
    // export
    toMarkdownExtensions,
    toMarkdownOptions,
    addToMarkdownExtension,
    addExportVisitor,
    exportVisitors,
    // markdown strings
    initialMarkdown,
    setMarkdown,
    markdown,
    markdownSignal,
    // DOM
    editorRootElementRef,
    contentEditableClassName,
    placeholder: placeholder2,
    autoFocus,
    readOnly,
    // child controls
    composerChildren,
    addComposerChild,
    topAreaChildren,
    addTopAreaChild,
    nestedEditorChildren,
    addNestedEditorChild,
    editorWrappers,
    addEditorWrapper,
    // editor content state and commands
    currentFormat,
    editorInFocus,
    applyFormat,
    currentBlockType,
    applyBlockType,
    convertSelectionToNode,
    insertDecoratorNode,
    // Events
    onBlur,
    iconComponentFor,
    // error handling
    markdownProcessingError,
    markdownErrorSignal
  };
}, []);
const [
  /** @internal */
  corePlugin,
  /** @internal */
  corePluginHooks
] = realmPlugin({
  id: "core",
  systemSpec: coreSystem,
  applyParamsToSystem(realm2, params) {
    realm2.pubKeys({
      contentEditableClassName: params.contentEditableClassName,
      toMarkdownOptions: params.toMarkdownOptions,
      autoFocus: params.autoFocus,
      placeholder: params.placeholder,
      readOnly: params.readOnly
    });
    realm2.singletonSubKey("markdownSignal", params.onChange);
    realm2.singletonSubKey("onBlur", params.onBlur);
    realm2.singletonSubKey("markdownErrorSignal", params.onError);
  },
  init(realm2, params) {
    realm2.pubKey("initialMarkdown", params.initialMarkdown.trim());
    realm2.pubKey("iconComponentFor", params.iconComponentFor);
    realm2.pubKey("addImportVisitor", MdastRootVisitor);
    realm2.pubKey("addImportVisitor", MdastParagraphVisitor);
    realm2.pubKey("addImportVisitor", MdastTextVisitor);
    realm2.pubKey("addImportVisitor", MdastFormattingVisitor);
    realm2.pubKey("addImportVisitor", MdastInlineCodeVisitor);
    realm2.pubKey("addImportVisitor", MdastBreakVisitor);
    realm2.pubKey("addLexicalNode", Lexical_1.ParagraphNode);
    realm2.pubKey("addLexicalNode", Lexical_1.TextNode);
    realm2.pubKey("addLexicalNode", GenericHTMLNode);
    realm2.pubKey("addExportVisitor", LexicalRootVisitor);
    realm2.pubKey("addExportVisitor", LexicalParagraphVisitor);
    realm2.pubKey("addExportVisitor", LexicalTextVisitor);
    realm2.pubKey("addExportVisitor", LexicalLinebreakVisitor);
    realm2.pubKey("addExportVisitor", LexicalGenericHTMLVisitor);
    realm2.pubKey("addComposerChild", SharedHistoryPlugin);
    if (!params.suppressHtmlProcessing) {
      realm2.pubKey("addMdastExtension", mdxJsxFromMarkdown());
      realm2.pubKey("addSyntaxExtension", mdxJsx());
      realm2.pubKey("addToMarkdownExtension", mdxJsxToMarkdown());
      realm2.pubKey("addImportVisitor", MdastHTMLVisitor);
    }
  }
});
const lightTheme = "_light-theme_1xkrx_1";
const darkTheme = "_dark-theme_1xkrx_1";
const bold = "_bold_1xkrx_10";
const italic = "_italic_1xkrx_14";
const underline = "_underline_1xkrx_18";
const strikethrough = "_strikethrough_1xkrx_34";
const underlineStrikethrough = "_underlineStrikethrough_1xkrx_38";
const subscript = "_subscript_1xkrx_42";
const superscript = "_superscript_1xkrx_47";
const code = "_code_1xkrx_52";
const nestedListItem$1 = "_nestedListItem_1xkrx_59";
const listitem = "_listitem_1xkrx_69";
const listItemChecked = "_listItemChecked_1xkrx_73";
const listItemUnchecked = "_listItemUnchecked_1xkrx_74";
const admonitionDanger = "_admonitionDanger_1xkrx_151";
const admonitionInfo = "_admonitionInfo_1xkrx_152";
const admonitionNote = "_admonitionNote_1xkrx_153";
const admonitionTip = "_admonitionTip_1xkrx_154";
const admonitionCaution = "_admonitionCaution_1xkrx_155";
const styles$1 = {
  lightTheme,
  darkTheme,
  bold,
  italic,
  underline,
  strikethrough,
  underlineStrikethrough,
  subscript,
  superscript,
  code,
  nestedListItem: nestedListItem$1,
  listitem,
  listItemChecked,
  listItemUnchecked,
  admonitionDanger,
  admonitionInfo,
  admonitionNote,
  admonitionTip,
  admonitionCaution
};
const lexicalTheme = {
  text: {
    bold: styles$1.bold,
    italic: styles$1.italic,
    underline: styles$1.underline,
    code: styles$1.code,
    strikethrough: styles$1.strikethrough,
    subscript: styles$1.subscript,
    superscript: styles$1.superscript,
    underlineStrikethrough: styles$1.underlineStrikethrough
  },
  list: {
    listitem: styles$1.listitem,
    listitemChecked: styles$1.listItemChecked,
    listitemUnchecked: styles$1.listItemUnchecked,
    nested: {
      listitem: styles$1.nestedListItem
    }
  },
  admonition: {
    danger: styles$1.admonitionDanger,
    info: styles$1.admonitionInfo,
    note: styles$1.admonitionNote,
    tip: styles$1.admonitionTip,
    caution: styles$1.admonitionCaution
  }
};
var LexicalComposer_prod = {};
var e$4 = LexicalComposerContext_1, f$5 = Lexical_1, g$8 = reactExports;
let m$7 = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement;
var n$7 = m$7 ? g$8.useLayoutEffect : g$8.useEffect;
let p$6 = { tag: "history-merge" };
function q$5(a2, c2) {
  if (null !== c2) {
    if (void 0 === c2)
      a2.update(() => {
        var b2 = f$5.$getRoot();
        if (b2.isEmpty()) {
          let d2 = f$5.$createParagraphNode();
          b2.append(d2);
          b2 = m$7 ? document.activeElement : null;
          (null !== f$5.$getSelection() || null !== b2 && b2 === a2.getRootElement()) && d2.select();
        }
      }, p$6);
    else if (null !== c2)
      switch (typeof c2) {
        case "string":
          let b2 = a2.parseEditorState(c2);
          a2.setEditorState(b2, p$6);
          break;
        case "object":
          a2.setEditorState(c2, p$6);
          break;
        case "function":
          a2.update(() => {
            f$5.$getRoot().isEmpty() && c2(a2);
          }, p$6);
      }
  }
}
LexicalComposer_prod.LexicalComposer = function({ initialConfig: a2, children: c2 }) {
  let b2 = g$8.useMemo(() => {
    const { theme: d2, namespace: h2, editor__DEPRECATED: r2, nodes: t3, onError: u2, editorState: v3, html: w2 } = a2, x3 = e$4.createLexicalComposerContext(null, d2);
    let k2 = r2 || null;
    if (null === k2) {
      const l2 = f$5.createEditor({ editable: a2.editable, html: w2, namespace: h2, nodes: t3, onError: (y2) => u2(y2, l2), theme: d2 });
      q$5(l2, v3);
      k2 = l2;
    }
    return [k2, x3];
  }, []);
  n$7(() => {
    let d2 = a2.editable, [h2] = b2;
    h2.setEditable(void 0 !== d2 ? d2 : true);
  }, []);
  return g$8.createElement(
    e$4.LexicalComposerContext.Provider,
    { value: b2 },
    c2
  );
};
const LexicalComposer = LexicalComposer_prod;
var LexicalComposer_1 = LexicalComposer;
const editorRoot = "_editorRoot_lug8m_37";
const editorWrapper = "_editorWrapper_lug8m_138";
const nestedListItem = "_nestedListItem_lug8m_141";
const toolbarRoot = "_toolbarRoot_lug8m_145";
const readOnlyToolbarRoot = "_readOnlyToolbarRoot_lug8m_168";
const toolbarModeSwitch = "_toolbarModeSwitch_lug8m_176";
const toolbarToggleItem = "_toolbarToggleItem_lug8m_186";
const toolbarGroupOfGroups = "_toolbarGroupOfGroups_lug8m_196";
const toolbarToggleSingleGroup = "_toolbarToggleSingleGroup_lug8m_201";
const toolbarButton = "_toolbarButton_lug8m_215";
const activeToolbarButton = "_activeToolbarButton_lug8m_246";
const toolbarNodeKindSelectContainer = "_toolbarNodeKindSelectContainer_lug8m_254";
const toolbarButtonDropdownContainer = "_toolbarButtonDropdownContainer_lug8m_255";
const toolbarCodeBlockLanguageSelectContent = "_toolbarCodeBlockLanguageSelectContent_lug8m_256";
const selectContainer = "_selectContainer_lug8m_257";
const selectItem = "_selectItem_lug8m_271";
const toolbarNodeKindSelectTrigger = "_toolbarNodeKindSelectTrigger_lug8m_276";
const toolbarButtonSelectTrigger = "_toolbarButtonSelectTrigger_lug8m_277";
const selectTrigger = "_selectTrigger_lug8m_278";
const toolbarCodeBlockLanguageSelectTrigger = "_toolbarCodeBlockLanguageSelectTrigger_lug8m_312";
const toolbarNodeKindSelectItem = "_toolbarNodeKindSelectItem_lug8m_318";
const toolbarNodeKindSelectDropdownArrow = "_toolbarNodeKindSelectDropdownArrow_lug8m_344";
const selectDropdownArrow = "_selectDropdownArrow_lug8m_345";
const contentEditable = "_contentEditable_lug8m_351";
const sandpackWrapper = "_sandpackWrapper_lug8m_361";
const frontmatterWrapper = "_frontmatterWrapper_lug8m_365";
const frontmatterToggleButton = "_frontmatterToggleButton_lug8m_375";
const propertyPanelTitle = "_propertyPanelTitle_lug8m_383";
const propertyEditorTable = "_propertyEditorTable_lug8m_391";
const iconButton = "_iconButton_lug8m_408";
const readOnlyColumnCell = "_readOnlyColumnCell_lug8m_413";
const propertyEditorLabelCell = "_propertyEditorLabelCell_lug8m_418";
const buttonsFooter = "_buttonsFooter_lug8m_426";
const propertyEditorInput = "_propertyEditorInput_lug8m_432";
const primaryButton = "_primaryButton_lug8m_453";
const secondaryButton = "_secondaryButton_lug8m_453";
const smallButton = "_smallButton_lug8m_467";
const dialogForm = "_dialogForm_lug8m_479";
const linkDialogEditForm = "_linkDialogEditForm_lug8m_485";
const linkDialogInputContainer = "_linkDialogInputContainer_lug8m_493";
const linkDialogInputWrapper = "_linkDialogInputWrapper_lug8m_499";
const linkDialogInput = "_linkDialogInput_lug8m_493";
const dialogInput = "_dialogInput_lug8m_519";
const linkDialogAnchor = "_linkDialogAnchor_lug8m_529";
const linkDialogPopoverContent = "_linkDialogPopoverContent_lug8m_543";
const tableColumnEditorPopoverContent = "_tableColumnEditorPopoverContent_lug8m_543";
const dialogContent = "_dialogContent_lug8m_543";
const largeDialogContent = "_largeDialogContent_lug8m_555";
const dialogTitle = "_dialogTitle_lug8m_565";
const dialogCloseButton = "_dialogCloseButton_lug8m_571";
const popoverContent = "_popoverContent_lug8m_578";
const popoverArrow = "_popoverArrow_lug8m_590";
const linkDialogPreviewAnchor = "_linkDialogPreviewAnchor_lug8m_594";
const tooltipTrigger = "_tooltipTrigger_lug8m_615";
const tooltipContent = "_tooltipContent_lug8m_619";
const actionButton = "_actionButton_lug8m_633";
const primaryActionButton = "_primaryActionButton_lug8m_639";
const tableEditor = "_tableEditor_lug8m_648";
const toolCell = "_toolCell_lug8m_659";
const tableColumnEditorTrigger = "_tableColumnEditorTrigger_lug8m_676";
const tableRowEditorTrigger = "_tableRowEditorTrigger_lug8m_676";
const addRowButton = "_addRowButton_lug8m_676";
const addColumnButton = "_addColumnButton_lug8m_676";
const tableColumnEditorToolbar = "_tableColumnEditorToolbar_lug8m_710";
const toggleGroupRoot = "_toggleGroupRoot_lug8m_723";
const tableToolsColumn = "_tableToolsColumn_lug8m_740";
const leftAlignedCell = "_leftAlignedCell_lug8m_748";
const rightAlignedCell = "_rightAlignedCell_lug8m_752";
const centeredCell = "_centeredCell_lug8m_756";
const dialogOverlay = "_dialogOverlay_lug8m_787";
const overlayShow = "_overlayShow_lug8m_1";
const contentShow = "_contentShow_lug8m_1";
const focusedImage = "_focusedImage_lug8m_830";
const imageWrapper = "_imageWrapper_lug8m_834";
const editImageButton = "_editImageButton_lug8m_846";
const inlineEditor = "_inlineEditor_lug8m_858";
const blockEditor = "_blockEditor_lug8m_867";
const nestedEditor = "_nestedEditor_lug8m_876";
const genericComponentName = "_genericComponentName_lug8m_893";
const diffSourceToggle = "_diffSourceToggle_lug8m_899";
const selectWithLabel = "_selectWithLabel_lug8m_912";
const toolbarTitleMode = "_toolbarTitleMode_lug8m_926";
const imageControlWrapperResizing = "_imageControlWrapperResizing_lug8m_932";
const imageResizer = "_imageResizer_lug8m_936";
const imageResizerN = "_imageResizerN_lug8m_945";
const imageResizerNe = "_imageResizerNe_lug8m_951";
const imageResizerE = "_imageResizerE_lug8m_957";
const imageResizerSe = "_imageResizerSe_lug8m_963";
const imageResizerS = "_imageResizerS_lug8m_963";
const imageResizerSw = "_imageResizerSw_lug8m_975";
const imageResizerW = "_imageResizerW_lug8m_981";
const imageResizerNw = "_imageResizerNw_lug8m_987";
const placeholder = "_placeholder_lug8m_993";
const rootContentEditableWrapper = "_rootContentEditableWrapper_lug8m_1006";
const downshiftContainer = "_downshiftContainer_lug8m_1012";
const downshiftInputWrapper = "_downshiftInputWrapper_lug8m_1018";
const downshiftInput = "_downshiftInput_lug8m_1018";
const downshiftAutocompleteContainer = "_downshiftAutocompleteContainer_lug8m_1048";
const textInput = "_textInput_lug8m_1093";
const multiFieldForm = "_multiFieldForm_lug8m_1101";
const formField = "_formField_lug8m_1107";
const markdownParseError = "_markdownParseError_lug8m_1118";
const popupContainer = "_popupContainer_lug8m_1127";
const styles = {
  editorRoot,
  editorWrapper,
  nestedListItem,
  toolbarRoot,
  readOnlyToolbarRoot,
  toolbarModeSwitch,
  toolbarToggleItem,
  toolbarGroupOfGroups,
  toolbarToggleSingleGroup,
  toolbarButton,
  activeToolbarButton,
  toolbarNodeKindSelectContainer,
  toolbarButtonDropdownContainer,
  toolbarCodeBlockLanguageSelectContent,
  selectContainer,
  selectItem,
  toolbarNodeKindSelectTrigger,
  toolbarButtonSelectTrigger,
  selectTrigger,
  toolbarCodeBlockLanguageSelectTrigger,
  toolbarNodeKindSelectItem,
  toolbarNodeKindSelectDropdownArrow,
  selectDropdownArrow,
  contentEditable,
  sandpackWrapper,
  frontmatterWrapper,
  frontmatterToggleButton,
  propertyPanelTitle,
  propertyEditorTable,
  iconButton,
  readOnlyColumnCell,
  propertyEditorLabelCell,
  buttonsFooter,
  propertyEditorInput,
  primaryButton,
  secondaryButton,
  smallButton,
  dialogForm,
  linkDialogEditForm,
  linkDialogInputContainer,
  linkDialogInputWrapper,
  linkDialogInput,
  dialogInput,
  linkDialogAnchor,
  linkDialogPopoverContent,
  tableColumnEditorPopoverContent,
  dialogContent,
  largeDialogContent,
  dialogTitle,
  dialogCloseButton,
  popoverContent,
  popoverArrow,
  linkDialogPreviewAnchor,
  tooltipTrigger,
  tooltipContent,
  actionButton,
  primaryActionButton,
  tableEditor,
  toolCell,
  tableColumnEditorTrigger,
  tableRowEditorTrigger,
  addRowButton,
  addColumnButton,
  tableColumnEditorToolbar,
  toggleGroupRoot,
  tableToolsColumn,
  leftAlignedCell,
  rightAlignedCell,
  centeredCell,
  dialogOverlay,
  overlayShow,
  contentShow,
  focusedImage,
  imageWrapper,
  editImageButton,
  inlineEditor,
  blockEditor,
  nestedEditor,
  genericComponentName,
  diffSourceToggle,
  selectWithLabel,
  toolbarTitleMode,
  imageControlWrapperResizing,
  imageResizer,
  imageResizerN,
  imageResizerNe,
  imageResizerE,
  imageResizerSe,
  imageResizerS,
  imageResizerSw,
  imageResizerW,
  imageResizerNw,
  placeholder,
  rootContentEditableWrapper,
  downshiftContainer,
  downshiftInputWrapper,
  downshiftInput,
  downshiftAutocompleteContainer,
  textInput,
  multiFieldForm,
  formField,
  markdownParseError,
  popupContainer
};
var LexicalRichTextPlugin_prod = {};
var b$3 = LexicalComposerContext_1, k$6 = reactExports, l$3 = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement ? k$6.useLayoutEffect : k$6.useEffect;
function m$6(a2) {
  let [c2] = b$3.useLexicalComposerContext(), e2 = k$6.useMemo(() => a2(c2), [c2, a2]), d2 = k$6.useRef(e2.initialValueFn()), [n2, g2] = k$6.useState(d2.current);
  l$3(() => {
    let { initialValueFn: p2, subscribe: q2 } = e2, f2 = p2();
    d2.current !== f2 && (d2.current = f2, g2(f2));
    return q2((h2) => {
      d2.current = h2;
      g2(h2);
    });
  }, [e2, a2]);
  return n2;
}
function r$7(a2) {
  return { initialValueFn: () => a2.isEditable(), subscribe: (c2) => a2.registerEditableListener(c2) };
}
var useLexicalEditable_prod = function() {
  return m$6(r$7);
};
const useLexicalEditable = useLexicalEditable_prod;
var useLexicalEditable_1 = useLexicalEditable;
var LexicalText_prod = {};
var g$7 = Lexical_1;
function r$6(c2, h2 = true) {
  if (c2)
    return false;
  c2 = t$6();
  h2 && (c2 = c2.trim());
  return "" === c2;
}
function t$6() {
  return g$7.$getRoot().getTextContent();
}
function u$6(c2) {
  if (!r$6(c2, false))
    return false;
  c2 = g$7.$getRoot().getChildren();
  let h2 = c2.length;
  if (1 < h2)
    return false;
  for (let e2 = 0; e2 < h2; e2++) {
    var b2 = c2[e2];
    if (g$7.$isDecoratorNode(b2))
      return false;
    if (g$7.$isElementNode(b2)) {
      if (!g$7.$isParagraphNode(b2) || 0 !== b2.__indent)
        return false;
      b2 = b2.getChildren();
      let n2 = b2.length;
      for (let q2 = 0; q2 < n2; q2++)
        if (!g$7.$isTextNode(b2[e2]))
          return false;
    }
  }
  return true;
}
LexicalText_prod.$canShowPlaceholder = u$6;
LexicalText_prod.$canShowPlaceholderCurry = function(c2) {
  return () => u$6(c2);
};
LexicalText_prod.$findTextIntersectionFromCharacters = function(c2, h2) {
  var b2 = c2.getFirstChild();
  c2 = 0;
  a:
    for (; null !== b2; ) {
      if (g$7.$isElementNode(b2)) {
        var e2 = b2.getFirstChild();
        if (null !== e2) {
          b2 = e2;
          continue;
        }
      } else if (g$7.$isTextNode(b2)) {
        e2 = b2.getTextContentSize();
        if (c2 + e2 > h2)
          return { node: b2, offset: h2 - c2 };
        c2 += e2;
      }
      e2 = b2.getNextSibling();
      if (null !== e2)
        b2 = e2;
      else {
        for (b2 = b2.getParent(); null !== b2; ) {
          e2 = b2.getNextSibling();
          if (null !== e2) {
            b2 = e2;
            continue a;
          }
          b2 = b2.getParent();
        }
        break;
      }
    }
  return null;
};
LexicalText_prod.$isRootTextContentEmpty = r$6;
LexicalText_prod.$isRootTextContentEmptyCurry = function(c2, h2) {
  return () => r$6(c2, h2);
};
LexicalText_prod.$rootTextContent = t$6;
LexicalText_prod.registerLexicalTextEntity = function(c2, h2, b2, e2) {
  let n2 = (a2) => {
    const d2 = g$7.$createTextNode(a2.getTextContent());
    d2.setFormat(a2.getFormat());
    a2.replace(d2);
  }, q2 = c2.registerNodeTransform(g$7.TextNode, (a2) => {
    if (a2.isSimpleText()) {
      var d2 = a2.getPreviousSibling(), l2 = a2.getTextContent(), m2 = a2;
      if (g$7.$isTextNode(d2)) {
        var k2 = d2.getTextContent(), f2 = h2(k2 + l2);
        if (d2 instanceof b2) {
          if (null === f2 || 0 !== d2.getLatest().__mode) {
            n2(d2);
            return;
          }
          f2 = f2.end - k2.length;
          if (0 < f2) {
            m2 = l2.slice(0, f2);
            m2 = k2 + m2;
            d2.select();
            d2.setTextContent(m2);
            f2 === l2.length ? a2.remove() : (d2 = l2.slice(f2), a2.setTextContent(d2));
            return;
          }
        } else if (null === f2 || f2.start < k2.length)
          return;
      }
      for (; ; ) {
        a2 = h2(l2);
        l2 = f2 = null === a2 ? "" : l2.slice(a2.end);
        if ("" === f2) {
          if (k2 = m2.getNextSibling(), g$7.$isTextNode(k2)) {
            if (f2 = m2.getTextContent() + k2.getTextContent(), f2 = h2(f2), null === f2) {
              k2 instanceof b2 ? n2(k2) : k2.markDirty();
              break;
            } else if (0 !== f2.start)
              break;
          }
        } else if (k2 = h2(f2), null !== k2 && 0 === k2.start)
          break;
        if (null === a2)
          break;
        if (0 === a2.start && g$7.$isTextNode(d2) && d2.isTextEntity())
          continue;
        let p2;
        0 === a2.start ? [p2, m2] = m2.splitText(a2.end) : [, p2, m2] = m2.splitText(a2.start, a2.end);
        a2 = e2(p2);
        a2.setFormat(p2.getFormat());
        p2.replace(a2);
        if (null == m2)
          break;
      }
    }
  });
  c2 = c2.registerNodeTransform(b2, (a2) => {
    var d2 = a2.getTextContent();
    const l2 = h2(d2);
    null === l2 || 0 !== l2.start ? n2(a2) : d2.length > l2.end ? a2.splitText(l2.end) : (d2 = a2.getPreviousSibling(), g$7.$isTextNode(d2) && d2.isTextEntity() && (n2(d2), n2(a2)), d2 = a2.getNextSibling(), g$7.$isTextNode(d2) && d2.isTextEntity() && (n2(d2), a2 instanceof b2 && n2(a2)));
  });
  return [q2, c2];
};
const LexicalText = LexicalText_prod;
var LexicalText_1 = LexicalText;
var LexicalDragon_prod = {};
var g$6 = Lexical_1;
LexicalDragon_prod.registerDragonSupport = function(m2) {
  let t3 = window.location.origin, r2 = (l2) => {
    if (l2.origin === t3) {
      var h2 = m2.getRootElement();
      if (document.activeElement === h2 && (h2 = l2.data, "string" === typeof h2)) {
        try {
          var a2 = JSON.parse(h2);
        } catch (k2) {
          return;
        }
        if (a2 && "nuanria_messaging" === a2.protocol && "request" === a2.type && (a2 = a2.payload) && "makeChanges" === a2.functionId && (a2 = a2.args)) {
          const [k2, n2, p2, q2, u2] = a2;
          m2.update(() => {
            const f2 = g$6.$getSelection();
            if (g$6.$isRangeSelection(f2)) {
              var e2 = f2.anchor;
              let b2 = e2.getNode(), c2 = 0, d2 = 0;
              g$6.$isTextNode(b2) && 0 <= k2 && 0 <= n2 && (c2 = k2, d2 = k2 + n2, f2.setTextNodeRange(b2, c2, b2, d2));
              if (c2 !== d2 || "" !== p2)
                f2.insertRawText(p2), b2 = e2.getNode();
              g$6.$isTextNode(b2) && (c2 = q2, d2 = q2 + u2, e2 = b2.getTextContentSize(), c2 = c2 > e2 ? e2 : c2, d2 = d2 > e2 ? e2 : d2, f2.setTextNodeRange(b2, c2, b2, d2));
              l2.stopImmediatePropagation();
            }
          });
        }
      }
    }
  };
  window.addEventListener("message", r2, true);
  return () => {
    window.removeEventListener("message", r2, true);
  };
};
const LexicalDragon = LexicalDragon_prod;
var LexicalDragon_1 = LexicalDragon;
var b$2 = LexicalComposerContext_1, g$5 = useLexicalEditable_1, l$2 = reactExports, m$5 = LexicalText_1, n$6 = LexicalUtils_1, p$5 = reactDomExports, t$5 = LexicalDragon_1, u$5 = LexicalRichText_1, v$4 = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement ? l$2.useLayoutEffect : l$2.useEffect;
function w$3(a2) {
  return a2.getEditorState().read(m$5.$canShowPlaceholderCurry(a2.isComposing()));
}
function x$2(a2) {
  let [d2, c2] = l$2.useState(() => w$3(a2));
  v$4(() => {
    function e2() {
      let f2 = w$3(a2);
      c2(f2);
    }
    e2();
    return n$6.mergeRegister(a2.registerUpdateListener(() => {
      e2();
    }), a2.registerEditableListener(() => {
      e2();
    }));
  }, [a2]);
  return d2;
}
function y$3(a2, d2) {
  let [c2, e2] = l$2.useState(() => a2.getDecorators());
  v$4(() => a2.registerDecoratorListener((f2) => {
    p$5.flushSync(() => {
      e2(f2);
    });
  }), [a2]);
  l$2.useEffect(() => {
    e2(a2.getDecorators());
  }, [a2]);
  return l$2.useMemo(() => {
    let f2 = [], q2 = Object.keys(c2);
    for (let h2 = 0; h2 < q2.length; h2++) {
      let k2 = q2[h2], A2 = l$2.createElement(d2, { onError: (z2) => a2._onError(z2) }, l$2.createElement(l$2.Suspense, { fallback: null }, c2[k2])), r2 = a2.getElementByKey(k2);
      null !== r2 && f2.push(p$5.createPortal(A2, r2, k2));
    }
    return f2;
  }, [d2, c2, a2]);
}
function B$3(a2) {
  v$4(() => n$6.mergeRegister(u$5.registerRichText(a2), t$5.registerDragonSupport(a2)), [a2]);
}
function C$2({ content: a2 }) {
  var [d2] = b$2.useLexicalComposerContext();
  d2 = x$2(d2);
  let c2 = g$5();
  return d2 ? "function" === typeof a2 ? a2(c2) : a2 : null;
}
LexicalRichTextPlugin_prod.RichTextPlugin = function({ contentEditable: a2, placeholder: d2, ErrorBoundary: c2 }) {
  let [e2] = b$2.useLexicalComposerContext();
  c2 = y$3(e2, c2);
  B$3(e2);
  return l$2.createElement(l$2.Fragment, null, a2, l$2.createElement(C$2, { content: d2 }), c2);
};
const LexicalRichTextPlugin = LexicalRichTextPlugin_prod;
var LexicalRichTextPlugin_1 = LexicalRichTextPlugin;
var LexicalContentEditable_prod = {};
var c$2 = LexicalComposerContext_1, h$4 = reactExports;
function n$5() {
  n$5 = Object.assign ? Object.assign.bind() : function(g2) {
    for (var d2 = 1; d2 < arguments.length; d2++) {
      var e2 = arguments[d2], b2;
      for (b2 in e2)
        Object.prototype.hasOwnProperty.call(e2, b2) && (g2[b2] = e2[b2]);
    }
    return g2;
  };
  return n$5.apply(this, arguments);
}
var p$4 = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement ? h$4.useLayoutEffect : h$4.useEffect;
LexicalContentEditable_prod.ContentEditable = function({ ariaActiveDescendant: g2, ariaAutoComplete: d2, ariaControls: e2, ariaDescribedBy: b2, ariaExpanded: q2, ariaLabel: r2, ariaLabelledBy: t3, ariaMultiline: u2, ariaOwns: v3, ariaRequired: w2, autoCapitalize: x3, className: y2, id: z2, role: l2 = "textbox", spellCheck: A2 = true, style: B3, tabIndex: C2, "data-testid": D2, ...E2 }) {
  let [f2] = c$2.useLexicalComposerContext(), [a2, m2] = h$4.useState(false), F2 = h$4.useCallback((k2) => {
    f2.setRootElement(k2);
  }, [f2]);
  p$4(() => {
    m2(f2.isEditable());
    return f2.registerEditableListener((k2) => {
      m2(k2);
    });
  }, [f2]);
  return h$4.createElement(
    "div",
    n$5({}, E2, { "aria-activedescendant": a2 ? g2 : void 0, "aria-autocomplete": a2 ? d2 : "none", "aria-controls": a2 ? e2 : void 0, "aria-describedby": b2, "aria-expanded": a2 ? "combobox" === l2 ? !!q2 : void 0 : void 0, "aria-label": r2, "aria-labelledby": t3, "aria-multiline": u2, "aria-owns": a2 ? v3 : void 0, "aria-readonly": a2 ? void 0 : true, "aria-required": w2, autoCapitalize: x3, className: y2, contentEditable: a2, "data-testid": D2, id: z2, ref: F2, role: l2, spellCheck: A2, style: B3, tabIndex: C2 })
  );
};
const LexicalContentEditable = LexicalContentEditable_prod;
var LexicalContentEditable_1 = LexicalContentEditable;
var h$3 = reactExports;
function m$4(b2, c2) {
  m$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(g2, a2) {
    g2.__proto__ = a2;
    return g2;
  };
  return m$4(b2, c2);
}
function n$4(b2, c2) {
  b2.prototype = Object.create(c2.prototype);
  b2.prototype.constructor = b2;
  m$4(b2, c2);
}
function r$5(b2, c2) {
  void 0 === b2 && (b2 = []);
  void 0 === c2 && (c2 = []);
  return b2.length !== c2.length || b2.some(function(g2, a2) {
    return !Object.is(g2, c2[a2]);
  });
}
var t$4 = { error: null }, u$4 = function(b2) {
  function c2() {
    for (var a2, d2 = arguments.length, f2 = Array(d2), e2 = 0; e2 < d2; e2++)
      f2[e2] = arguments[e2];
    a2 = b2.call.apply(b2, [this].concat(f2)) || this;
    a2.state = t$4;
    a2.resetErrorBoundary = function() {
      for (var k2, p2 = arguments.length, q2 = Array(p2), l2 = 0; l2 < p2; l2++)
        q2[l2] = arguments[l2];
      null == a2.props.onReset ? void 0 : (k2 = a2.props).onReset.apply(k2, q2);
      a2.reset();
    };
    return a2;
  }
  n$4(c2, b2);
  c2.getDerivedStateFromError = function(a2) {
    return { error: a2 };
  };
  var g2 = c2.prototype;
  g2.reset = function() {
    this.setState(t$4);
  };
  g2.componentDidCatch = function(a2, d2) {
    var f2, e2;
    null == (f2 = (e2 = this.props).onError) ? void 0 : f2.call(e2, a2, d2);
  };
  g2.componentDidUpdate = function(a2, d2) {
    var f2 = this.props.resetKeys;
    if (null !== this.state.error && null !== d2.error && r$5(a2.resetKeys, f2)) {
      var e2, k2;
      null == (e2 = (k2 = this.props).onResetKeysChange) ? void 0 : e2.call(k2, a2.resetKeys, f2);
      this.reset();
    }
  };
  g2.render = function() {
    var a2 = this.state.error, d2 = this.props, f2 = d2.fallbackRender, e2 = d2.FallbackComponent;
    d2 = d2.fallback;
    if (null !== a2) {
      a2 = { error: a2, resetErrorBoundary: this.resetErrorBoundary };
      if (h$3.isValidElement(d2))
        return d2;
      if ("function" === typeof f2)
        return f2(a2);
      if (e2)
        return h$3.createElement(e2, a2);
      throw Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
    }
    return this.props.children;
  };
  return c2;
}(h$3.Component);
var LexicalErrorBoundary_prod = function({ children: b2, onError: c2 }) {
  return h$3.createElement(u$4, { fallback: h$3.createElement("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" } }, "An error was thrown."), onError: c2 }, b2);
};
const LexicalErrorBoundary = LexicalErrorBoundary_prod;
var LexicalErrorBoundary_1 = LexicalErrorBoundary;
const LexicalErrorBoundary$1 = /* @__PURE__ */ getDefaultExportFromCjs(LexicalErrorBoundary_1);
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames2() {
      var classes = "";
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg) {
          classes = appendClass(classes, parseValue(arg));
        }
      }
      return classes;
    }
    function parseValue(arg) {
      if (typeof arg === "string" || typeof arg === "number") {
        return arg;
      }
      if (typeof arg !== "object") {
        return "";
      }
      if (Array.isArray(arg)) {
        return classNames2.apply(null, arg);
      }
      if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
        return arg.toString();
      }
      var classes = "";
      for (var key in arg) {
        if (hasOwn.call(arg, key) && arg[key]) {
          classes = appendClass(classes, key);
        }
      }
      return classes;
    }
    function appendClass(value, newClass) {
      if (!newClass) {
        return value;
      }
      if (value) {
        return value + " " + newClass;
      }
      return value + newClass;
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classnamesExports = classnames.exports;
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
const LexicalProvider = ({ children }) => {
  const [initialRootEditorState, nodes, readOnly] = corePluginHooks.useEmitterValues(
    "initialRootEditorState",
    "usedLexicalNodes",
    "readOnly"
  );
  return /* @__PURE__ */ React__default.createElement(
    LexicalComposer_1.LexicalComposer,
    {
      initialConfig: {
        editable: !readOnly,
        editorState: initialRootEditorState,
        namespace: "MDXEditor",
        theme: lexicalTheme,
        nodes,
        onError: (error) => {
          throw error;
        }
      }
    },
    children
  );
};
const RichTextEditor = () => {
  const [contentEditableClassName, composerChildren, topAreaChildren, editorWrappers, placeholder2] = corePluginHooks.useEmitterValues(
    "contentEditableClassName",
    "composerChildren",
    "topAreaChildren",
    "editorWrappers",
    "placeholder"
  );
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, topAreaChildren.map((Child, index2) => /* @__PURE__ */ React__default.createElement(Child, { key: index2 })), /* @__PURE__ */ React__default.createElement(RenderRecurisveWrappers, { wrappers: editorWrappers }, /* @__PURE__ */ React__default.createElement("div", { className: classNames(styles.rootContentEditableWrapper) }, /* @__PURE__ */ React__default.createElement(
    LexicalRichTextPlugin_1.RichTextPlugin,
    {
      contentEditable: /* @__PURE__ */ React__default.createElement(LexicalContentEditable_1.ContentEditable, { className: classNames(styles.contentEditable, contentEditableClassName) }),
      placeholder: /* @__PURE__ */ React__default.createElement("div", { className: classNames(styles.contentEditable, styles.placeholder, contentEditableClassName) }, /* @__PURE__ */ React__default.createElement("p", null, placeholder2)),
      ErrorBoundary: LexicalErrorBoundary$1
    }
  ))), composerChildren.map((Child, index2) => /* @__PURE__ */ React__default.createElement(Child, { key: index2 })));
};
const DEFAULT_MARKDOWN_OPTIONS = {
  listItemIndent: "one"
};
const DefaultIcon = React__default.lazy(() => __vitePreload(() => import("./Icon-0d7b2467.js"), true ? [] : void 0, import.meta.url));
const IconFallback = () => {
  return /* @__PURE__ */ React__default.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none" });
};
const defaultIconComponentFor = (name) => {
  return /* @__PURE__ */ React__default.createElement(React__default.Suspense, { fallback: /* @__PURE__ */ React__default.createElement(IconFallback, null) }, /* @__PURE__ */ React__default.createElement(DefaultIcon, { name }));
};
const RenderRecurisveWrappers = ({
  wrappers,
  children
}) => {
  if (wrappers.length === 0) {
    return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, children);
  }
  const Wrapper = wrappers[0];
  return /* @__PURE__ */ React__default.createElement(Wrapper, null, /* @__PURE__ */ React__default.createElement(RenderRecurisveWrappers, { wrappers: wrappers.slice(1) }, children));
};
const EditorRootElement = ({ children, className }) => {
  const editorRootElementRef = React__default.useRef(null);
  const setEditorRootElementRef = corePluginHooks.usePublisher("editorRootElementRef");
  React__default.useEffect(() => {
    const popupContainer2 = document.createElement("div");
    popupContainer2.classList.add(styles.editorRoot);
    popupContainer2.classList.add(styles.popupContainer);
    if (className) {
      className.split(" ").forEach((c2) => {
        popupContainer2.classList.add(c2);
      });
    }
    document.body.appendChild(popupContainer2);
    editorRootElementRef.current = popupContainer2;
    setEditorRootElementRef(editorRootElementRef);
    return () => {
      popupContainer2.remove();
    };
  }, [className, editorRootElementRef, setEditorRootElementRef]);
  return /* @__PURE__ */ React__default.createElement("div", { className: classNames(styles.editorRoot, styles.editorWrapper, className, "mdxeditor") }, children);
};
const Methods = ({ mdxRef }) => {
  const realm2 = corePluginHooks.useRealmContext();
  const hasDiffSourcePlugin = useHasPlugin("diff-source");
  React__default.useImperativeHandle(
    mdxRef,
    () => {
      return {
        getMarkdown: () => {
          if (hasDiffSourcePlugin) {
            if (realm2.getKeyValue("viewMode") === "source") {
              return realm2.getKeyValue("markdownSourceEditorValue");
            }
          }
          return realm2.getKeyValue("markdown");
        },
        setMarkdown: (markdown) => {
          realm2.pubKey("setMarkdown", markdown);
        },
        focus: (callbackFn, opts) => {
          var _a;
          (_a = realm2.getKeyValue("rootEditor")) == null ? void 0 : _a.focus(callbackFn, opts);
        }
      };
    },
    [realm2, hasDiffSourcePlugin]
  );
  return null;
};
const MDXEditor = React__default.forwardRef((props, ref) => {
  return /* @__PURE__ */ React__default.createElement(
    RealmPluginInitializer,
    {
      plugins: [
        corePlugin({
          contentEditableClassName: props.contentEditableClassName ?? "",
          initialMarkdown: props.markdown,
          onChange: props.onChange ?? noop,
          onBlur: props.onBlur ?? noop,
          toMarkdownOptions: props.toMarkdownOptions ?? DEFAULT_MARKDOWN_OPTIONS,
          autoFocus: props.autoFocus ?? false,
          placeholder: props.placeholder ?? "",
          readOnly: Boolean(props.readOnly),
          iconComponentFor: props.iconComponentFor ?? defaultIconComponentFor,
          suppressHtmlProcessing: props.suppressHtmlProcessing ?? false,
          onError: props.onError ?? noop
        }),
        ...props.plugins || []
      ]
    },
    /* @__PURE__ */ React__default.createElement(EditorRootElement, { className: props.className }, /* @__PURE__ */ React__default.createElement(LexicalProvider, null, /* @__PURE__ */ React__default.createElement(RichTextEditor, null))),
    /* @__PURE__ */ React__default.createElement(Methods, { mdxRef: ref })
  );
});
const MdastHeadingVisitor = {
  testNode: "heading",
  visitNode: function({ mdastNode, actions }) {
    actions.addAndStepInto(LexicalRichText_1.$createHeadingNode(`h${mdastNode.depth}`));
  }
};
const LexicalHeadingVisitor = {
  testLexicalNode: LexicalRichText_1.$isHeadingNode,
  visitLexicalNode: ({ lexicalNode, actions }) => {
    const depth = parseInt(lexicalNode.getTag()[1], 10);
    actions.addAndStepInto("heading", { depth });
  }
};
const FORMATTING_KEYS = [48, 49, 50, 51, 52, 53, 54];
const ALL_HEADING_LEVELS = [1, 2, 3, 4, 5, 6];
const CODE_TO_HEADING_LEVEL_MAP = {
  49: 1,
  50: 2,
  51: 3,
  52: 4,
  53: 5,
  54: 6
};
const headingsSystem = system(
  (r2, [{ createRootEditorSubscription, convertSelectionToNode }]) => {
    const allowedHeadingLevels = r2.node(ALL_HEADING_LEVELS);
    r2.pub(createRootEditorSubscription, (theRootEditor) => {
      return theRootEditor.registerCommand(
        Lexical_1.KEY_DOWN_COMMAND,
        (event) => {
          const { keyCode, ctrlKey, metaKey, altKey } = event;
          if (FORMATTING_KEYS.includes(keyCode) && controlOrMeta(metaKey, ctrlKey) && altKey) {
            event.preventDefault();
            theRootEditor.update(() => {
              if (keyCode === 48) {
                r2.pub(convertSelectionToNode, () => Lexical_1.$createParagraphNode());
              } else {
                const allowedHeadingLevelsValues = r2.getValue(allowedHeadingLevels);
                const requestedHeadingLevel = CODE_TO_HEADING_LEVEL_MAP[keyCode];
                if (!allowedHeadingLevelsValues.includes(requestedHeadingLevel)) {
                  r2.pub(convertSelectionToNode, () => LexicalRichText_1.$createHeadingNode(`h${requestedHeadingLevel}`));
                }
              }
            });
            return true;
          }
          return false;
        },
        Lexical_1.COMMAND_PRIORITY_LOW
      );
    });
    return {
      allowedHeadingLevels
    };
  },
  [coreSystem]
);
const [headingsPlugin, headingsPluginHooks] = realmPlugin({
  id: "headings",
  systemSpec: headingsSystem,
  applyParamsToSystem(realm2, params) {
    realm2.pubKey("allowedHeadingLevels", (params == null ? void 0 : params.allowedHeadingLevels) ?? ALL_HEADING_LEVELS);
  },
  init: (realm2) => {
    realm2.pubKey("addImportVisitor", MdastHeadingVisitor);
    realm2.pubKey("addLexicalNode", LexicalRichText_1.HeadingNode);
    realm2.pubKey("addExportVisitor", LexicalHeadingVisitor);
  }
});
var LexicalHorizontalRuleNode_prod = {};
var useLexicalNodeSelection_prod = {};
var b$1 = LexicalComposerContext_1, f$4 = Lexical_1, h$2 = reactExports;
function k$5(c2, a2) {
  return c2.getEditorState().read(() => {
    let g2 = f$4.$getNodeByKey(a2);
    return null === g2 ? false : g2.isSelected();
  });
}
useLexicalNodeSelection_prod.useLexicalNodeSelection = function(c2) {
  let [a2] = b$1.useLexicalComposerContext(), [g2, l2] = h$2.useState(() => k$5(a2, c2));
  h$2.useEffect(() => {
    let e2 = true, d2 = a2.registerUpdateListener(() => {
      e2 && l2(k$5(a2, c2));
    });
    return () => {
      e2 = false;
      d2();
    };
  }, [a2, c2]);
  let m2 = h$2.useCallback((e2) => {
    a2.update(() => {
      let d2 = f$4.$getSelection();
      f$4.$isNodeSelection(d2) || (d2 = f$4.$createNodeSelection(), f$4.$setSelection(d2));
      f$4.$isNodeSelection(d2) && (e2 ? d2.add(c2) : d2.delete(c2));
    });
  }, [a2, c2]), n2 = h$2.useCallback(
    () => {
      a2.update(() => {
        const e2 = f$4.$getSelection();
        f$4.$isNodeSelection(e2) && e2.clear();
      });
    },
    [a2]
  );
  return [g2, m2, n2];
};
const useLexicalNodeSelection = useLexicalNodeSelection_prod;
var useLexicalNodeSelection_1 = useLexicalNodeSelection;
var a = LexicalComposerContext_1, f$3 = useLexicalNodeSelection_1, g$4 = LexicalUtils_1, k$4 = Lexical_1, n$3 = reactExports;
let p$3 = k$4.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
function q$4({ nodeKey: b2 }) {
  let [d2] = a.useLexicalComposerContext(), [e2, l2, m2] = f$3.useLexicalNodeSelection(b2), h2 = n$3.useCallback((c2) => {
    e2 && k$4.$isNodeSelection(k$4.$getSelection()) && (c2.preventDefault(), c2 = k$4.$getNodeByKey(b2), r$4(c2) && c2.remove());
    return false;
  }, [e2, b2]);
  n$3.useEffect(() => g$4.mergeRegister(d2.registerCommand(k$4.CLICK_COMMAND, (c2) => {
    let v3 = d2.getElementByKey(b2);
    return c2.target === v3 ? (c2.shiftKey || m2(), l2(!e2), true) : false;
  }, k$4.COMMAND_PRIORITY_LOW), d2.registerCommand(k$4.KEY_DELETE_COMMAND, h2, k$4.COMMAND_PRIORITY_LOW), d2.registerCommand(
    k$4.KEY_BACKSPACE_COMMAND,
    h2,
    k$4.COMMAND_PRIORITY_LOW
  )), [m2, d2, e2, b2, h2, l2]);
  n$3.useEffect(() => {
    let c2 = d2.getElementByKey(b2);
    null !== c2 && (c2.className = e2 ? "selected" : "");
  }, [d2, e2, b2]);
  return null;
}
let t$3 = class t extends k$4.DecoratorNode {
  static getType() {
    return "horizontalrule";
  }
  static clone(b2) {
    return new t(b2.__key);
  }
  static importJSON() {
    return u$3();
  }
  static importDOM() {
    return { hr: () => ({ conversion: w$2, priority: 0 }) };
  }
  exportJSON() {
    return { type: "horizontalrule", version: 1 };
  }
  exportDOM() {
    return { element: document.createElement("hr") };
  }
  createDOM() {
    return document.createElement("hr");
  }
  getTextContent() {
    return "\n";
  }
  isInline() {
    return false;
  }
  updateDOM() {
    return false;
  }
  decorate() {
    return n$3.createElement(q$4, { nodeKey: this.__key });
  }
};
function w$2() {
  return { node: u$3() };
}
function u$3() {
  return k$4.$applyNodeReplacement(new t$3());
}
function r$4(b2) {
  return b2 instanceof t$3;
}
LexicalHorizontalRuleNode_prod.$createHorizontalRuleNode = u$3;
LexicalHorizontalRuleNode_prod.$isHorizontalRuleNode = r$4;
LexicalHorizontalRuleNode_prod.HorizontalRuleNode = t$3;
LexicalHorizontalRuleNode_prod.INSERT_HORIZONTAL_RULE_COMMAND = p$3;
const LexicalHorizontalRuleNode = LexicalHorizontalRuleNode_prod;
var LexicalHorizontalRuleNode_1 = LexicalHorizontalRuleNode;
var LexicalList_prod = {};
var h$1 = Lexical_1, k$3 = LexicalUtils_1;
function m$3(a2) {
  let b2 = new URLSearchParams();
  b2.append("code", a2);
  for (let c2 = 1; c2 < arguments.length; c2++)
    b2.append("v", arguments[c2]);
  throw Error(`Minified Lexical error #${a2}; visit https://lexical.dev/docs/error?${b2} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function n$2(a2) {
  let b2 = 1;
  for (a2 = a2.getParent(); null != a2; ) {
    if (p$2(a2)) {
      a2 = a2.getParent();
      if (q$3(a2)) {
        b2++;
        a2 = a2.getParent();
        continue;
      }
      m$3(40);
    }
    break;
  }
  return b2;
}
function r$3(a2) {
  a2 = a2.getParent();
  q$3(a2) || m$3(40);
  let b2 = a2;
  for (; null !== b2; )
    b2 = b2.getParent(), q$3(b2) && (a2 = b2);
  return a2;
}
function t$2(a2) {
  let b2 = [];
  a2 = a2.getChildren().filter(p$2);
  for (let c2 = 0; c2 < a2.length; c2++) {
    let d2 = a2[c2], e2 = d2.getFirstChild();
    q$3(e2) ? b2 = b2.concat(t$2(e2)) : b2.push(d2);
  }
  return b2;
}
function u$2(a2) {
  return p$2(a2) && q$3(a2.getFirstChild());
}
function v$3(a2) {
  for (; null == a2.getNextSibling() && null == a2.getPreviousSibling(); ) {
    let b2 = a2.getParent();
    if (null == b2 || !p$2(a2) && !q$3(a2))
      break;
    a2 = b2;
  }
  a2.remove();
}
function w$1(a2) {
  return y$2().append(a2);
}
function z$2(a2, b2) {
  return p$2(a2) && (0 === b2.length || 1 === b2.length && a2.is(b2[0]) && 0 === a2.getChildrenSize());
}
function B$2(a2, b2) {
  a2.splice(a2.getChildrenSize(), 0, b2);
}
function C$1(a2, b2) {
  if (q$3(a2))
    return a2;
  let c2 = a2.getPreviousSibling(), d2 = a2.getNextSibling(), e2 = y$2();
  e2.setFormat(a2.getFormatType());
  e2.setIndent(a2.getIndent());
  B$2(e2, a2.getChildren());
  if (q$3(c2) && b2 === c2.getListType())
    return c2.append(e2), a2.remove(), q$3(d2) && b2 === d2.getListType() && (B$2(c2, d2.getChildren()), d2.remove()), c2;
  if (q$3(d2) && b2 === d2.getListType())
    return d2.getFirstChildOrThrow().insertBefore(e2), a2.remove(), d2;
  b2 = D$1(b2);
  b2.append(e2);
  a2.replace(b2);
  E$1(b2);
  return b2;
}
function F$1(a2, b2) {
  var c2 = a2.getLastChild();
  let d2 = b2.getFirstChild();
  c2 && d2 && u$2(c2) && u$2(d2) && (F$1(c2.getFirstChild(), d2.getFirstChild()), d2.remove());
  c2 = b2.getChildren();
  0 < c2.length && (a2.append(...c2), E$1(a2));
  b2.remove();
}
function E$1(a2, b2) {
  a2 = b2 || a2.getChildren();
  if (void 0 !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      let f2 = a2[b2];
      if (p$2(f2)) {
        let g2 = f2.getValue();
        var c2 = f2, d2 = c2.getParent(), e2 = 1;
        null != d2 && (q$3(d2) ? e2 = d2.getStart() : m$3(44));
        c2 = c2.getPreviousSiblings();
        for (d2 = 0; d2 < c2.length; d2++) {
          let l2 = c2[d2];
          p$2(l2) && !q$3(l2.getFirstChild()) && e2++;
        }
        g2 !== e2 && f2.setValue(e2);
      }
    }
}
function G$2(a2) {
  if (!u$2(a2)) {
    var b2 = a2.getParent(), c2 = b2 ? b2.getParent() : void 0, d2 = c2 ? c2.getParent() : void 0;
    if (q$3(d2) && p$2(c2) && q$3(b2)) {
      var e2 = b2 ? b2.getFirstChild() : void 0, f2 = b2 ? b2.getLastChild() : void 0;
      if (a2.is(e2))
        c2.insertBefore(a2), b2.isEmpty() && c2.remove();
      else if (a2.is(f2))
        c2.insertAfter(a2), b2.isEmpty() && c2.remove();
      else {
        var g2 = b2.getListType();
        e2 = y$2();
        let l2 = D$1(g2);
        e2.append(l2);
        a2.getPreviousSiblings().forEach((x3) => l2.append(x3));
        f2 = y$2();
        g2 = D$1(g2);
        f2.append(g2);
        B$2(g2, a2.getNextSiblings());
        c2.insertBefore(e2);
        c2.insertAfter(f2);
        c2.replace(a2);
      }
      E$1(b2);
      E$1(d2);
    }
  }
}
let H$2 = class H extends h$1.ElementNode {
  static getType() {
    return "listitem";
  }
  static clone(a2) {
    return new H(a2.__value, a2.__checked, a2.__key);
  }
  constructor(a2, b2, c2) {
    super(c2);
    this.__value = void 0 === a2 ? 1 : a2;
    this.__checked = b2;
  }
  createDOM(a2) {
    let b2 = document.createElement("li"), c2 = this.getParent();
    q$3(c2) && "check" === c2.getListType() && I$2(b2, this, null);
    b2.value = this.__value;
    J$1(b2, a2.theme, this);
    return b2;
  }
  updateDOM(a2, b2, c2) {
    let d2 = this.getParent();
    q$3(d2) && "check" === d2.getListType() && I$2(b2, this, a2);
    b2.value = this.__value;
    J$1(b2, c2.theme, this);
    return false;
  }
  static transform() {
    return (a2) => {
      let b2 = a2.getParent();
      q$3(b2) && (E$1(b2), "check" !== b2.getListType() && null != a2.getChecked() && a2.setChecked(void 0));
    };
  }
  static importDOM() {
    return { li: () => ({ conversion: K$2, priority: 0 }) };
  }
  static importJSON(a2) {
    let b2 = y$2();
    b2.setChecked(a2.checked);
    b2.setValue(a2.value);
    b2.setFormat(a2.format);
    b2.setDirection(a2.direction);
    return b2;
  }
  exportDOM(a2) {
    a2 = this.createDOM(a2._config);
    a2.style.textAlign = this.getFormatType();
    return { element: a2 };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      checked: this.getChecked(),
      type: "listitem",
      value: this.getValue(),
      version: 1
    };
  }
  append(...a2) {
    for (let b2 = 0; b2 < a2.length; b2++) {
      let c2 = a2[b2];
      if (h$1.$isElementNode(c2) && this.canMergeWith(c2)) {
        let d2 = c2.getChildren();
        this.append(...d2);
        c2.remove();
      } else
        super.append(c2);
    }
    return this;
  }
  replace(a2, b2) {
    if (p$2(a2))
      return super.replace(a2);
    this.setIndent(0);
    let c2 = this.getParentOrThrow();
    if (!q$3(c2))
      return a2;
    if (c2.__first === this.getKey())
      c2.insertBefore(a2);
    else if (c2.__last === this.getKey())
      c2.insertAfter(a2);
    else {
      let d2 = D$1(c2.getListType()), e2 = this.getNextSibling();
      for (; e2; ) {
        let f2 = e2;
        e2 = e2.getNextSibling();
        d2.append(f2);
      }
      c2.insertAfter(a2);
      a2.insertAfter(d2);
    }
    b2 && this.getChildren().forEach((d2) => {
      a2.append(d2);
    });
    this.remove();
    0 === c2.getChildrenSize() && c2.remove();
    return a2;
  }
  insertAfter(a2, b2 = true) {
    var c2 = this.getParentOrThrow();
    q$3(c2) || m$3(39);
    var d2 = this.getNextSiblings();
    if (p$2(a2))
      return b2 = super.insertAfter(a2, b2), a2 = a2.getParentOrThrow(), q$3(a2) && E$1(a2), b2;
    if (q$3(a2)) {
      c2 = a2;
      a2 = a2.getChildren();
      for (d2 = a2.length - 1; 0 <= d2; d2--)
        c2 = a2[d2], this.insertAfter(c2, b2);
      return c2;
    }
    c2.insertAfter(a2, b2);
    if (0 !== d2.length) {
      let e2 = D$1(c2.getListType());
      d2.forEach((f2) => e2.append(f2));
      a2.insertAfter(e2, b2);
    }
    return a2;
  }
  remove(a2) {
    let b2 = this.getPreviousSibling(), c2 = this.getNextSibling();
    super.remove(a2);
    b2 && c2 && u$2(b2) && u$2(c2) ? (F$1(b2.getFirstChild(), c2.getFirstChild()), c2.remove()) : c2 && (a2 = c2.getParent(), q$3(a2) && E$1(a2));
  }
  insertNewAfter(a2, b2 = true) {
    a2 = y$2(null == this.__checked ? void 0 : false);
    this.insertAfter(a2, b2);
    return a2;
  }
  collapseAtStart(a2) {
    let b2 = h$1.$createParagraphNode();
    this.getChildren().forEach((f2) => b2.append(f2));
    var c2 = this.getParentOrThrow(), d2 = c2.getParentOrThrow();
    let e2 = p$2(d2);
    1 === c2.getChildrenSize() ? e2 ? (c2.remove(), d2.select()) : (c2.insertBefore(b2), c2.remove(), c2 = a2.anchor, a2 = a2.focus, d2 = b2.getKey(), "element" === c2.type && c2.getNode().is(this) && c2.set(d2, c2.offset, "element"), "element" === a2.type && a2.getNode().is(this) && a2.set(d2, a2.offset, "element")) : (c2.insertBefore(b2), this.remove());
    return true;
  }
  getValue() {
    return this.getLatest().__value;
  }
  setValue(a2) {
    this.getWritable().__value = a2;
  }
  getChecked() {
    return this.getLatest().__checked;
  }
  setChecked(a2) {
    this.getWritable().__checked = a2;
  }
  toggleChecked() {
    this.setChecked(!this.__checked);
  }
  getIndent() {
    var a2 = this.getParent();
    if (null === a2)
      return this.getLatest().__indent;
    a2 = a2.getParentOrThrow();
    let b2 = 0;
    for (; p$2(a2); )
      a2 = a2.getParentOrThrow().getParentOrThrow(), b2++;
    return b2;
  }
  setIndent(a2) {
    "number" === typeof a2 && -1 < a2 || m$3(117);
    let b2 = this.getIndent();
    for (; b2 !== a2; )
      if (b2 < a2) {
        a: {
          var c2 = /* @__PURE__ */ new Set();
          if (u$2(this) || c2.has(this.getKey()))
            break a;
          let g2 = this.getParent();
          var d2 = this.getNextSibling(), e2 = this.getPreviousSibling();
          if (u$2(d2) && u$2(e2)) {
            if (e2 = e2.getFirstChild(), q$3(e2)) {
              e2.append(this);
              var f2 = d2.getFirstChild();
              q$3(f2) && (f2 = f2.getChildren(), B$2(e2, f2), d2.remove(), c2.add(d2.getKey()));
              E$1(e2);
            }
          } else
            u$2(d2) ? (d2 = d2.getFirstChild(), q$3(d2) && (c2 = d2.getFirstChild(), null !== c2 && c2.insertBefore(this), E$1(d2))) : u$2(e2) ? (d2 = e2.getFirstChild(), q$3(d2) && (d2.append(this), E$1(d2))) : q$3(g2) && (c2 = y$2(), f2 = D$1(g2.getListType()), c2.append(f2), f2.append(this), e2 ? e2.insertAfter(c2) : d2 ? d2.insertBefore(c2) : g2.append(c2), E$1(f2));
          q$3(g2) && E$1(g2);
        }
        b2++;
      } else
        G$2(this), b2--;
    return this;
  }
  insertBefore(a2) {
    if (p$2(a2)) {
      let b2 = this.getParentOrThrow();
      if (q$3(b2)) {
        let c2 = this.getNextSiblings();
        E$1(b2, c2);
      }
    }
    return super.insertBefore(a2);
  }
  canInsertAfter(a2) {
    return p$2(a2);
  }
  canReplaceWith(a2) {
    return p$2(a2);
  }
  canMergeWith(a2) {
    return h$1.$isParagraphNode(a2) || p$2(a2);
  }
  extractWithChild(a2, b2) {
    if (!h$1.$isRangeSelection(b2))
      return false;
    a2 = b2.anchor.getNode();
    let c2 = b2.focus.getNode();
    return this.isParentOf(a2) && this.isParentOf(c2) && this.getTextContent().length === b2.getTextContent().length;
  }
  isParentRequired() {
    return true;
  }
  createParentElementNode() {
    return D$1("bullet");
  }
};
function J$1(a2, b2, c2) {
  let d2 = [], e2 = [];
  var f2 = (b2 = b2.list) ? b2.listitem : void 0;
  if (b2 && b2.nested)
    var g2 = b2.nested.listitem;
  void 0 !== f2 && (f2 = f2.split(" "), d2.push(...f2));
  if (b2) {
    f2 = c2.getParent();
    f2 = q$3(f2) && "check" === f2.getListType();
    let l2 = c2.getChecked();
    f2 && !l2 || e2.push(b2.listitemUnchecked);
    f2 && l2 || e2.push(b2.listitemChecked);
    f2 && d2.push(l2 ? b2.listitemChecked : b2.listitemUnchecked);
  }
  void 0 !== g2 && (g2 = g2.split(" "), c2.getChildren().some((l2) => q$3(l2)) ? d2.push(...g2) : e2.push(...g2));
  0 < e2.length && k$3.removeClassNamesFromElement(a2, ...e2);
  0 < d2.length && k$3.addClassNamesToElement(
    a2,
    ...d2
  );
}
function I$2(a2, b2, c2) {
  q$3(b2.getFirstChild()) ? (a2.removeAttribute("role"), a2.removeAttribute("tabIndex"), a2.removeAttribute("aria-checked")) : (a2.setAttribute("role", "checkbox"), a2.setAttribute("tabIndex", "-1"), c2 && b2.__checked === c2.__checked || a2.setAttribute("aria-checked", b2.getChecked() ? "true" : "false"));
}
function K$2(a2) {
  a2 = k$3.isHTMLElement(a2) && "true" === a2.getAttribute("aria-checked");
  return { node: y$2(a2) };
}
function y$2(a2) {
  return h$1.$applyNodeReplacement(new H$2(void 0, a2));
}
function p$2(a2) {
  return a2 instanceof H$2;
}
let L$2 = class L extends h$1.ElementNode {
  static getType() {
    return "list";
  }
  static clone(a2) {
    return new L(a2.__listType || N$2[a2.__tag], a2.__start, a2.__key);
  }
  constructor(a2, b2, c2) {
    super(c2);
    this.__listType = a2 = N$2[a2] || a2;
    this.__tag = "number" === a2 ? "ol" : "ul";
    this.__start = b2;
  }
  getTag() {
    return this.__tag;
  }
  setListType(a2) {
    let b2 = this.getWritable();
    b2.__listType = a2;
    b2.__tag = "number" === a2 ? "ol" : "ul";
  }
  getListType() {
    return this.__listType;
  }
  getStart() {
    return this.__start;
  }
  createDOM(a2) {
    let b2 = document.createElement(this.__tag);
    1 !== this.__start && b2.setAttribute(
      "start",
      String(this.__start)
    );
    b2.__lexicalListType = this.__listType;
    O$2(b2, a2.theme, this);
    return b2;
  }
  updateDOM(a2, b2, c2) {
    if (a2.__tag !== this.__tag)
      return true;
    O$2(b2, c2.theme, this);
    return false;
  }
  static importDOM() {
    return { ol: () => ({ conversion: P$2, priority: 0 }), ul: () => ({ conversion: P$2, priority: 0 }) };
  }
  static importJSON(a2) {
    let b2 = D$1(a2.listType, a2.start);
    b2.setFormat(a2.format);
    b2.setIndent(a2.indent);
    b2.setDirection(a2.direction);
    return b2;
  }
  exportDOM(a2) {
    ({ element: a2 } = super.exportDOM(a2));
    a2 && k$3.isHTMLElement(a2) && (1 !== this.__start && a2.setAttribute("start", String(this.__start)), "check" === this.__listType && a2.setAttribute("__lexicalListType", "check"));
    return { element: a2 };
  }
  exportJSON() {
    return { ...super.exportJSON(), listType: this.getListType(), start: this.getStart(), tag: this.getTag(), type: "list", version: 1 };
  }
  canBeEmpty() {
    return false;
  }
  canIndent() {
    return false;
  }
  append(...a2) {
    for (let c2 = 0; c2 < a2.length; c2++) {
      var b2 = a2[c2];
      if (p$2(b2))
        super.append(b2);
      else {
        let d2 = y$2();
        q$3(b2) ? d2.append(b2) : h$1.$isElementNode(b2) ? (b2 = h$1.$createTextNode(b2.getTextContent()), d2.append(b2)) : d2.append(b2);
        super.append(d2);
      }
    }
    E$1(this);
    return this;
  }
  extractWithChild(a2) {
    return p$2(a2);
  }
};
function O$2(a2, b2, c2) {
  let d2 = [], e2 = [];
  var f2 = b2.list;
  if (void 0 !== f2) {
    let l2 = f2[`${c2.__tag}Depth`] || [];
    b2 = n$2(c2) - 1;
    let x3 = b2 % l2.length;
    var g2 = l2[x3];
    let M2 = f2[c2.__tag], A2;
    f2 = f2.nested;
    void 0 !== f2 && f2.list && (A2 = f2.list);
    void 0 !== M2 && d2.push(M2);
    if (void 0 !== g2)
      for (g2 = g2.split(" "), d2.push(...g2), g2 = 0; g2 < l2.length; g2++)
        g2 !== x3 && e2.push(c2.__tag + g2);
    void 0 !== A2 && (c2 = A2.split(" "), 1 < b2 ? d2.push(...c2) : e2.push(...c2));
  }
  0 < e2.length && k$3.removeClassNamesFromElement(a2, ...e2);
  0 < d2.length && k$3.addClassNamesToElement(a2, ...d2);
}
function Q$2(a2) {
  let b2 = [];
  for (let d2 = 0; d2 < a2.length; d2++) {
    var c2 = a2[d2];
    p$2(c2) ? (b2.push(c2), c2 = c2.getChildren(), 1 < c2.length && c2.forEach((e2) => {
      q$3(e2) && b2.push(w$1(e2));
    })) : b2.push(w$1(c2));
  }
  return b2;
}
function P$2(a2) {
  let b2 = a2.nodeName.toLowerCase(), c2 = null;
  "ol" === b2 ? c2 = D$1("number", a2.start) : "ul" === b2 && (c2 = k$3.isHTMLElement(a2) && "check" === a2.getAttribute("__lexicallisttype") ? D$1("check") : D$1("bullet"));
  return { after: Q$2, node: c2 };
}
let N$2 = { ol: "number", ul: "bullet" };
function D$1(a2, b2 = 1) {
  return h$1.$applyNodeReplacement(new L$2(a2, b2));
}
function q$3(a2) {
  return a2 instanceof L$2;
}
let R$2 = h$1.createCommand("INSERT_UNORDERED_LIST_COMMAND"), S$2 = h$1.createCommand("INSERT_ORDERED_LIST_COMMAND"), T$2 = h$1.createCommand("INSERT_CHECK_LIST_COMMAND"), U$2 = h$1.createCommand("REMOVE_LIST_COMMAND");
LexicalList_prod.$createListItemNode = y$2;
LexicalList_prod.$createListNode = D$1;
LexicalList_prod.$getListDepth = n$2;
LexicalList_prod.$handleListInsertParagraph = function() {
  var a2 = h$1.$getSelection();
  if (!h$1.$isRangeSelection(a2) || !a2.isCollapsed())
    return false;
  a2 = a2.anchor.getNode();
  if (!p$2(a2) || 0 !== a2.getChildrenSize())
    return false;
  var b2 = r$3(a2), c2 = a2.getParent();
  q$3(c2) || m$3(40);
  let d2 = c2.getParent(), e2;
  if (h$1.$isRootOrShadowRoot(d2))
    e2 = h$1.$createParagraphNode(), b2.insertAfter(e2);
  else if (p$2(d2))
    e2 = y$2(), d2.insertAfter(e2);
  else
    return false;
  e2.select();
  b2 = a2.getNextSiblings();
  if (0 < b2.length) {
    let f2 = D$1(c2.getListType());
    h$1.$isParagraphNode(e2) ? e2.insertAfter(f2) : (c2 = y$2(), c2.append(f2), e2.insertAfter(c2));
    b2.forEach((g2) => {
      g2.remove();
      f2.append(g2);
    });
  }
  v$3(a2);
  return true;
};
LexicalList_prod.$isListItemNode = p$2;
LexicalList_prod.$isListNode = q$3;
LexicalList_prod.INSERT_CHECK_LIST_COMMAND = T$2;
LexicalList_prod.INSERT_ORDERED_LIST_COMMAND = S$2;
LexicalList_prod.INSERT_UNORDERED_LIST_COMMAND = R$2;
LexicalList_prod.ListItemNode = H$2;
LexicalList_prod.ListNode = L$2;
LexicalList_prod.REMOVE_LIST_COMMAND = U$2;
LexicalList_prod.insertList = function(a2, b2) {
  a2.update(() => {
    var c2 = h$1.$getSelection();
    if (h$1.$INTERNAL_isPointSelection(c2)) {
      var d2 = c2.getNodes();
      c2 = c2.anchor.getNode();
      var e2 = c2.getParent();
      if (z$2(c2, d2))
        d2 = D$1(b2), h$1.$isRootOrShadowRoot(e2) ? (c2.replace(d2), e2 = y$2(), h$1.$isElementNode(c2) && (e2.setFormat(c2.getFormatType()), e2.setIndent(c2.getIndent())), d2.append(e2)) : p$2(c2) && (c2 = c2.getParentOrThrow(), B$2(d2, c2.getChildren()), c2.replace(d2));
      else
        for (c2 = /* @__PURE__ */ new Set(), e2 = 0; e2 < d2.length; e2++) {
          var f2 = d2[e2];
          if (h$1.$isElementNode(f2) && f2.isEmpty() && !p$2(f2) && !c2.has(f2.getKey()))
            C$1(
              f2,
              b2
            );
          else if (h$1.$isLeafNode(f2))
            for (f2 = f2.getParent(); null != f2; ) {
              let l2 = f2.getKey();
              if (q$3(f2)) {
                if (!c2.has(l2)) {
                  var g2 = D$1(b2);
                  B$2(g2, f2.getChildren());
                  f2.replace(g2);
                  E$1(g2);
                  c2.add(l2);
                }
                break;
              } else {
                g2 = f2.getParent();
                if (h$1.$isRootOrShadowRoot(g2) && !c2.has(l2)) {
                  c2.add(l2);
                  C$1(f2, b2);
                  break;
                }
                f2 = g2;
              }
            }
        }
    }
  });
};
LexicalList_prod.removeList = function(a2) {
  a2.update(() => {
    let b2 = h$1.$getSelection();
    if (h$1.$isRangeSelection(b2)) {
      var c2 = /* @__PURE__ */ new Set(), d2 = b2.getNodes(), e2 = b2.anchor.getNode();
      if (z$2(e2, d2))
        c2.add(r$3(e2));
      else
        for (e2 = 0; e2 < d2.length; e2++) {
          var f2 = d2[e2];
          h$1.$isLeafNode(f2) && (f2 = k$3.$getNearestNodeOfType(f2, H$2), null != f2 && c2.add(r$3(f2)));
        }
      for (let g2 of c2) {
        c2 = g2;
        d2 = t$2(g2);
        for (let l2 of d2)
          d2 = h$1.$createParagraphNode(), B$2(d2, l2.getChildren()), c2.insertAfter(d2), c2 = d2, l2.__key === b2.anchor.key && b2.anchor.set(d2.getKey(), 0, "element"), l2.__key === b2.focus.key && b2.focus.set(d2.getKey(), 0, "element"), l2.remove();
        g2.remove();
      }
    }
  });
};
const LexicalList = LexicalList_prod;
var LexicalList_1 = LexicalList;
const MdastListVisitor = {
  testNode: "list",
  visitNode: function({ mdastNode, lexicalParent, actions }) {
    var _a;
    const listType = ((_a = mdastNode.children) == null ? void 0 : _a.some((e2) => typeof e2.checked === "boolean")) ? "check" : mdastNode.ordered ? "number" : "bullet";
    const lexicalNode = LexicalList_1.$createListNode(listType);
    if (LexicalList_1.$isListItemNode(lexicalParent)) {
      const dedicatedParent = LexicalList_1.$createListItemNode();
      dedicatedParent.append(lexicalNode);
      lexicalParent.insertAfter(dedicatedParent);
    } else {
      lexicalParent.append(lexicalNode);
    }
    actions.visitChildren(mdastNode, lexicalNode);
  }
};
const MdastListItemVisitor = {
  testNode: "listItem",
  visitNode({ mdastNode, actions, lexicalParent }) {
    const isChecked = lexicalParent.getListType() === "check" ? mdastNode.checked ?? false : void 0;
    actions.addAndStepInto(LexicalList_1.$createListItemNode(isChecked));
  }
};
const LexicalListVisitor = {
  testLexicalNode: LexicalList_1.$isListNode,
  visitLexicalNode: ({ lexicalNode, actions }) => {
    actions.addAndStepInto("list", {
      ordered: lexicalNode.getListType() === "number",
      spread: false
    });
  }
};
const LexicalListItemVisitor = {
  testLexicalNode: LexicalList_1.$isListItemNode,
  visitLexicalNode: ({ lexicalNode, mdastParent, actions }) => {
    const children = lexicalNode.getChildren();
    const firstChild = children[0];
    if (children.length === 1 && LexicalList_1.$isListNode(firstChild)) {
      const prevListItemNode = mdastParent.children.at(-1);
      actions.visitChildren(lexicalNode, prevListItemNode);
    } else {
      const listItem2 = actions.appendToParent(mdastParent, {
        type: "listItem",
        checked: lexicalNode.getChecked(),
        spread: false,
        children: [{ type: "paragraph", children: [] }]
      });
      actions.visitChildren(lexicalNode, listItem2.children[0]);
    }
  }
};
var LexicalTabIndentationPlugin_prod = {};
var d$3 = LexicalComposerContext_1, e$3 = LexicalUtils_1, f$2 = Lexical_1, g$3 = reactExports;
function h(b2) {
  var a2 = b2.getNodes();
  if (0 < e$3.$filter(a2, (c2) => f$2.$isBlockElementNode(c2) && c2.canIndent() ? c2 : null).length)
    return true;
  a2 = b2.anchor;
  b2 = b2.focus;
  b2 = b2.isBefore(a2) ? b2 : a2;
  a2 = b2.getNode();
  a2 = e$3.$getNearestBlockElementAncestorOrThrow(a2);
  if (a2.canIndent()) {
    a2 = a2.getKey();
    let c2 = f$2.$createRangeSelection();
    c2.anchor.set(a2, 0, "element");
    c2.focus.set(a2, 0, "element");
    c2 = f$2.$normalizeSelection__EXPERIMENTAL(c2);
    if (c2.anchor.is(b2))
      return true;
  }
  return false;
}
function k$2(b2) {
  return b2.registerCommand(f$2.KEY_TAB_COMMAND, (a2) => {
    let c2 = f$2.$getSelection();
    if (!f$2.$isRangeSelection(c2))
      return false;
    a2.preventDefault();
    a2 = h(c2) ? a2.shiftKey ? f$2.OUTDENT_CONTENT_COMMAND : f$2.INDENT_CONTENT_COMMAND : f$2.INSERT_TAB_COMMAND;
    return b2.dispatchCommand(a2, void 0);
  }, f$2.COMMAND_PRIORITY_EDITOR);
}
LexicalTabIndentationPlugin_prod.TabIndentationPlugin = function() {
  let [b2] = d$3.useLexicalComposerContext();
  g$3.useEffect(() => k$2(b2));
  return null;
};
LexicalTabIndentationPlugin_prod.registerTabIndentation = k$2;
const LexicalTabIndentationPlugin = LexicalTabIndentationPlugin_prod;
var LexicalTabIndentationPlugin_1 = LexicalTabIndentationPlugin;
var LexicalCheckListPlugin_prod = {};
var e$2 = LexicalList_1, g$2 = LexicalComposerContext_1, k$1 = LexicalUtils_1, l$1 = Lexical_1, m$2 = reactExports;
function n$1(a2, c2) {
  let b2 = a2.target;
  if (null !== b2 && k$1.isHTMLElement(b2)) {
    var d2 = b2.firstChild;
    (null == d2 || !k$1.isHTMLElement(d2) || "UL" !== d2.tagName && "OL" !== d2.tagName) && (d2 = b2.parentNode) && "check" === d2.__lexicalListType && (a2 = a2.pageX, d2 = b2.getBoundingClientRect(), ("rtl" === b2.dir ? a2 < d2.right && a2 > d2.right - 20 : a2 > d2.left && a2 < d2.left + 20) && c2());
  }
}
function p$1(a2) {
  n$1(a2, () => {
    let c2 = a2.target, b2 = q$2(c2);
    null != b2 && b2.isEditable() && b2.update(() => {
      if (a2.target) {
        let d2 = l$1.$getNearestNodeFromDOMNode(c2);
        e$2.$isListItemNode(d2) && (c2.focus(), d2.toggleChecked());
      }
    });
  });
}
function r$2(a2) {
  n$1(a2, () => {
    a2.preventDefault();
  });
}
function q$2(a2) {
  for (; a2; ) {
    if (a2.__lexicalEditor)
      return a2.__lexicalEditor;
    a2 = a2.parentNode;
  }
  return null;
}
function t$1() {
  let a2 = document.activeElement;
  return null != a2 && "LI" === a2.tagName && null != a2.parentNode && "check" === a2.parentNode.__lexicalListType ? a2 : null;
}
function u$1(a2, c2) {
  let b2 = c2 ? a2.getPreviousSibling() : a2.getNextSibling();
  for (; null == b2 && e$2.$isListItemNode(a2); )
    a2 = a2.getParentOrThrow().getParent(), null != a2 && (b2 = c2 ? a2.getPreviousSibling() : a2.getNextSibling());
  for (; e$2.$isListItemNode(b2); ) {
    a2 = c2 ? b2.getLastChild() : b2.getFirstChild();
    if (!e$2.$isListNode(a2))
      return b2;
    b2 = c2 ? a2.getLastChild() : a2.getFirstChild();
  }
  return null;
}
function v$2(a2, c2, b2) {
  let d2 = t$1();
  null != d2 && c2.update(() => {
    var f2 = l$1.$getNearestNodeFromDOMNode(d2);
    if (e$2.$isListItemNode(f2) && (f2 = u$1(f2, b2), null != f2)) {
      f2.selectStart();
      let h2 = c2.getElementByKey(f2.__key);
      null != h2 && (a2.preventDefault(), setTimeout(() => {
        h2.focus();
      }, 0));
    }
  });
  return false;
}
LexicalCheckListPlugin_prod.CheckListPlugin = function() {
  let [a2] = g$2.useLexicalComposerContext();
  m$2.useEffect(() => k$1.mergeRegister(
    a2.registerCommand(e$2.INSERT_CHECK_LIST_COMMAND, () => {
      e$2.insertList(a2, "check");
      return true;
    }, l$1.COMMAND_PRIORITY_LOW),
    a2.registerCommand(l$1.KEY_ARROW_DOWN_COMMAND, (c2) => v$2(c2, a2, false), l$1.COMMAND_PRIORITY_LOW),
    a2.registerCommand(l$1.KEY_ARROW_UP_COMMAND, (c2) => v$2(c2, a2, true), l$1.COMMAND_PRIORITY_LOW),
    a2.registerCommand(l$1.KEY_ESCAPE_COMMAND, () => {
      if (null != t$1()) {
        let c2 = a2.getRootElement();
        null != c2 && c2.focus();
        return true;
      }
      return false;
    }, l$1.COMMAND_PRIORITY_LOW),
    a2.registerCommand(l$1.KEY_SPACE_COMMAND, (c2) => {
      let b2 = t$1();
      return null != b2 && a2.isEditable() ? (a2.update(() => {
        let d2 = l$1.$getNearestNodeFromDOMNode(b2);
        e$2.$isListItemNode(d2) && (c2.preventDefault(), d2.toggleChecked());
      }), true) : false;
    }, l$1.COMMAND_PRIORITY_LOW),
    a2.registerCommand(l$1.KEY_ARROW_LEFT_COMMAND, (c2) => a2.getEditorState().read(() => {
      var b2 = l$1.$getSelection();
      if (l$1.$isRangeSelection(b2) && b2.isCollapsed()) {
        var { anchor: d2 } = b2;
        if ((b2 = "element" === d2.type) || 0 === d2.offset) {
          d2 = d2.getNode();
          let f2 = k$1.$findMatchingParent(d2, (h2) => l$1.$isElementNode(h2) && !h2.isInline());
          if (e$2.$isListItemNode(f2)) {
            let h2 = f2.getParent();
            if (e$2.$isListNode(h2) && "check" === h2.getListType() && (b2 || f2.getFirstDescendant() === d2) && (b2 = a2.getElementByKey(f2.__key), null != b2 && document.activeElement !== b2))
              return b2.focus(), c2.preventDefault(), true;
          }
        }
      }
      return false;
    }), l$1.COMMAND_PRIORITY_LOW),
    a2.registerRootListener((c2, b2) => {
      null !== c2 && (c2.addEventListener("click", p$1), c2.addEventListener("pointerdown", r$2));
      null !== b2 && (b2.removeEventListener("click", p$1), b2.removeEventListener("pointerdown", r$2));
    })
  ));
  return null;
};
const LexicalCheckListPlugin = LexicalCheckListPlugin_prod;
var LexicalCheckListPlugin_1 = LexicalCheckListPlugin;
var LexicalListPlugin_prod = {};
var b = LexicalList_1, c$1 = LexicalComposerContext_1, d$2 = reactExports, e$1 = LexicalUtils_1, f$1 = Lexical_1;
function g$1(a2) {
  d$2.useEffect(() => e$1.mergeRegister(a2.registerCommand(b.INSERT_ORDERED_LIST_COMMAND, () => {
    b.insertList(a2, "number");
    return true;
  }, f$1.COMMAND_PRIORITY_LOW), a2.registerCommand(b.INSERT_UNORDERED_LIST_COMMAND, () => {
    b.insertList(a2, "bullet");
    return true;
  }, f$1.COMMAND_PRIORITY_LOW), a2.registerCommand(b.REMOVE_LIST_COMMAND, () => {
    b.removeList(a2);
    return true;
  }, f$1.COMMAND_PRIORITY_LOW), a2.registerCommand(f$1.INSERT_PARAGRAPH_COMMAND, () => b.$handleListInsertParagraph() ? true : false, f$1.COMMAND_PRIORITY_LOW)), [a2]);
}
LexicalListPlugin_prod.ListPlugin = function() {
  let [a2] = c$1.useLexicalComposerContext();
  d$2.useEffect(() => {
    if (!a2.hasNodes([b.ListNode, b.ListItemNode]))
      throw Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
  }, [a2]);
  g$1(a2);
  return null;
};
const LexicalListPlugin = LexicalListPlugin_prod;
var LexicalListPlugin_1 = LexicalListPlugin;
const tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};
const gfmTaskListItem = {
  text: {
    [91]: tasklistCheck
  }
};
function tokenizeTasklistCheck(effects, ok2, nok) {
  const self2 = this;
  return open;
  function open(code2) {
    if (
      // Exit if there’s stuff before.
      self2.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code2);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code2);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code2) {
    if (markdownLineEndingOrSpace(code2)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueUnchecked");
      return close;
    }
    if (code2 === 88 || code2 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueChecked");
      return close;
    }
    return nok(code2);
  }
  function close(code2) {
    if (code2 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code2);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return effects.check(
        {
          tokenize: spaceThenNonSpace
        },
        ok2,
        nok
      )(code2);
    }
    return nok(code2);
  }
}
function spaceThenNonSpace(effects, ok2, nok) {
  return factorySpace(effects, after, "whitespace");
  function after(code2) {
    return code2 === null ? nok(code2) : ok2(code2);
  }
}
const gfmTaskListItemFromMarkdown = {
  exit: {
    taskListCheckValueChecked: exitCheck,
    taskListCheckValueUnchecked: exitCheck,
    paragraph: exitParagraphWithTaskListItem
  }
};
const gfmTaskListItemToMarkdown = {
  unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
  handlers: { listItem: listItemWithTaskListItem }
};
function exitCheck(token) {
  const node2 = (
    /** @type {ListItem} */
    this.stack[this.stack.length - 2]
  );
  node2.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = (
    /** @type {Parents} */
    this.stack[this.stack.length - 2]
  );
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = (
      /** @type {Paragraph} */
      this.stack[this.stack.length - 1]
    );
    const head = node2.children[0];
    if (head && head.type === "text") {
      const siblings = parent.children;
      let index2 = -1;
      let firstParaghraph;
      while (++index2 < siblings.length) {
        const sibling = siblings[index2];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
          head.position.start.column++;
          head.position.start.offset++;
          node2.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node2, parent, context, safeOptions) {
  const head = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = track(safeOptions);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = listItem(node2, parent, context, {
    ...safeOptions,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + checkbox;
  }
}
const ListTypeCommandMap = /* @__PURE__ */ new Map([
  ["number", LexicalList_1.INSERT_ORDERED_LIST_COMMAND],
  ["bullet", LexicalList_1.INSERT_UNORDERED_LIST_COMMAND],
  ["check", LexicalList_1.INSERT_CHECK_LIST_COMMAND],
  ["", LexicalList_1.REMOVE_LIST_COMMAND]
]);
const listsSystem = system(
  (r2, [{ activeEditor, currentSelection }]) => {
    const currentListType = r2.node("");
    const applyListType = r2.node();
    r2.sub(r2.pipe(applyListType, r2.o.withLatestFrom(activeEditor)), ([listType, theEditor]) => {
      theEditor == null ? void 0 : theEditor.dispatchCommand(ListTypeCommandMap.get(listType), void 0);
    });
    r2.sub(r2.pipe(currentSelection, r2.o.withLatestFrom(activeEditor)), ([selection, theEditor]) => {
      if (!selection || !theEditor) {
        return;
      }
      const anchorNode = selection.anchor.getNode();
      let element2 = anchorNode.getKey() === "root" ? anchorNode : LexicalUtils_1.$findMatchingParent(anchorNode, (e2) => {
        const parent = e2.getParent();
        return parent !== null && Lexical_1.$isRootOrShadowRoot(parent);
      });
      if (element2 === null) {
        element2 = anchorNode.getTopLevelElementOrThrow();
      }
      const elementKey = element2.getKey();
      const elementDOM = theEditor.getElementByKey(elementKey);
      if (elementDOM !== null) {
        if (LexicalList_1.$isListNode(element2)) {
          const parentList = LexicalUtils_1.$getNearestNodeOfType(anchorNode, LexicalList_1.ListNode);
          const type = parentList ? parentList.getListType() : element2.getListType();
          r2.pub(currentListType, type);
        } else {
          r2.pub(currentListType, null);
        }
      }
    });
    return { currentListType, applyListType };
  },
  [coreSystem]
);
const [
  /** @internal */
  listsPlugin,
  /** @internal */
  listsPluginHooks
] = realmPlugin({
  id: "lists",
  systemSpec: listsSystem,
  init: (realm2) => {
    var _a;
    realm2.pubKey("addMdastExtension", gfmTaskListItemFromMarkdown);
    realm2.pubKey("addSyntaxExtension", gfmTaskListItem);
    realm2.pubKey("addImportVisitor", MdastListVisitor);
    realm2.pubKey("addImportVisitor", MdastListItemVisitor);
    realm2.pubKey("addLexicalNode", LexicalList_1.ListItemNode);
    realm2.pubKey("addLexicalNode", LexicalList_1.ListNode);
    realm2.pubKey("addExportVisitor", LexicalListVisitor);
    realm2.pubKey("addExportVisitor", LexicalListItemVisitor);
    realm2.pubKey("addToMarkdownExtension", gfmTaskListItemToMarkdown);
    (_a = realm2.getKeyValue("rootEditor")) == null ? void 0 : _a.registerCommand(Lexical_1.INDENT_CONTENT_COMMAND, () => !isIndentPermitted(7), Lexical_1.COMMAND_PRIORITY_CRITICAL);
    realm2.pubKey("addComposerChild", LexicalTabIndentationPlugin_1.TabIndentationPlugin);
    realm2.pubKey("addComposerChild", LexicalListPlugin_1.ListPlugin);
    realm2.pubKey("addComposerChild", LexicalCheckListPlugin_1.CheckListPlugin);
    realm2.pubKey("addNestedEditorChild", LexicalTabIndentationPlugin_1.TabIndentationPlugin);
    realm2.pubKey("addNestedEditorChild", LexicalListPlugin_1.ListPlugin);
    realm2.pubKey("addNestedEditorChild", LexicalCheckListPlugin_1.CheckListPlugin);
  }
});
function getElementNodesInSelection(selection) {
  const nodesInSelection = selection.getNodes();
  if (nodesInSelection.length === 0) {
    return /* @__PURE__ */ new Set([selection.anchor.getNode().getParentOrThrow(), selection.focus.getNode().getParentOrThrow()]);
  }
  return new Set(nodesInSelection.map((n2) => Lexical_1.$isElementNode(n2) ? n2 : n2.getParentOrThrow()));
}
function isIndentPermitted(maxDepth) {
  const selection = Lexical_1.$getSelection();
  if (!Lexical_1.$isRangeSelection(selection)) {
    return false;
  }
  const elementNodesInSelection = getElementNodesInSelection(selection);
  let totalDepth = 0;
  for (const elementNode of elementNodesInSelection) {
    if (LexicalList_1.$isListNode(elementNode)) {
      totalDepth = Math.max(LexicalList_1.$getListDepth(elementNode) + 1, totalDepth);
    } else if (LexicalList_1.$isListItemNode(elementNode)) {
      const parent = elementNode.getParent();
      if ((parent == null ? void 0 : parent.getChildren().length) === 1) {
        const grandParentListItem = parent == null ? void 0 : parent.getParent();
        if (LexicalList_1.$isListItemNode(grandParentListItem) && grandParentListItem.getChildren().length === 1) {
          return false;
        }
      }
      if (!LexicalList_1.$isListNode(parent)) {
        throw new Error("ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent.");
      }
      totalDepth = Math.max(LexicalList_1.$getListDepth(parent) + 1, totalDepth);
    }
  }
  return totalDepth <= maxDepth;
}
var LexicalLink_prod = {};
var l = LexicalUtils_1, m$1 = Lexical_1;
let n = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
class p extends m$1.ElementNode {
  static getType() {
    return "link";
  }
  static clone(a2) {
    return new p(a2.__url, { rel: a2.__rel, target: a2.__target, title: a2.__title }, a2.__key);
  }
  constructor(a2, b2 = {}, e2) {
    super(e2);
    let { target: h2 = null, rel: k2 = null, title: f2 = null } = b2;
    this.__url = a2;
    this.__target = h2;
    this.__rel = k2;
    this.__title = f2;
  }
  createDOM(a2) {
    let b2 = document.createElement("a");
    b2.href = this.sanitizeUrl(this.__url);
    null !== this.__target && (b2.target = this.__target);
    null !== this.__rel && (b2.rel = this.__rel);
    null !== this.__title && (b2.title = this.__title);
    l.addClassNamesToElement(
      b2,
      a2.theme.link
    );
    return b2;
  }
  updateDOM(a2, b2) {
    let e2 = this.__url, h2 = this.__target, k2 = this.__rel, f2 = this.__title;
    e2 !== a2.__url && (b2.href = e2);
    h2 !== a2.__target && (h2 ? b2.target = h2 : b2.removeAttribute("target"));
    k2 !== a2.__rel && (k2 ? b2.rel = k2 : b2.removeAttribute("rel"));
    f2 !== a2.__title && (f2 ? b2.title = f2 : b2.removeAttribute("title"));
    return false;
  }
  static importDOM() {
    return { a: () => ({ conversion: q$1, priority: 1 }) };
  }
  static importJSON(a2) {
    let b2 = r$1(a2.url, { rel: a2.rel, target: a2.target, title: a2.title });
    b2.setFormat(a2.format);
    b2.setIndent(a2.indent);
    b2.setDirection(a2.direction);
    return b2;
  }
  sanitizeUrl(a2) {
    try {
      let b2 = new URL(a2);
      if (!n.has(b2.protocol))
        return "about:blank";
    } catch (b2) {
    }
    return a2;
  }
  exportJSON() {
    return { ...super.exportJSON(), rel: this.getRel(), target: this.getTarget(), title: this.getTitle(), type: "link", url: this.getURL(), version: 1 };
  }
  getURL() {
    return this.getLatest().__url;
  }
  setURL(a2) {
    this.getWritable().__url = a2;
  }
  getTarget() {
    return this.getLatest().__target;
  }
  setTarget(a2) {
    this.getWritable().__target = a2;
  }
  getRel() {
    return this.getLatest().__rel;
  }
  setRel(a2) {
    this.getWritable().__rel = a2;
  }
  getTitle() {
    return this.getLatest().__title;
  }
  setTitle(a2) {
    this.getWritable().__title = a2;
  }
  insertNewAfter(a2, b2 = true) {
    a2 = r$1(this.__url, { rel: this.__rel, target: this.__target, title: this.__title });
    this.insertAfter(a2, b2);
    return a2;
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
  canBeEmpty() {
    return false;
  }
  isInline() {
    return true;
  }
  extractWithChild(a2, b2) {
    if (!m$1.$isRangeSelection(b2))
      return false;
    a2 = b2.anchor.getNode();
    let e2 = b2.focus.getNode();
    return this.isParentOf(a2) && this.isParentOf(e2) && 0 < b2.getTextContent().length;
  }
}
function q$1(a2) {
  let b2 = null;
  if (l.isHTMLAnchorElement(a2)) {
    let e2 = a2.textContent;
    if (null !== e2 && "" !== e2 || 0 < a2.children.length)
      b2 = r$1(a2.getAttribute("href") || "", { rel: a2.getAttribute("rel"), target: a2.getAttribute("target"), title: a2.getAttribute("title") });
  }
  return { node: b2 };
}
function r$1(a2, b2) {
  return m$1.$applyNodeReplacement(new p(a2, b2));
}
function u(a2) {
  return a2 instanceof p;
}
let v$1 = class v extends p {
  static getType() {
    return "autolink";
  }
  static clone(a2) {
    return new v(a2.__url, { rel: a2.__rel, target: a2.__target, title: a2.__title }, a2.__key);
  }
  static importJSON(a2) {
    let b2 = w(a2.url, { rel: a2.rel, target: a2.target, title: a2.title });
    b2.setFormat(a2.format);
    b2.setIndent(a2.indent);
    b2.setDirection(a2.direction);
    return b2;
  }
  static importDOM() {
    return null;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "autolink", version: 1 };
  }
  insertNewAfter(a2, b2 = true) {
    a2 = this.getParentOrThrow().insertNewAfter(a2, b2);
    return m$1.$isElementNode(a2) ? (b2 = w(this.__url, { rel: this.__rel, target: this.__target, title: this.__title }), a2.append(b2), b2) : null;
  }
};
function w(a2, b2) {
  return m$1.$applyNodeReplacement(new v$1(a2, b2));
}
let x$1 = m$1.createCommand("TOGGLE_LINK_COMMAND");
function y$1(a2, b2) {
  for (; null !== a2 && null !== a2.getParent() && !b2(a2); )
    a2 = a2.getParentOrThrow();
  return b2(a2) ? a2 : null;
}
LexicalLink_prod.$createAutoLinkNode = w;
LexicalLink_prod.$createLinkNode = r$1;
LexicalLink_prod.$isAutoLinkNode = function(a2) {
  return a2 instanceof v$1;
};
LexicalLink_prod.$isLinkNode = u;
LexicalLink_prod.AutoLinkNode = v$1;
LexicalLink_prod.LinkNode = p;
LexicalLink_prod.TOGGLE_LINK_COMMAND = x$1;
LexicalLink_prod.toggleLink = function(a2, b2 = {}) {
  let { target: e2, title: h2 } = b2, k2 = void 0 === b2.rel ? "noreferrer" : b2.rel;
  b2 = m$1.$getSelection();
  if (m$1.$isRangeSelection(b2))
    if (b2 = b2.extract(), null === a2)
      b2.forEach((f2) => {
        f2 = f2.getParent();
        if (u(f2)) {
          let d2 = f2.getChildren();
          for (let c2 = 0; c2 < d2.length; c2++)
            f2.insertBefore(d2[c2]);
          f2.remove();
        }
      });
    else {
      if (1 === b2.length) {
        let c2 = y$1(b2[0], u);
        if (null !== c2) {
          c2.setURL(a2);
          void 0 !== e2 && c2.setTarget(e2);
          null !== k2 && c2.setRel(k2);
          void 0 !== h2 && c2.setTitle(h2);
          return;
        }
      }
      let f2 = null, d2 = null;
      b2.forEach((c2) => {
        var g2 = c2.getParent();
        if (g2 !== d2 && null !== g2 && (!m$1.$isElementNode(c2) || c2.isInline()))
          if (u(g2))
            d2 = g2, g2.setURL(a2), void 0 !== e2 && g2.setTarget(e2), null !== k2 && d2.setRel(k2), void 0 !== h2 && d2.setTitle(h2);
          else if (g2.is(f2) || (f2 = g2, d2 = r$1(a2, { rel: k2, target: e2, title: h2 }), u(g2) ? null === c2.getPreviousSibling() ? g2.insertBefore(d2) : g2.insertAfter(d2) : c2.insertBefore(d2)), u(c2)) {
            if (!c2.is(d2)) {
              if (null !== d2) {
                g2 = c2.getChildren();
                for (let t3 = 0; t3 < g2.length; t3++)
                  d2.append(g2[t3]);
              }
              c2.remove();
            }
          } else
            null !== d2 && d2.append(c2);
      });
    }
};
const LexicalLink = LexicalLink_prod;
var LexicalLink_1 = LexicalLink;
const MdastBlockQuoteVisitor = {
  testNode: "blockquote",
  visitNode({ actions }) {
    actions.addAndStepInto(LexicalRichText_1.$createQuoteNode());
  }
};
const LexicalQuoteVisitor = {
  testLexicalNode: LexicalRichText_1.$isQuoteNode,
  visitLexicalNode: ({ lexicalNode, mdastParent, actions }) => {
    const paragraph2 = { type: "paragraph", children: [] };
    actions.appendToParent(mdastParent, { type: "blockquote", children: [paragraph2] });
    actions.visitChildren(lexicalNode, paragraph2);
  }
};
const [
  /** @internal */
  quotePlugin,
  /** @internal */
  quotePluginHooks
] = realmPlugin({
  id: "quote",
  systemSpec: system(() => {
    return {};
  }, [coreSystem]),
  init: (realm2) => {
    realm2.pubKey("addImportVisitor", MdastBlockQuoteVisitor);
    realm2.pubKey("addLexicalNode", LexicalRichText_1.QuoteNode);
    realm2.pubKey("addExportVisitor", LexicalQuoteVisitor);
  }
});
function voidEmitter() {
  let subscription = noop;
  return {
    publish: () => {
      subscription();
    },
    subscribe: (cb2) => {
      subscription = cb2;
    }
  };
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class CodeBlockNode extends Lexical_1.DecoratorNode {
  constructor(code2, language, meta, key) {
    super(key);
    __publicField(this, "__code");
    __publicField(this, "__meta");
    __publicField(this, "__language");
    __publicField(this, "__focusEmitter", voidEmitter());
    __publicField(this, "setCode", (code3) => {
      if (code3 !== this.__code) {
        this.getWritable().__code = code3;
      }
    });
    __publicField(this, "setMeta", (meta2) => {
      if (meta2 !== this.__meta) {
        this.getWritable().__meta = meta2;
      }
    });
    __publicField(this, "setLanguage", (language2) => {
      if (language2 !== this.__language) {
        this.getWritable().__language = language2;
      }
    });
    __publicField(this, "select", () => {
      this.__focusEmitter.publish();
    });
    this.__code = code2;
    this.__meta = meta;
    this.__language = language;
  }
  static getType() {
    return "codeblock";
  }
  static clone(node2) {
    return new CodeBlockNode(node2.__code, node2.__language, node2.__meta, node2.__key);
  }
  static importJSON(serializedNode) {
    const { code: code2, meta, language } = serializedNode;
    return $createCodeBlockNode({
      code: code2,
      language,
      meta
    });
  }
  exportJSON() {
    return {
      code: this.getCode(),
      language: this.getLanguage(),
      meta: this.getMeta(),
      type: "codeblock",
      version: 1
    };
  }
  // View
  createDOM(_config) {
    return document.createElement("div");
  }
  updateDOM() {
    return false;
  }
  getCode() {
    return this.__code;
  }
  getMeta() {
    return this.__meta;
  }
  getLanguage() {
    return this.__language;
  }
  decorate(editor) {
    return /* @__PURE__ */ React__default.createElement(
      CodeBlockEditorContainer,
      {
        parentEditor: editor,
        code: this.getCode(),
        meta: this.getMeta(),
        language: this.getLanguage(),
        codeBlockNode: this,
        nodeKey: this.getKey(),
        focusEmitter: this.__focusEmitter
      }
    );
  }
  isInline() {
    return false;
  }
}
const CodeBlockEditorContext = React__default.createContext(null);
const CodeBlockEditorContextProvider = ({ parentEditor, lexicalNode, children }) => {
  return /* @__PURE__ */ React__default.createElement(
    CodeBlockEditorContext.Provider,
    {
      value: {
        lexicalNode,
        setCode: (code2) => {
          parentEditor.update(() => {
            lexicalNode.setCode(code2);
            setTimeout(() => {
              parentEditor.dispatchCommand(NESTED_EDITOR_UPDATED_COMMAND, void 0);
            }, 0);
          });
        },
        setLanguage: (language) => {
          parentEditor.update(() => {
            lexicalNode.setLanguage(language);
          });
        },
        setMeta: (meta) => {
          parentEditor.update(() => {
            lexicalNode.setMeta(meta);
          });
        }
      }
    },
    children
  );
};
function CodeBlockEditorContainer(props) {
  const [codeBlockEditorDescriptors] = codeBlockPluginHooks.useEmitterValues("codeBlockEditorDescriptors");
  const descriptor = codeBlockEditorDescriptors.sort((a2, b2) => b2.priority - a2.priority).find((descriptor2) => descriptor2.match(props.language || "", props.meta || ""));
  if (!descriptor) {
    throw new Error(`No CodeBlockEditor registered for language=${props.language} meta=${props.meta}`);
  }
  const Editor = descriptor.Editor;
  const { codeBlockNode: _, parentEditor: __, ...restProps } = props;
  return /* @__PURE__ */ React__default.createElement(CodeBlockEditorContextProvider, { parentEditor: props.parentEditor, lexicalNode: props.codeBlockNode }, /* @__PURE__ */ React__default.createElement(Editor, { ...restProps }));
}
function $createCodeBlockNode(options) {
  const { code: code2 = "", language = "", meta = "" } = options;
  return new CodeBlockNode(code2, language, meta);
}
function $isCodeBlockNode(node2) {
  return node2 instanceof CodeBlockNode;
}
const CodeBlockVisitor = {
  testLexicalNode: $isCodeBlockNode,
  visitLexicalNode: ({ lexicalNode, actions }) => {
    actions.addAndStepInto("code", {
      value: lexicalNode.getCode(),
      lang: lexicalNode.getLanguage(),
      meta: lexicalNode.getMeta()
    });
  }
};
const MdastCodeVisitor = {
  testNode: "code",
  visitNode({ mdastNode, actions }) {
    actions.addAndStepInto(
      $createCodeBlockNode({
        code: mdastNode.value,
        language: mdastNode.lang,
        meta: mdastNode.meta
      })
    );
  }
};
const codeBlockSystem = system(
  (r2, [{ insertDecoratorNode }]) => {
    const codeBlockEditorDescriptors = r2.node([]);
    const appendCodeBlockEditorDescriptor = r2.node();
    const insertCodeBlock = r2.node();
    const defaultCodeBlockLanguage = r2.node("");
    r2.link(
      r2.pipe(
        insertCodeBlock,
        r2.o.withLatestFrom(defaultCodeBlockLanguage),
        r2.o.map(
          ([payload, defaultCodeBlockLanguage2]) => () => $createCodeBlockNode({ language: defaultCodeBlockLanguage2, ...payload })
        )
      ),
      insertDecoratorNode
    );
    r2.link(
      r2.pipe(
        appendCodeBlockEditorDescriptor,
        r2.o.withLatestFrom(codeBlockEditorDescriptors),
        r2.o.map(([newValue, values]) => {
          if (values.includes(newValue)) {
            return values;
          }
          return [...values, newValue];
        })
      ),
      codeBlockEditorDescriptors
    );
    return {
      codeBlockEditorDescriptors,
      defaultCodeBlockLanguage,
      appendCodeBlockEditorDescriptor,
      insertCodeBlock
    };
  },
  [coreSystem]
);
const [
  /**
   * @internal
   */
  codeBlockPlugin,
  /**
   * @internal
   */
  codeBlockPluginHooks
] = realmPlugin({
  id: "codeblock",
  systemSpec: codeBlockSystem,
  applyParamsToSystem(realm2, params) {
    realm2.pubKey("defaultCodeBlockLanguage", (params == null ? void 0 : params.defaultCodeBlockLanguage) || "");
  },
  init: (realm2, params) => {
    realm2.pubKey("codeBlockEditorDescriptors", (params == null ? void 0 : params.codeBlockEditorDescriptors) || []);
    realm2.pubKey("addImportVisitor", MdastCodeVisitor);
    realm2.pubKey("addLexicalNode", CodeBlockNode);
    realm2.pubKey("addExportVisitor", CodeBlockVisitor);
  }
});
var LexicalMarkdown_prod = {};
var LexicalCode_prod = {};
var prism = { exports: {} };
(function(module) {
  var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var Prism2 = function(_self2) {
    var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    var uniqueId = 0;
    var plainTextGrammar = {};
    var _ = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: _self2.Prism && _self2.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function encode(tokens) {
          if (tokens instanceof Token) {
            return new Token(tokens.type, encode(tokens.content), tokens.alias);
          } else if (Array.isArray(tokens)) {
            return tokens.map(encode);
          } else {
            return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          }
        },
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(o) {
          return Object.prototype.toString.call(o).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(obj) {
          if (!obj["__id"]) {
            Object.defineProperty(obj, "__id", { value: ++uniqueId });
          }
          return obj["__id"];
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function deepClone(o, visited) {
          visited = visited || {};
          var clone;
          var id2;
          switch (_.util.type(o)) {
            case "Object":
              id2 = _.util.objId(o);
              if (visited[id2]) {
                return visited[id2];
              }
              clone = /** @type {Record<string, any>} */
              {};
              visited[id2] = clone;
              for (var key in o) {
                if (o.hasOwnProperty(key)) {
                  clone[key] = deepClone(o[key], visited);
                }
              }
              return (
                /** @type {any} */
                clone
              );
            case "Array":
              id2 = _.util.objId(o);
              if (visited[id2]) {
                return visited[id2];
              }
              clone = [];
              visited[id2] = clone;
              /** @type {Array} */
              /** @type {any} */
              o.forEach(function(v3, i) {
                clone[i] = deepClone(v3, visited);
              });
              return (
                /** @type {any} */
                clone
              );
            default:
              return o;
          }
        },
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function(element2) {
          while (element2) {
            var m2 = lang.exec(element2.className);
            if (m2) {
              return m2[1].toLowerCase();
            }
            element2 = element2.parentElement;
          }
          return "none";
        },
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: function(element2, language) {
          element2.className = element2.className.replace(RegExp(lang, "gi"), "");
          element2.classList.add("language-" + language);
        },
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function() {
          if (typeof document === "undefined") {
            return null;
          }
          if ("currentScript" in document && 1 < 2) {
            return (
              /** @type {any} */
              document.currentScript
            );
          }
          try {
            throw new Error();
          } catch (err) {
            var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
            if (src) {
              var scripts = document.getElementsByTagName("script");
              for (var i in scripts) {
                if (scripts[i].src == src) {
                  return scripts[i];
                }
              }
            }
            return null;
          }
        },
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function(element2, className, defaultActivation) {
          var no = "no-" + className;
          while (element2) {
            var classList = element2.classList;
            if (classList.contains(className)) {
              return true;
            }
            if (classList.contains(no)) {
              return false;
            }
            element2 = element2.parentElement;
          }
          return !!defaultActivation;
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: plainTextGrammar,
        plaintext: plainTextGrammar,
        text: plainTextGrammar,
        txt: plainTextGrammar,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(id2, redef) {
          var lang2 = _.util.clone(_.languages[id2]);
          for (var key in redef) {
            lang2[key] = redef[key];
          }
          return lang2;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(inside, before, insert, root2) {
          root2 = root2 || /** @type {any} */
          _.languages;
          var grammar = root2[inside];
          var ret = {};
          for (var token in grammar) {
            if (grammar.hasOwnProperty(token)) {
              if (token == before) {
                for (var newToken in insert) {
                  if (insert.hasOwnProperty(newToken)) {
                    ret[newToken] = insert[newToken];
                  }
                }
              }
              if (!insert.hasOwnProperty(token)) {
                ret[token] = grammar[token];
              }
            }
          }
          var old = root2[inside];
          root2[inside] = ret;
          _.languages.DFS(_.languages, function(key, value) {
            if (value === old && key != inside) {
              this[key] = ret;
            }
          });
          return ret;
        },
        // Traverse a language definition with Depth First Search
        DFS: function DFS(o, callback, type, visited) {
          visited = visited || {};
          var objId = _.util.objId;
          for (var i in o) {
            if (o.hasOwnProperty(i)) {
              callback.call(o, i, o[i], type || i);
              var property = o[i];
              var propertyType = _.util.type(property);
              if (propertyType === "Object" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, null, visited);
              } else if (propertyType === "Array" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, i, visited);
              }
            }
          }
        }
      },
      plugins: {},
      /**
       * This is the most high-level function in Prism’s API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function(async, callback) {
        _.highlightAllUnder(document, async, callback);
      },
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function(container, async, callback) {
        var env = {
          callback,
          container,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        _.hooks.run("before-highlightall", env);
        env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
        _.hooks.run("before-all-elements-highlight", env);
        for (var i = 0, element2; element2 = env.elements[i++]; ) {
          _.highlightElement(element2, async === true, env.callback);
        }
      },
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function(element2, async, callback) {
        var language = _.util.getLanguage(element2);
        var grammar = _.languages[language];
        _.util.setLanguage(element2, language);
        var parent = element2.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre") {
          _.util.setLanguage(parent, language);
        }
        var code2 = element2.textContent;
        var env = {
          element: element2,
          language,
          grammar,
          code: code2
        };
        function insertHighlightedCode(highlightedCode) {
          env.highlightedCode = highlightedCode;
          _.hooks.run("before-insert", env);
          env.element.innerHTML = env.highlightedCode;
          _.hooks.run("after-highlight", env);
          _.hooks.run("complete", env);
          callback && callback.call(env.element);
        }
        _.hooks.run("before-sanity-check", env);
        parent = env.element.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
          parent.setAttribute("tabindex", "0");
        }
        if (!env.code) {
          _.hooks.run("complete", env);
          callback && callback.call(env.element);
          return;
        }
        _.hooks.run("before-highlight", env);
        if (!env.grammar) {
          insertHighlightedCode(_.util.encode(env.code));
          return;
        }
        if (async && _self2.Worker) {
          var worker = new Worker(_.filename);
          worker.onmessage = function(evt) {
            insertHighlightedCode(evt.data);
          };
          worker.postMessage(JSON.stringify({
            language: env.language,
            code: env.code,
            immediateClose: true
          }));
        } else {
          insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
        }
      },
      /**
       * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(text2, grammar, language) {
        var env = {
          code: text2,
          grammar,
          language
        };
        _.hooks.run("before-tokenize", env);
        if (!env.grammar) {
          throw new Error('The language "' + env.language + '" has no grammar.');
        }
        env.tokens = _.tokenize(env.code, env.grammar);
        _.hooks.run("after-tokenize", env);
        return Token.stringify(_.util.encode(env.tokens), env.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(text2, grammar) {
        var rest = grammar.rest;
        if (rest) {
          for (var token in rest) {
            grammar[token] = rest[token];
          }
          delete grammar.rest;
        }
        var tokenList = new LinkedList();
        addAfter(tokenList, tokenList.head, text2);
        matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
        return toArray(tokenList);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(name, callback) {
          var hooks = _.hooks.all;
          hooks[name] = hooks[name] || [];
          hooks[name].push(callback);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(name, env) {
          var callbacks = _.hooks.all[name];
          if (!callbacks || !callbacks.length) {
            return;
          }
          for (var i = 0, callback; callback = callbacks[i++]; ) {
            callback(env);
          }
        }
      },
      Token
    };
    _self2.Prism = _;
    function Token(type, content2, alias, matchedStr) {
      this.type = type;
      this.content = content2;
      this.alias = alias;
      this.length = (matchedStr || "").length | 0;
    }
    Token.stringify = function stringify(o, language) {
      if (typeof o == "string") {
        return o;
      }
      if (Array.isArray(o)) {
        var s = "";
        o.forEach(function(e2) {
          s += stringify(e2, language);
        });
        return s;
      }
      var env = {
        type: o.type,
        content: stringify(o.content, language),
        tag: "span",
        classes: ["token", o.type],
        attributes: {},
        language
      };
      var aliases = o.alias;
      if (aliases) {
        if (Array.isArray(aliases)) {
          Array.prototype.push.apply(env.classes, aliases);
        } else {
          env.classes.push(aliases);
        }
      }
      _.hooks.run("wrap", env);
      var attributes = "";
      for (var name in env.attributes) {
        attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
      }
      return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    };
    function matchPattern(pattern, pos, text2, lookbehind) {
      pattern.lastIndex = pos;
      var match = pattern.exec(text2);
      if (match && lookbehind && match[1]) {
        var lookbehindLength = match[1].length;
        match.index += lookbehindLength;
        match[0] = match[0].slice(lookbehindLength);
      }
      return match;
    }
    function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
      for (var token in grammar) {
        if (!grammar.hasOwnProperty(token) || !grammar[token]) {
          continue;
        }
        var patterns = grammar[token];
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        for (var j = 0; j < patterns.length; ++j) {
          if (rematch && rematch.cause == token + "," + j) {
            return;
          }
          var patternObj = patterns[j];
          var inside = patternObj.inside;
          var lookbehind = !!patternObj.lookbehind;
          var greedy = !!patternObj.greedy;
          var alias = patternObj.alias;
          if (greedy && !patternObj.pattern.global) {
            var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
            patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
          }
          var pattern = patternObj.pattern || patternObj;
          for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
            if (rematch && pos >= rematch.reach) {
              break;
            }
            var str = currentNode.value;
            if (tokenList.length > text2.length) {
              return;
            }
            if (str instanceof Token) {
              continue;
            }
            var removeCount = 1;
            var match;
            if (greedy) {
              match = matchPattern(pattern, pos, text2, lookbehind);
              if (!match || match.index >= text2.length) {
                break;
              }
              var from = match.index;
              var to = match.index + match[0].length;
              var p2 = pos;
              p2 += currentNode.value.length;
              while (from >= p2) {
                currentNode = currentNode.next;
                p2 += currentNode.value.length;
              }
              p2 -= currentNode.value.length;
              pos = p2;
              if (currentNode.value instanceof Token) {
                continue;
              }
              for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to || typeof k2.value === "string"); k2 = k2.next) {
                removeCount++;
                p2 += k2.value.length;
              }
              removeCount--;
              str = text2.slice(pos, p2);
              match.index -= pos;
            } else {
              match = matchPattern(pattern, 0, str, lookbehind);
              if (!match) {
                continue;
              }
            }
            var from = match.index;
            var matchStr = match[0];
            var before = str.slice(0, from);
            var after = str.slice(from + matchStr.length);
            var reach = pos + str.length;
            if (rematch && reach > rematch.reach) {
              rematch.reach = reach;
            }
            var removeFrom = currentNode.prev;
            if (before) {
              removeFrom = addAfter(tokenList, removeFrom, before);
              pos += before.length;
            }
            removeRange(tokenList, removeFrom, removeCount);
            var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
            currentNode = addAfter(tokenList, removeFrom, wrapped);
            if (after) {
              addAfter(tokenList, currentNode, after);
            }
            if (removeCount > 1) {
              var nestedRematch = {
                cause: token + "," + j,
                reach
              };
              matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
              if (rematch && nestedRematch.reach > rematch.reach) {
                rematch.reach = nestedRematch.reach;
              }
            }
          }
        }
      }
    }
    function LinkedList() {
      var head = { value: null, prev: null, next: null };
      var tail = { value: null, prev: head, next: null };
      head.next = tail;
      this.head = head;
      this.tail = tail;
      this.length = 0;
    }
    function addAfter(list2, node2, value) {
      var next = node2.next;
      var newNode = { value, prev: node2, next };
      node2.next = newNode;
      next.prev = newNode;
      list2.length++;
      return newNode;
    }
    function removeRange(list2, node2, count) {
      var next = node2.next;
      for (var i = 0; i < count && next !== list2.tail; i++) {
        next = next.next;
      }
      node2.next = next;
      next.prev = node2;
      list2.length -= i;
    }
    function toArray(list2) {
      var array = [];
      var node2 = list2.head.next;
      while (node2 !== list2.tail) {
        array.push(node2.value);
        node2 = node2.next;
      }
      return array;
    }
    if (!_self2.document) {
      if (!_self2.addEventListener) {
        return _;
      }
      if (!_.disableWorkerMessageHandler) {
        _self2.addEventListener("message", function(evt) {
          var message = JSON.parse(evt.data);
          var lang2 = message.language;
          var code2 = message.code;
          var immediateClose = message.immediateClose;
          _self2.postMessage(_.highlight(code2, _.languages[lang2], lang2));
          if (immediateClose) {
            _self2.close();
          }
        }, false);
      }
      return _;
    }
    var script = _.util.currentScript();
    if (script) {
      _.filename = script.src;
      if (script.hasAttribute("data-manual")) {
        _.manual = true;
      }
    }
    function highlightAutomaticallyCallback() {
      if (!_.manual) {
        _.highlightAll();
      }
    }
    if (!_.manual) {
      var readyState = document.readyState;
      if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
        document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
      } else {
        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(highlightAutomaticallyCallback);
        } else {
          window.setTimeout(highlightAutomaticallyCallback, 16);
        }
      }
    }
    return _;
  }(_self);
  if (module.exports) {
    module.exports = Prism2;
  }
  if (typeof commonjsGlobal !== "undefined") {
    commonjsGlobal.Prism = Prism2;
  }
  Prism2.languages.markup = {
    "comment": {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: true
    },
    "prolog": {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: true
    },
    "doctype": {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null
          // see below
        },
        "string": {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        "punctuation": /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        "name": /[^\s<>'"]+/
      }
    },
    "cdata": {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: true
    },
    "tag": {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        "tag": {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            "punctuation": /^<\/?/,
            "namespace": /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: true
              }
            ]
          }
        },
        "punctuation": /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            "namespace": /^[^\s>\/:]+:/
          }
        }
      }
    },
    "entity": [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  };
  Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
  Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
  Prism2.hooks.add("wrap", function(env) {
    if (env.type === "entity") {
      env.attributes["title"] = env.content.replace(/&amp;/, "&");
    }
  });
  Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function addInlined2(tagName, lang) {
      var includedCdataInside = {};
      includedCdataInside["language-" + lang] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: true,
        inside: Prism2.languages[lang]
      };
      includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside["language-" + lang] = {
        pattern: /[\s\S]+/,
        inside: Prism2.languages[lang]
      };
      var def = {};
      def[tagName] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return tagName;
        }), "i"),
        lookbehind: true,
        greedy: true,
        inside
      };
      Prism2.languages.insertBefore("markup", "cdata", def);
    }
  });
  Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(attrName, lang) {
      Prism2.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: true,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              "value": {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: true,
                alias: [lang, "language-" + lang],
                inside: Prism2.languages[lang]
              },
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  });
  Prism2.languages.html = Prism2.languages.markup;
  Prism2.languages.mathml = Prism2.languages.markup;
  Prism2.languages.svg = Prism2.languages.markup;
  Prism2.languages.xml = Prism2.languages.extend("markup", {});
  Prism2.languages.ssml = Prism2.languages.xml;
  Prism2.languages.atom = Prism2.languages.xml;
  Prism2.languages.rss = Prism2.languages.xml;
  (function(Prism3) {
    var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism3.languages.css = {
      "comment": /\/\*[\s\S]*?\*\//,
      "atrule": {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string2.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          "rule": /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: true,
            alias: "selector"
          },
          "keyword": {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: true
          }
          // See rest below
        }
      },
      "url": {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: true,
        inside: {
          "function": /^url/i,
          "punctuation": /^\(|\)$/,
          "string": {
            pattern: RegExp("^" + string2.source + "$"),
            alias: "url"
          }
        }
      },
      "selector": {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"),
        lookbehind: true
      },
      "string": {
        pattern: string2,
        greedy: true
      },
      "property": {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: true
      },
      "important": /!important\b/i,
      "function": {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: true
      },
      "punctuation": /[(){};:,]/
    };
    Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
    var markup = Prism3.languages.markup;
    if (markup) {
      markup.tag.addInlined("style", "css");
      markup.tag.addAttribute("style", "css");
    }
  })(Prism2);
  Prism2.languages.clike = {
    "comment": [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    "string": {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    "boolean": /\b(?:false|true)\b/,
    "function": /\b\w+(?=\()/,
    "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    "punctuation": /[{}[\];(),.:]/
  };
  Prism2.languages.javascript = Prism2.languages.extend("clike", {
    "class-name": [
      Prism2.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: true
      }
    ],
    "keyword": [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    "number": {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: true
    },
    "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  });
  Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
  Prism2.languages.insertBefore("javascript", "keyword", {
    "regex": {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: true,
          alias: "language-regex",
          inside: Prism2.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    "parameter": [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: true,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: true,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: Prism2.languages.javascript
      }
    ],
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  });
  Prism2.languages.insertBefore("javascript", "string", {
    "hashbang": {
      pattern: /^#!.*/,
      greedy: true,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: true,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: true,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism2.languages.javascript
          }
        },
        "string": /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: true,
      greedy: true,
      alias: "property"
    }
  });
  Prism2.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: true,
      alias: "property"
    }
  });
  if (Prism2.languages.markup) {
    Prism2.languages.markup.tag.addInlined("script", "javascript");
    Prism2.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    );
  }
  Prism2.languages.js = Prism2.languages.javascript;
  (function() {
    if (typeof Prism2 === "undefined" || typeof document === "undefined") {
      return;
    }
    if (!Element.prototype.matches) {
      Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    }
    var LOADING_MESSAGE = "Loading…";
    var FAILURE_MESSAGE = function(status, message) {
      return "✖ Error " + status + " while fetching file: " + message;
    };
    var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
    var EXTENSIONS = {
      "js": "javascript",
      "py": "python",
      "rb": "ruby",
      "ps1": "powershell",
      "psm1": "powershell",
      "sh": "bash",
      "bat": "batch",
      "h": "c",
      "tex": "latex"
    };
    var STATUS_ATTR = "data-src-status";
    var STATUS_LOADING = "loading";
    var STATUS_LOADED = "loaded";
    var STATUS_FAILED = "failed";
    var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
    function loadFile(src, success, error) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", src, true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (xhr.status < 400 && xhr.responseText) {
            success(xhr.responseText);
          } else {
            if (xhr.status >= 400) {
              error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
            } else {
              error(FAILURE_EMPTY_MESSAGE);
            }
          }
        }
      };
      xhr.send(null);
    }
    function parseRange(range) {
      var m2 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
      if (m2) {
        var start2 = Number(m2[1]);
        var comma = m2[2];
        var end = m2[3];
        if (!comma) {
          return [start2, start2];
        }
        if (!end) {
          return [start2, void 0];
        }
        return [start2, Number(end)];
      }
      return void 0;
    }
    Prism2.hooks.add("before-highlightall", function(env) {
      env.selector += ", " + SELECTOR;
    });
    Prism2.hooks.add("before-sanity-check", function(env) {
      var pre = (
        /** @type {HTMLPreElement} */
        env.element
      );
      if (pre.matches(SELECTOR)) {
        env.code = "";
        pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
        var code2 = pre.appendChild(document.createElement("CODE"));
        code2.textContent = LOADING_MESSAGE;
        var src = pre.getAttribute("data-src");
        var language = env.language;
        if (language === "none") {
          var extension2 = (/\.(\w+)$/.exec(src) || [, "none"])[1];
          language = EXTENSIONS[extension2] || extension2;
        }
        Prism2.util.setLanguage(code2, language);
        Prism2.util.setLanguage(pre, language);
        var autoloader = Prism2.plugins.autoloader;
        if (autoloader) {
          autoloader.loadLanguages(language);
        }
        loadFile(
          src,
          function(text2) {
            pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
            var range = parseRange(pre.getAttribute("data-range"));
            if (range) {
              var lines = text2.split(/\r\n?|\n/g);
              var start2 = range[0];
              var end = range[1] == null ? lines.length : range[1];
              if (start2 < 0) {
                start2 += lines.length;
              }
              start2 = Math.max(0, Math.min(start2 - 1, lines.length));
              if (end < 0) {
                end += lines.length;
              }
              end = Math.max(0, Math.min(end, lines.length));
              text2 = lines.slice(start2, end).join("\n");
              if (!pre.hasAttribute("data-start")) {
                pre.setAttribute("data-start", String(start2 + 1));
              }
            }
            code2.textContent = text2;
            Prism2.highlightElement(code2);
          },
          function(error) {
            pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
            code2.textContent = error;
          }
        );
      }
    });
    Prism2.plugins.fileHighlight = {
      /**
       * Executes the File Highlight plugin for all matching `pre` elements under the given container.
       *
       * Note: Elements which are already loaded or currently loading will not be touched by this method.
       *
       * @param {ParentNode} [container=document]
       */
      highlight: function highlight(container) {
        var elements = (container || document).querySelectorAll(SELECTOR);
        for (var i = 0, element2; element2 = elements[i++]; ) {
          Prism2.highlightElement(element2);
        }
      }
    };
    var logged = false;
    Prism2.fileHighlight = function() {
      if (!logged) {
        console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
        logged = true;
      }
      Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
    };
  })();
})(prism);
var prismExports = prism.exports;
Prism.languages.clike = {
  "comment": [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: true,
      greedy: true
    },
    {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }
  ],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
      lookbehind: true
    }
  ],
  "keyword": [
    {
      pattern: /((?:^|\})\s*)catch\b/,
      lookbehind: true
    },
    {
      pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: true
    }
  ],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(
      /(^|[^\w$])/.source + "(?:" + // constant
      (/NaN|Infinity/.source + "|" + // binary integer
      /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
      /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
      /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
      /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
      /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
    ),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [
    {
      pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    }
  ],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  );
}
Prism.languages.js = Prism.languages.javascript;
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [
            {
              pattern: /^=/,
              alias: "attr-equals"
            },
            {
              pattern: /^(\s*)["']|["']$/,
              lookbehind: true
            }
          ]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [
    {
      pattern: /&[\da-z]{1,8};/i,
      alias: "named-entity"
    },
    /&#x?[\da-f]{1,8};/i
  ]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(
        /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
        "i"
      ),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              /"|'/
            ]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function(Prism2) {
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function() {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism2.languages.markdown = Prism2.languages.extend("markup", {});
  Prism2.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "punctuation": /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: Prism2.languages.yaml
        }
      }
    },
    "blockquote": {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    "table": {
      pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(tableCell),
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
          lookbehind: true,
          inside: {
            "punctuation": /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + tableRow + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(tableCell),
              alias: "important",
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        }
      }
    },
    "code": [
      {
        // Prefixed by 4 spaces or 1 tab and preceded by an empty line
        pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
        lookbehind: true,
        alias: "keyword"
      },
      {
        // ```optional language
        // code block
        // ```
        pattern: /^```[\s\S]*?^```$/m,
        greedy: true,
        inside: {
          "code-block": {
            pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
            lookbehind: true
          },
          "code-language": {
            pattern: /^(```).+/,
            lookbehind: true
          },
          "punctuation": /```/
        }
      }
    ],
    "title": [
      {
        // title 1
        // =======
        // title 2
        // -------
        pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
        alias: "important",
        inside: {
          punctuation: /==+$|--+$/
        }
      },
      {
        // # title 1
        // ###### title 6
        pattern: /(^\s*)#.+/m,
        lookbehind: true,
        alias: "important",
        inside: {
          punctuation: /^#+|#+$/
        }
      }
    ],
    "hr": {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "list": {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        "variable": {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        "punctuation": /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    "bold": {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /\*\*|__/
      }
    },
    "italic": {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /[*_]/
      }
    },
    "strike": {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    "url": {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "operator": /^!/,
        "content": {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "variable": {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        "url": {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        "string": {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ["url", "bold", "italic", "strike"].forEach(function(token) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
      if (token !== inside) {
        Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside];
      }
    });
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "markdown" && env.language !== "md") {
      return;
    }
    function walkTokens(tokens) {
      if (!tokens || typeof tokens === "string") {
        return;
      }
      for (var i = 0, l2 = tokens.length; i < l2; i++) {
        var token = tokens[i];
        if (token.type !== "code") {
          walkTokens(token.content);
          continue;
        }
        var codeLang = token.content[1];
        var codeBlock = token.content[3];
        if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
          var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
          lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
          var alias = "language-" + lang;
          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === "string") {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env.tokens);
  });
  Prism2.hooks.add("wrap", function(env) {
    if (env.type !== "code-block") {
      return;
    }
    var codeLang = "";
    for (var i = 0, l2 = env.classes.length; i < l2; i++) {
      var cls = env.classes[i];
      var match = /language-(.+)/.exec(cls);
      if (match) {
        codeLang = match[1];
        break;
      }
    }
    var grammar = Prism2.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
        var id2 = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        env.attributes["id"] = id2;
        Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
          var ele = document.getElementById(id2);
          if (ele) {
            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
  var KNOWN_ENTITY_NAMES = {
    "amp": "&",
    "lt": "<",
    "gt": ">",
    "quot": '"'
  };
  var fromCodePoint = String.fromCodePoint || String.fromCharCode;
  function textContent(html2) {
    var text2 = html2.replace(tagPattern, "");
    text2 = text2.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m2, code2) {
      code2 = code2.toLowerCase();
      if (code2[0] === "#") {
        var value;
        if (code2[1] === "x") {
          value = parseInt(code2.slice(2), 16);
        } else {
          value = Number(code2.slice(1));
        }
        return fromCodePoint(value);
      } else {
        var known = KNOWN_ENTITY_NAMES[code2];
        if (known) {
          return known;
        }
        return m2;
      }
    });
    return text2;
  }
  Prism2.languages.md = Prism2.languages.markdown;
})(Prism);
Prism.languages.c = Prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  "char": {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
Prism.languages.insertBefore("c", "string", {
  "macro": {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [
        {
          // highlight the path of the include statement as a string
          pattern: /^(#\s*include\s*)<[^>]+>/,
          lookbehind: true
        },
        Prism.languages.c["string"]
      ],
      "char": Prism.languages.c["char"],
      "comment": Prism.languages.c["comment"],
      "macro-name": [
        {
          pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
          lookbehind: true
        },
        {
          pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
          lookbehind: true,
          alias: "function"
        }
      ],
      // highlight macro directives as keywords
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];
(function(Prism2) {
  var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string2.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string2.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string2,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
Prism.languages.objectivec = Prism.languages.extend("c", {
  "string": {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;
Prism.languages.sql = {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  "variable": [
    {
      pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
      greedy: true
    },
    /@[\w.$]+/
  ],
  "string": {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  "identifier": {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      "punctuation": /^`|`$/
    }
  },
  "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
  "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  "punctuation": /[;[\]()`,.]/
};
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
(function(Prism2) {
  var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
  for (var i = 0; i < 2; i++) {
    multilineComment = multilineComment.replace(/<self>/g, function() {
      return multilineComment;
    });
  }
  multilineComment = multilineComment.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  });
  Prism2.languages.rust = {
    "comment": [
      {
        pattern: RegExp(/(^|[^\\])/.source + multilineComment),
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    "string": {
      pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
      greedy: true
    },
    "char": {
      pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
      greedy: true
    },
    "attribute": {
      pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
      greedy: true,
      alias: "attr-name",
      inside: {
        "string": null
        // see below
      }
    },
    // Closure params should not be confused with bitwise OR |
    "closure-params": {
      pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "closure-punctuation": {
          pattern: /^\||\|$/,
          alias: "punctuation"
        },
        rest: null
        // see below
      }
    },
    "lifetime-annotation": {
      pattern: /'\w+/,
      alias: "symbol"
    },
    "fragment-specifier": {
      pattern: /(\$\w+:)[a-z]+/,
      lookbehind: true,
      alias: "punctuation"
    },
    "variable": /\$\w+/,
    "function-definition": {
      pattern: /(\bfn\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "type-definition": {
      pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
      lookbehind: true,
      alias: "class-name"
    },
    "module-declaration": [
      {
        pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
        lookbehind: true,
        alias: "namespace"
      },
      {
        pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
        lookbehind: true,
        alias: "namespace",
        inside: {
          "punctuation": /::/
        }
      }
    ],
    "keyword": [
      // https://github.com/rust-lang/reference/blob/master/src/keywords.md
      /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
      // primitives and str
      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
      /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    ],
    // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
    // and Rust's naming conventions recommend snake_case anyway.
    // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
    "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    "macro": {
      pattern: /\b\w+!/,
      alias: "property"
    },
    "constant": /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    "namespace": {
      pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
      inside: {
        "punctuation": /::/
      }
    },
    // Hex, oct, bin, dec numbers with visual separators and type suffix
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    "boolean": /\b(?:false|true)\b/,
    "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
  };
  Prism2.languages.rust["closure-params"].inside.rest = Prism2.languages.rust;
  Prism2.languages.rust["attribute"].inside["string"] = Prism2.languages.rust["string"];
})(Prism);
Prism.languages.swift = {
  "comment": {
    // Nested comments are supported up to 2 levels
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: true,
    greedy: true
  },
  "string-literal": [
    // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    {
      pattern: RegExp(
        /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        "punctuation": /\\(?=[\r\n])/,
        "string": /[\s\S]+/
      }
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        "string": /[\s\S]+/
      }
    }
  ],
  "directive": {
    // directives with conditions
    pattern: RegExp(
      /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      "boolean": /\b(?:false|true)\b/,
      "number": /\b\d+(?:\.\d+)*\b/,
      "operator": /!|&&|\|\||[<>]=?/,
      "punctuation": /[(),]/
    }
  },
  "literal": {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+\b/,
    alias: "property"
  },
  "attribute": {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: true,
    alias: "function"
  },
  "label": {
    // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: true,
    alias: "important"
  },
  "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  "boolean": /\b(?:false|true)\b/,
  "nil": {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  "omit": {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
  // This regex only supports ASCII operators.
  "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  "punctuation": /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(rule) {
  rule.inside["interpolation"].inside = Prism.languages.swift;
});
(function(Prism2) {
  Prism2.languages.typescript = Prism2.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
      // see below
    },
    "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  });
  Prism2.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  );
  delete Prism2.languages.typescript["parameter"];
  delete Prism2.languages.typescript["literal-property"];
  var typeInside = Prism2.languages.extend("typescript", {});
  delete typeInside["class-name"];
  Prism2.languages.typescript["class-name"].inside = typeInside;
  Prism2.languages.insertBefore("typescript", "function", {
    "decorator": {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        "at": {
          pattern: /^@/,
          alias: "operator"
        },
        "function": /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        "generic": {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: typeInside
        }
      }
    }
  });
  Prism2.languages.ts = Prism2.languages.typescript;
})(Prism);
(function(Prism2) {
  var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism2.languages.java = Prism2.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [
      className,
      {
        // variables, parameters, and constructor references
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
        lookbehind: true,
        inside: className.inside
      },
      {
        // class names based on keyword
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
        lookbehind: true,
        inside: className.inside
      }
    ],
    "keyword": keywords,
    "function": [
      Prism2.languages.clike.function,
      {
        pattern: /(::\s*)[a-z_]\w*/,
        lookbehind: true
      }
    ],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    },
    "constant": /\b[A-Z][A-Z_\d]+\b/
  });
  Prism2.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [
      {
        pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
        lookbehind: true,
        inside: {
          "namespace": className.inside.namespace,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      },
      {
        pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
        lookbehind: true,
        alias: "static",
        inside: {
          "namespace": className.inside.namespace,
          "static": /\b\w+$/,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      }
    ],
    "namespace": {
      pattern: RegExp(
        /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
          return keywords.source;
        })
      ),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);
(function(Prism2) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword.source;
  });
  Prism2.languages.cpp = Prism2.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        })),
        lookbehind: true
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism2.languages.insertBefore("cpp", "string", {
    "module": {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(
        /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
        /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
        /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
          return modName;
        }) + ")"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism2.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism2.languages.cpp
        }
      }
    }
  });
  Prism2.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism2.languages.extend("cpp", {})
    }
  });
  Prism2.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism2.languages.cpp["base-clause"]);
})(Prism);
var d$1 = prismExports;
var m = LexicalUtils_1, q = Lexical_1;
let v2 = (a2) => null != a2 && d$1.languages.hasOwnProperty(a2) ? a2 : void 0;
function x2(a2, b2) {
  for (let c2 of a2.childNodes) {
    if (m.isHTMLElement(c2) && c2.tagName === b2)
      return true;
    x2(c2, b2);
  }
  return false;
}
class y extends q.ElementNode {
  static getType() {
    return "code";
  }
  static clone(a2) {
    return new y(a2.__language, a2.__key);
  }
  constructor(a2, b2) {
    super(b2);
    this.__language = v2(a2);
  }
  createDOM(a2) {
    let b2 = document.createElement("code");
    m.addClassNamesToElement(b2, a2.theme.code);
    b2.setAttribute("spellcheck", "false");
    (a2 = this.getLanguage()) && b2.setAttribute("data-highlight-language", a2);
    return b2;
  }
  updateDOM(a2, b2) {
    let c2 = this.__language;
    a2 = a2.__language;
    c2 ? c2 !== a2 && b2.setAttribute("data-highlight-language", c2) : a2 && b2.removeAttribute("data-highlight-language");
    return false;
  }
  exportDOM() {
    let a2 = document.createElement("pre");
    a2.setAttribute("spellcheck", "false");
    let b2 = this.getLanguage();
    b2 && a2.setAttribute("data-highlight-language", b2);
    return { element: a2 };
  }
  static importDOM() {
    return { code: (a2) => null != a2.textContent && (/\r?\n/.test(a2.textContent) || x2(a2, "BR")) ? { conversion: z$1, priority: 1 } : null, div: () => ({ conversion: aa$1, priority: 1 }), pre: () => ({ conversion: z$1, priority: 0 }), table: (a2) => A(a2) ? { conversion: ba$1, priority: 3 } : null, td: (a2) => {
      let b2 = a2.closest("table");
      return a2.classList.contains("js-file-line") ? { conversion: ca$1, priority: 3 } : b2 && A(b2) ? { conversion: B$1, priority: 3 } : null;
    }, tr: (a2) => (a2 = a2.closest("table")) && A(a2) ? { conversion: B$1, priority: 3 } : null };
  }
  static importJSON(a2) {
    let b2 = C(a2.language);
    b2.setFormat(a2.format);
    b2.setIndent(a2.indent);
    b2.setDirection(a2.direction);
    return b2;
  }
  exportJSON() {
    return { ...super.exportJSON(), language: this.getLanguage(), type: "code", version: 1 };
  }
  insertNewAfter(a2, b2 = true) {
    var c2 = this.getChildren(), e2 = c2.length;
    if (2 <= e2 && "\n" === c2[e2 - 1].getTextContent() && "\n" === c2[e2 - 2].getTextContent() && a2.isCollapsed() && a2.anchor.key === this.__key && a2.anchor.offset === e2)
      return c2[e2 - 1].remove(), c2[e2 - 2].remove(), a2 = q.$createParagraphNode(), this.insertAfter(a2, b2), a2;
    let { anchor: f2, focus: g2 } = a2;
    b2 = (f2.isBefore(g2) ? f2 : g2).getNode();
    if (q.$isTextNode(b2)) {
      e2 = D(b2);
      for (c2 = []; ; )
        if (q.$isTabNode(e2))
          c2.push(q.$createTabNode()), e2 = e2.getNextSibling();
        else if (E(e2)) {
          for (var h2 = 0, k2 = e2.getTextContent(), l2 = e2.getTextContentSize(); h2 < l2 && " " === k2[h2]; h2++)
            ;
          0 !== h2 && c2.push(F(" ".repeat(h2)));
          if (h2 !== l2)
            break;
          e2 = e2.getNextSibling();
        } else
          break;
      e2 = b2.splitText(f2.offset)[0];
      h2 = 0 === f2.offset ? 0 : 1;
      h2 = e2.getIndexWithinParent() + h2;
      k2 = b2.getParentOrThrow();
      l2 = [q.$createLineBreakNode(), ...c2];
      k2.splice(h2, 0, l2);
      (c2 = c2[c2.length - 1]) ? c2.select() : 0 === f2.offset ? e2.selectPrevious() : e2.getNextSibling().selectNext(0, 0);
    }
    G$1(b2) && ({ offset: a2 } = a2.anchor, b2.splice(a2, 0, [q.$createLineBreakNode()]), b2.select(a2 + 1, a2 + 1));
    return null;
  }
  canIndent() {
    return false;
  }
  collapseAtStart() {
    let a2 = q.$createParagraphNode();
    this.getChildren().forEach((b2) => a2.append(b2));
    this.replace(a2);
    return true;
  }
  setLanguage(a2) {
    this.getWritable().__language = v2(a2);
  }
  getLanguage() {
    return this.getLatest().__language;
  }
}
function C(a2) {
  return q.$applyNodeReplacement(new y(a2));
}
function G$1(a2) {
  return a2 instanceof y;
}
function z$1(a2) {
  let b2;
  m.isHTMLElement(a2) && (b2 = a2.getAttribute("data-highlight-language"));
  return { node: C(b2) };
}
function aa$1(a2) {
  let b2 = null !== a2.style.fontFamily.match("monospace");
  return b2 || da$1(a2) ? { after: (c2) => {
    let e2 = a2.parentNode;
    null != e2 && a2 !== e2.lastChild && c2.push(q.$createLineBreakNode());
    return c2;
  }, node: b2 ? C() : null } : { node: null };
}
function ba$1() {
  return { node: C() };
}
function B$1() {
  return { node: null };
}
function ca$1(a2) {
  return { after: (b2) => {
    a2.parentNode && a2.parentNode.nextSibling && b2.push(q.$createLineBreakNode());
    return b2;
  }, node: null };
}
function da$1(a2) {
  for (a2 = a2.parentElement; null !== a2; ) {
    if (null !== a2.style.fontFamily.match("monospace"))
      return true;
    a2 = a2.parentElement;
  }
  return false;
}
function A(a2) {
  return a2.classList.contains("js-file-line-container");
}
let H$1 = { c: "C", clike: "C-like", cpp: "C++", css: "CSS", html: "HTML", java: "Java", js: "JavaScript", markdown: "Markdown", objc: "Objective-C", plain: "Plain Text", py: "Python", rust: "Rust", sql: "SQL", swift: "Swift", typescript: "TypeScript", xml: "XML" }, I$1 = { cpp: "cpp", java: "java", javascript: "js", md: "markdown", plaintext: "plain", python: "py", text: "plain", ts: "typescript" };
function K$1(a2) {
  return I$1[a2] || a2;
}
let L$1 = class L2 extends q.TextNode {
  constructor(a2, b2, c2) {
    super(a2, c2);
    this.__highlightType = b2;
  }
  static getType() {
    return "code-highlight";
  }
  static clone(a2) {
    return new L2(a2.__text, a2.__highlightType || void 0, a2.__key);
  }
  getHighlightType() {
    return this.getLatest().__highlightType;
  }
  createDOM(a2) {
    let b2 = super.createDOM(a2);
    a2 = M$1(a2.theme, this.__highlightType);
    m.addClassNamesToElement(b2, a2);
    return b2;
  }
  updateDOM(a2, b2, c2) {
    let e2 = super.updateDOM(a2, b2, c2);
    a2 = M$1(c2.theme, a2.__highlightType);
    c2 = M$1(c2.theme, this.__highlightType);
    a2 !== c2 && (a2 && m.removeClassNamesFromElement(
      b2,
      a2
    ), c2 && m.addClassNamesToElement(b2, c2));
    return e2;
  }
  static importJSON(a2) {
    let b2 = F(a2.text, a2.highlightType);
    b2.setFormat(a2.format);
    b2.setDetail(a2.detail);
    b2.setMode(a2.mode);
    b2.setStyle(a2.style);
    return b2;
  }
  exportJSON() {
    return { ...super.exportJSON(), highlightType: this.getHighlightType(), type: "code-highlight", version: 1 };
  }
  setFormat() {
    return this;
  }
  isParentRequired() {
    return true;
  }
  createParentElementNode() {
    return C();
  }
};
function M$1(a2, b2) {
  return b2 && a2 && a2.codeHighlight && a2.codeHighlight[b2];
}
function F(a2, b2) {
  return q.$applyNodeReplacement(new L$1(a2, b2));
}
function E(a2) {
  return a2 instanceof L$1;
}
function D(a2) {
  let b2 = a2;
  for (; E(a2) || q.$isTabNode(a2); )
    b2 = a2, a2 = a2.getPreviousSibling();
  return b2;
}
function N$1(a2) {
  let b2 = a2;
  for (; E(a2) || q.$isTabNode(a2); )
    b2 = a2, a2 = a2.getNextSibling();
  return b2;
}
let O$1 = { defaultLanguage: "javascript", tokenize(a2, b2) {
  return d$1.tokenize(a2, d$1.languages[b2 || ""] || d$1.languages[this.defaultLanguage]);
} };
function P$1(a2, b2) {
  let c2 = null;
  var e2 = null, f2 = a2;
  let g2 = b2, h2 = a2.getTextContent();
  for (; ; ) {
    if (0 === g2) {
      f2 = f2.getPreviousSibling();
      if (null === f2)
        break;
      if (!(E(f2) || q.$isTabNode(f2) || q.$isLineBreakNode(f2)))
        throw Error("Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode");
      if (q.$isLineBreakNode(f2)) {
        c2 = { node: f2, offset: 1 };
        break;
      }
      g2 = Math.max(0, f2.getTextContentSize() - 1);
      h2 = f2.getTextContent();
    } else
      g2--;
    let k2 = h2[g2];
    E(f2) && " " !== k2 && (e2 = { node: f2, offset: g2 });
  }
  if (null !== e2)
    return e2;
  e2 = null;
  b2 < a2.getTextContentSize() ? E(a2) && (e2 = a2.getTextContent()[b2]) : (f2 = a2.getNextSibling(), E(f2) && (e2 = f2.getTextContent()[0]));
  if (null !== e2 && " " !== e2)
    return c2;
  a:
    for (e2 = a2, f2 = a2.getTextContent(), a2 = a2.getTextContentSize(); ; ) {
      if (!E(e2) || b2 === a2) {
        e2 = e2.getNextSibling();
        if (null === e2 || q.$isLineBreakNode(e2)) {
          a2 = null;
          break a;
        }
        E(e2) && (b2 = 0, f2 = e2.getTextContent(), a2 = e2.getTextContentSize());
      }
      if (E(e2)) {
        if (" " !== f2[b2]) {
          a2 = { node: e2, offset: b2 };
          break a;
        }
        b2++;
      }
    }
  return null !== a2 ? a2 : c2;
}
function Q$1(a2) {
  a2 = N$1(a2);
  if (q.$isLineBreakNode(a2))
    throw Error("Unexpected lineBreakNode in getEndOfCodeInLine");
  return a2;
}
function R$1(a2, b2, c2) {
  let e2 = a2.getParent();
  G$1(e2) ? S$1(e2, b2, c2) : E(a2) && a2.replace(q.$createTextNode(a2.__text));
}
let T$1 = /* @__PURE__ */ new Set();
function S$1(a2, b2, c2) {
  let e2 = a2.getKey();
  T$1.has(e2) || (T$1.add(e2), void 0 === a2.getLanguage() && a2.setLanguage(c2.defaultLanguage), b2.update(() => {
    ea$1(e2, () => {
      var f2 = q.$getNodeByKey(e2);
      if (!G$1(f2) || !f2.isAttached())
        return false;
      var g2 = f2.getTextContent();
      g2 = c2.tokenize(g2, f2.getLanguage() || c2.defaultLanguage);
      g2 = U$1(g2);
      var h2 = f2.getChildren();
      for (f2 = 0; f2 < h2.length && V$1(h2[f2], g2[f2]); )
        f2++;
      var k2 = h2.length;
      let l2 = g2.length, r2 = Math.min(k2, l2) - f2, n2 = 0;
      for (; n2 < r2; )
        if (n2++, !V$1(h2[k2 - n2], g2[l2 - n2])) {
          n2--;
          break;
        }
      h2 = f2;
      k2 -= n2;
      g2 = g2.slice(f2, l2 - n2);
      let { from: p2, to: w2, nodesForReplacement: u2 } = { from: h2, nodesForReplacement: g2, to: k2 };
      return p2 !== w2 || u2.length ? (a2.splice(p2, w2 - p2, u2), true) : false;
    });
  }, { onUpdate: () => {
    T$1.delete(e2);
  }, skipTransforms: true }));
}
function U$1(a2, b2) {
  let c2 = [];
  for (let e2 of a2)
    if ("string" === typeof e2) {
      a2 = e2.split(/(\n|\t)/);
      let f2 = a2.length;
      for (let g2 = 0; g2 < f2; g2++) {
        let h2 = a2[g2];
        "\n" === h2 || "\r\n" === h2 ? c2.push(q.$createLineBreakNode()) : "	" === h2 ? c2.push(q.$createTabNode()) : 0 < h2.length && c2.push(F(h2, b2));
      }
    } else
      ({ content: a2 } = e2), "string" === typeof a2 ? c2.push(...U$1([a2], e2.type)) : Array.isArray(a2) && c2.push(...U$1(a2, e2.type));
  return c2;
}
function ea$1(a2, b2) {
  a2 = q.$getNodeByKey(a2);
  if (G$1(a2) && a2.isAttached()) {
    var c2 = q.$getSelection();
    if (q.$isRangeSelection(c2)) {
      c2 = c2.anchor;
      var e2 = c2.offset, f2 = "element" === c2.type && q.$isLineBreakNode(a2.getChildAtIndex(c2.offset - 1)), g2 = 0;
      if (!f2) {
        let h2 = c2.getNode();
        g2 = e2 + h2.getPreviousSiblings().reduce((k2, l2) => k2 + l2.getTextContentSize(), 0);
      }
      b2() && (f2 ? c2.getNode().select(e2, e2) : a2.getChildren().some((h2) => {
        let k2 = q.$isTextNode(h2);
        if (k2 || q.$isLineBreakNode(h2)) {
          let l2 = h2.getTextContentSize();
          if (k2 && l2 >= g2)
            return h2.select(g2, g2), true;
          g2 -= l2;
        }
        return false;
      }));
    } else
      b2();
  }
}
function V$1(a2, b2) {
  return E(a2) && E(b2) && a2.__text === b2.__text && a2.__highlightType === b2.__highlightType || q.$isTabNode(a2) && q.$isTabNode(b2) || q.$isLineBreakNode(a2) && q.$isLineBreakNode(b2);
}
function W$1(a2) {
  if (!q.$isRangeSelection(a2))
    return false;
  var b2 = a2.anchor.getNode();
  a2 = a2.focus.getNode();
  if (b2.is(a2) && G$1(b2))
    return true;
  b2 = b2.getParent();
  return G$1(b2) && b2.is(a2.getParent());
}
function X$1(a2) {
  a2 = a2.getNodes();
  let b2 = [[]];
  if (1 === a2.length && G$1(a2[0]))
    return b2;
  let c2 = b2[0];
  for (let e2 = 0; e2 < a2.length; e2++) {
    let f2 = a2[e2];
    if (!(E(f2) || q.$isTabNode(f2) || q.$isLineBreakNode(f2)))
      throw Error("Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode");
    q.$isLineBreakNode(f2) ? 0 !== e2 && 0 < c2.length && (c2 = [], b2.push(c2)) : c2.push(f2);
  }
  return b2;
}
function fa$1(a2) {
  var b2 = q.$getSelection();
  if (!q.$isRangeSelection(b2) || !W$1(b2))
    return null;
  let c2 = a2 ? q.OUTDENT_CONTENT_COMMAND : q.INDENT_CONTENT_COMMAND;
  a2 = a2 ? q.OUTDENT_CONTENT_COMMAND : q.INSERT_TAB_COMMAND;
  if (1 < X$1(b2).length)
    return c2;
  var e2 = b2.getNodes()[0];
  if (!(G$1(e2) || E(e2) || q.$isTabNode(e2) || q.$isLineBreakNode(e2)))
    throw Error("Expected selection firstNode to be CodeHighlightNode or TabNode");
  if (G$1(e2))
    return c2;
  let f2 = D(e2);
  e2 = N$1(e2);
  var g2 = b2.anchor;
  let h2 = b2.focus;
  h2.isBefore(g2) ? b2 = h2 : (b2 = g2, g2 = h2);
  return null !== f2 && null !== e2 && b2.key === f2.getKey() && 0 === b2.offset && g2.key === e2.getKey() && g2.offset === e2.getTextContentSize() ? c2 : a2;
}
function Y$1(a2) {
  var b2 = q.$getSelection();
  if (!q.$isRangeSelection(b2) || !W$1(b2))
    return false;
  var c2 = X$1(b2);
  let e2 = c2.length;
  if (1 < c2.length) {
    for (b2 = 0; b2 < e2; b2++) {
      var f2 = c2[b2];
      0 < f2.length && (f2 = f2[0], 0 === b2 && (f2 = D(f2)), null !== f2 && (a2 === q.INDENT_CONTENT_COMMAND ? f2.insertBefore(q.$createTabNode()) : q.$isTabNode(f2) && f2.remove()));
    }
    return true;
  }
  c2 = b2.getNodes()[0];
  if (!(G$1(c2) || E(c2) || q.$isTabNode(c2) || q.$isLineBreakNode(c2)))
    throw Error("Expected selection firstNode to be CodeHighlightNode or CodeTabNode");
  if (G$1(c2))
    return a2 === q.INDENT_CONTENT_COMMAND && b2.insertNodes([q.$createTabNode()]), true;
  c2 = D(c2);
  if (null === c2)
    throw Error("Expected getFirstCodeNodeOfLine to return a valid Code Node");
  a2 === q.INDENT_CONTENT_COMMAND ? q.$isLineBreakNode(c2) ? c2.insertAfter(q.$createTabNode()) : c2.insertBefore(q.$createTabNode()) : q.$isTabNode(c2) && c2.remove();
  return true;
}
function Z$1(a2, b2) {
  let c2 = q.$getSelection();
  if (!q.$isRangeSelection(c2))
    return false;
  let { anchor: e2, focus: f2 } = c2, g2 = e2.offset, h2 = f2.offset, k2 = e2.getNode(), l2 = f2.getNode();
  var r2 = a2 === q.KEY_ARROW_UP_COMMAND;
  if (!W$1(c2) || !E(k2) && !q.$isTabNode(k2) || !E(l2) && !q.$isTabNode(l2))
    return false;
  if (!b2.altKey) {
    if (c2.isCollapsed()) {
      if (a2 = k2.getParentOrThrow(), r2 && 0 === g2 && null === k2.getPreviousSibling()) {
        if (null === a2.getPreviousSibling())
          return a2.selectPrevious(), b2.preventDefault(), true;
      } else if (!r2 && g2 === k2.getTextContentSize() && null === k2.getNextSibling() && null === a2.getNextSibling())
        return a2.selectNext(), b2.preventDefault(), true;
    }
    return false;
  }
  let n2;
  if (k2.isBefore(l2)) {
    var p2 = D(k2);
    n2 = N$1(l2);
  } else
    p2 = D(l2), n2 = N$1(k2);
  if (null == p2 || null == n2)
    return false;
  let w2 = p2.getNodesBetween(n2);
  for (let t3 = 0; t3 < w2.length; t3++) {
    let J2 = w2[t3];
    if (!E(J2) && !q.$isTabNode(J2) && !q.$isLineBreakNode(J2))
      return false;
  }
  b2.preventDefault();
  b2.stopPropagation();
  b2 = r2 ? p2.getPreviousSibling() : n2.getNextSibling();
  if (!q.$isLineBreakNode(b2))
    return true;
  p2 = r2 ? b2.getPreviousSibling() : b2.getNextSibling();
  if (null == p2)
    return true;
  r2 = E(p2) || q.$isTabNode(p2) || q.$isLineBreakNode(p2) ? r2 ? D(p2) : N$1(p2) : null;
  let u2 = null != r2 ? r2 : p2;
  b2.remove();
  w2.forEach((t3) => t3.remove());
  a2 === q.KEY_ARROW_UP_COMMAND ? (w2.forEach((t3) => u2.insertBefore(t3)), u2.insertBefore(b2)) : (u2.insertAfter(b2), u2 = b2, w2.forEach((t3) => {
    u2.insertAfter(t3);
    u2 = t3;
  }));
  c2.setTextNodeRange(k2, g2, l2, h2);
  return true;
}
function ha$1(a2, b2) {
  let c2 = q.$getSelection();
  if (!q.$isRangeSelection(c2))
    return false;
  let { anchor: e2, focus: f2 } = c2;
  var g2 = e2.getNode();
  let h2 = f2.getNode();
  a2 = a2 === q.MOVE_TO_START;
  if (!E(g2) && !q.$isTabNode(g2) || !E(h2) && !q.$isTabNode(h2))
    return false;
  if (a2)
    if (g2 = P$1(h2, f2.offset), null !== g2) {
      let { node: k2, offset: l2 } = g2;
      q.$isLineBreakNode(k2) ? k2.selectNext(0, 0) : c2.setTextNodeRange(k2, l2, k2, l2);
    } else
      h2.getParentOrThrow().selectStart();
  else
    Q$1(h2).select();
  b2.preventDefault();
  b2.stopPropagation();
  return true;
}
LexicalCode_prod.$createCodeHighlightNode = F;
LexicalCode_prod.$createCodeNode = C;
LexicalCode_prod.$isCodeHighlightNode = E;
LexicalCode_prod.$isCodeNode = G$1;
LexicalCode_prod.CODE_LANGUAGE_FRIENDLY_NAME_MAP = H$1;
LexicalCode_prod.CODE_LANGUAGE_MAP = I$1;
LexicalCode_prod.CodeHighlightNode = L$1;
LexicalCode_prod.CodeNode = y;
LexicalCode_prod.DEFAULT_CODE_LANGUAGE = "javascript";
LexicalCode_prod.PrismTokenizer = O$1;
LexicalCode_prod.getCodeLanguages = () => Object.keys(d$1.languages).filter((a2) => "function" !== typeof d$1.languages[a2]).sort();
LexicalCode_prod.getDefaultCodeLanguage = () => "javascript";
LexicalCode_prod.getEndOfCodeInLine = Q$1;
LexicalCode_prod.getFirstCodeNodeOfLine = D;
LexicalCode_prod.getLanguageFriendlyName = function(a2) {
  a2 = K$1(a2);
  return H$1[a2] || a2;
};
LexicalCode_prod.getLastCodeNodeOfLine = N$1;
LexicalCode_prod.getStartOfCodeInLine = P$1;
LexicalCode_prod.normalizeCodeLang = K$1;
LexicalCode_prod.registerCodeHighlighting = function(a2, b2) {
  if (!a2.hasNodes([y, L$1]))
    throw Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
  null == b2 && (b2 = O$1);
  return m.mergeRegister(
    a2.registerMutationListener(y, (c2) => {
      a2.update(() => {
        for (let [g2, h2] of c2)
          if ("destroyed" !== h2) {
            var e2 = q.$getNodeByKey(g2);
            if (null !== e2)
              a: {
                var f2 = e2;
                e2 = a2.getElementByKey(f2.getKey());
                if (null === e2)
                  break a;
                f2 = f2.getChildren();
                let k2 = f2.length;
                if (k2 === e2.__cachedChildrenLength)
                  break a;
                e2.__cachedChildrenLength = k2;
                let l2 = "1", r2 = 1;
                for (let n2 = 0; n2 < k2; n2++)
                  q.$isLineBreakNode(f2[n2]) && (l2 += "\n" + ++r2);
                e2.setAttribute("data-gutter", l2);
              }
          }
      });
    }),
    a2.registerNodeTransform(y, (c2) => S$1(c2, a2, b2)),
    a2.registerNodeTransform(q.TextNode, (c2) => R$1(c2, a2, b2)),
    a2.registerNodeTransform(L$1, (c2) => R$1(c2, a2, b2)),
    a2.registerCommand(q.KEY_TAB_COMMAND, (c2) => {
      let e2 = fa$1(c2.shiftKey);
      if (null === e2)
        return false;
      c2.preventDefault();
      a2.dispatchCommand(e2, void 0);
      return true;
    }, q.COMMAND_PRIORITY_LOW),
    a2.registerCommand(q.INSERT_TAB_COMMAND, () => {
      let c2 = q.$getSelection();
      if (!W$1(c2))
        return false;
      q.$insertNodes([q.$createTabNode()]);
      return true;
    }, q.COMMAND_PRIORITY_LOW),
    a2.registerCommand(q.INDENT_CONTENT_COMMAND, () => Y$1(q.INDENT_CONTENT_COMMAND), q.COMMAND_PRIORITY_LOW),
    a2.registerCommand(q.OUTDENT_CONTENT_COMMAND, () => Y$1(q.OUTDENT_CONTENT_COMMAND), q.COMMAND_PRIORITY_LOW),
    a2.registerCommand(q.KEY_ARROW_UP_COMMAND, (c2) => Z$1(q.KEY_ARROW_UP_COMMAND, c2), q.COMMAND_PRIORITY_LOW),
    a2.registerCommand(q.KEY_ARROW_DOWN_COMMAND, (c2) => Z$1(q.KEY_ARROW_DOWN_COMMAND, c2), q.COMMAND_PRIORITY_LOW),
    a2.registerCommand(q.MOVE_TO_END, (c2) => ha$1(q.MOVE_TO_END, c2), q.COMMAND_PRIORITY_LOW),
    a2.registerCommand(q.MOVE_TO_START, (c2) => ha$1(q.MOVE_TO_START, c2), q.COMMAND_PRIORITY_LOW)
  );
};
const LexicalCode = LexicalCode_prod;
var LexicalCode_1 = LexicalCode;
var k = Lexical_1, t2 = LexicalCode_1, z = LexicalList_1, B2 = LexicalRichText_1, aa = LexicalUtils_1, G = LexicalLink_1;
function H2(a2, b2) {
  let c2 = {};
  for (let d2 of a2)
    a2 = b2(d2), c2[a2] ? c2[a2].push(d2) : c2[a2] = [d2];
  return c2;
}
function I(a2) {
  a2 = H2(a2, (b2) => b2.type);
  return { element: a2.element || [], textFormat: a2["text-format"] || [], textMatch: a2["text-match"] || [] };
}
let J = /[!-/:-@[-`{-~\s]/;
function ba(a2) {
  let b2 = I(a2), c2 = b2.textFormat.filter((d2) => 1 === d2.format.length);
  return (d2) => {
    let e2 = [];
    d2 = (d2 || k.$getRoot()).getChildren();
    for (let f2 of d2)
      d2 = ca(f2, b2.element, c2, b2.textMatch), null != d2 && e2.push(d2);
    return e2.join("\n\n");
  };
}
function ca(a2, b2, c2, d2) {
  for (let e2 of b2)
    if (b2 = e2.export(a2, (f2) => K(f2, c2, d2)), null != b2)
      return b2;
  return k.$isElementNode(a2) ? K(a2, c2, d2) : k.$isDecoratorNode(a2) ? a2.getTextContent() : null;
}
function K(a2, b2, c2) {
  let d2 = [];
  a2 = a2.getChildren();
  a:
    for (let e2 of a2) {
      for (let f2 of c2)
        if (a2 = f2.export(e2, (g2) => K(g2, b2, c2), (g2, l2) => L3(g2, l2, b2)), null != a2) {
          d2.push(a2);
          continue a;
        }
      k.$isLineBreakNode(e2) ? d2.push("\n") : k.$isTextNode(e2) ? d2.push(L3(e2, e2.getTextContent(), b2)) : k.$isElementNode(e2) ? d2.push(K(e2, b2, c2)) : k.$isDecoratorNode(e2) && d2.push(e2.getTextContent());
    }
  return d2.join("");
}
function L3(a2, b2, c2) {
  let d2 = b2.trim(), e2 = d2, f2 = /* @__PURE__ */ new Set();
  for (let l2 of c2) {
    c2 = l2.format[0];
    let p2 = l2.tag;
    if (M(a2, c2) && !f2.has(c2)) {
      f2.add(c2);
      var g2 = N(a2, true);
      M(g2, c2) || (e2 = p2 + e2);
      g2 = N(a2, false);
      M(g2, c2) || (e2 += p2);
    }
  }
  return b2.replace(d2, e2);
}
function N(a2, b2) {
  let c2 = b2 ? a2.getPreviousSibling() : a2.getNextSibling();
  c2 || (a2 = a2.getParentOrThrow(), a2.isInline() && (c2 = b2 ? a2.getPreviousSibling() : a2.getNextSibling()));
  for (; c2; ) {
    if (k.$isElementNode(c2)) {
      if (!c2.isInline())
        break;
      a2 = b2 ? c2.getLastDescendant() : c2.getFirstDescendant();
      if (k.$isTextNode(a2))
        return a2;
      c2 = b2 ? c2.getPreviousSibling() : c2.getNextSibling();
    }
    if (k.$isTextNode(c2))
      return c2;
    if (!k.$isElementNode(c2))
      break;
  }
  return null;
}
function M(a2, b2) {
  return k.$isTextNode(a2) && a2.hasFormat(b2);
}
let O = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement, da = O && "documentMode" in document ? document.documentMode : null;
O && "InputEvent" in window && !da ? "getTargetRanges" in new window.InputEvent("input") : false;
let P = O && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), Q = O && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
let ea = O && /^(?=.*Chrome).*/i.test(navigator.userAgent), R = O && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !ea, fa = /^\s{0,3}$/, S = /^```(\w{1,10})?\s?$/;
function ha(a2) {
  let b2 = I(a2), c2 = ia(b2.textFormat);
  return (d2, e2) => {
    d2 = d2.split("\n");
    var f2 = d2.length;
    e2 = e2 || k.$getRoot();
    e2.clear();
    for (let h2 = 0; h2 < f2; h2++) {
      var g2 = d2[h2];
      a: {
        var l2 = d2, p2 = h2;
        var r2 = e2;
        var y2 = l2[p2].match(S);
        if (y2) {
          for (var q2 = p2, m2 = l2.length; ++q2 < m2; )
            if (l2[q2].match(S)) {
              y2 = t2.$createCodeNode(y2[1]);
              l2 = k.$createTextNode(l2.slice(p2 + 1, q2).join("\n"));
              y2.append(l2);
              r2.append(y2);
              r2 = [y2, q2];
              break a;
            }
        }
        r2 = [null, p2];
      }
      let [n2, v3] = r2;
      if (null != n2)
        h2 = v3;
      else {
        r2 = g2;
        m2 = e2;
        var w2 = b2.element;
        q2 = c2;
        l2 = b2.textMatch;
        p2 = r2.trim();
        y2 = k.$createTextNode(p2);
        g2 = k.$createParagraphNode();
        g2.append(y2);
        m2.append(g2);
        for (let { regExp: x3, replace: u2 } of w2)
          if (m2 = r2.match(x3)) {
            y2.setTextContent(r2.slice(m2[0].length));
            u2(g2, [y2], m2, true);
            break;
          }
        T(y2, q2, l2);
        g2.isAttached() && 0 < p2.length && (r2 = g2.getPreviousSibling(), k.$isParagraphNode(r2) || B2.$isQuoteNode(r2) || z.$isListNode(r2)) && (q2 = r2, z.$isListNode(r2) && (r2 = r2.getLastDescendant(), q2 = null == r2 ? null : aa.$findMatchingParent(r2, z.$isListItemNode)), null != q2 && 0 < q2.getTextContentSize() && (q2.splice(q2.getChildrenSize(), 0, [k.$createLineBreakNode(), ...g2.getChildren()]), g2.remove()));
      }
    }
    d2 = e2.getChildren();
    for (let h2 of d2)
      d2 = h2, k.$isParagraphNode(d2) ? (f2 = d2.getFirstChild(), d2 = null == f2 || 1 === d2.getChildrenSize() && k.$isTextNode(f2) && fa.test(f2.getTextContent())) : d2 = false, d2 && h2.remove();
    null !== k.$getSelection() && e2.selectEnd();
  };
}
function T(a2, b2, c2) {
  var d2 = a2.getTextContent();
  let e2 = ja(d2, b2);
  if (e2) {
    var f2, g2;
    if (e2[0] === d2)
      var l2 = a2;
    else {
      d2 = e2.index || 0;
      let p2 = d2 + e2[0].length;
      0 === d2 ? [l2, f2] = a2.splitText(p2) : [g2, l2, f2] = a2.splitText(d2, p2);
    }
    l2.setTextContent(e2[2]);
    if (a2 = b2.transformersByTag[e2[1]])
      for (let p2 of a2.format)
        l2.hasFormat(p2) || l2.toggleFormat(p2);
    l2.hasFormat("code") || T(l2, b2, c2);
    g2 && T(g2, b2, c2);
    f2 && T(f2, b2, c2);
  } else
    U(a2, c2);
}
function U(a2, b2) {
  a:
    for (; a2; ) {
      for (let c2 of b2) {
        let d2 = a2.getTextContent().match(c2.importRegExp);
        if (!d2)
          continue;
        let e2 = d2.index || 0, f2 = e2 + d2[0].length, g2, l2, p2;
        0 === e2 ? [g2, a2] = a2.splitText(f2) : [l2, g2, p2] = a2.splitText(e2, f2);
        l2 && U(l2, b2);
        p2 && (a2 = p2);
        c2.replace(g2, d2);
        continue a;
      }
      break;
    }
}
function ja(a2, b2) {
  var c2 = a2.match(b2.openTagsRegExp);
  if (null == c2)
    return null;
  for (let f2 of c2) {
    var d2 = f2.replace(/^\s/, "");
    c2 = b2.fullMatchRegExpByTag[d2];
    if (null != c2 && (c2 = a2.match(c2), d2 = b2.transformersByTag[d2], null != c2 && null != d2)) {
      if (false !== d2.intraword)
        return c2;
      var { index: e2 = 0 } = c2;
      d2 = a2[e2 - 1];
      e2 = a2[e2 + c2[0].length];
      if (!(d2 && !J.test(d2) || e2 && !J.test(e2)))
        return c2;
    }
  }
  return null;
}
function ia(a2) {
  let b2 = {}, c2 = {}, d2 = [];
  for (let e2 of a2) {
    ({ tag: a2 } = e2);
    b2[a2] = e2;
    let f2 = a2.replace(/(\*|\^|\+)/g, "\\$1");
    d2.push(f2);
    c2[a2] = P || Q || R ? new RegExp(`(${f2})(?![${f2}\\s])(.*?[^${f2}\\s])${f2}(?!${f2})`) : new RegExp(`(?<![\\\\${f2}])(${f2})((\\\\${f2})?.*?[^${f2}\\s](\\\\${f2})?)((?<!\\\\)|(?<=\\\\\\\\))(${f2})(?![\\\\${f2}])`);
  }
  return { fullMatchRegExpByTag: c2, openTagsRegExp: new RegExp((P || Q || R ? "" : "(?<![\\\\])") + "(" + d2.join("|") + ")", "g"), transformersByTag: b2 };
}
function V(a2, b2, c2) {
  let d2 = c2.length;
  for (; b2 >= d2; b2--) {
    let e2 = b2 - d2;
    if (W(a2, e2, c2, 0, d2) && " " !== a2[e2 + d2])
      return e2;
  }
  return -1;
}
function W(a2, b2, c2, d2, e2) {
  for (let f2 = 0; f2 < e2; f2++)
    if (a2[b2 + f2] !== c2[d2 + f2])
      return false;
  return true;
}
let ka = (a2) => (b2, c2, d2) => {
  d2 = a2(d2);
  d2.append(...c2);
  b2.replace(d2);
  d2.select(0, 0);
}, X = (a2) => (b2, c2, d2) => {
  var e2 = b2.getPreviousSibling(), f2 = b2.getNextSibling();
  const g2 = z.$createListItemNode("check" === a2 ? "x" === d2[3] : void 0);
  z.$isListNode(f2) && f2.getListType() === a2 ? (e2 = f2.getFirstChild(), null !== e2 ? e2.insertBefore(g2) : f2.append(g2), b2.remove()) : z.$isListNode(e2) && e2.getListType() === a2 ? (e2.append(g2), b2.remove()) : (f2 = z.$createListNode(a2, "number" === a2 ? Number(d2[2]) : void 0), f2.append(g2), b2.replace(f2));
  g2.append(...c2);
  g2.select(0, 0);
  (b2 = Math.floor(d2[1].length / 4)) && g2.setIndent(b2);
}, Y = (a2, b2, c2) => {
  const d2 = [];
  var e2 = a2.getChildren();
  let f2 = 0;
  for (const l2 of e2)
    if (z.$isListItemNode(l2)) {
      if (1 === l2.getChildrenSize() && (e2 = l2.getFirstChild(), z.$isListNode(e2))) {
        d2.push(Y(e2, b2, c2 + 1));
        continue;
      }
      e2 = " ".repeat(4 * c2);
      var g2 = a2.getListType();
      g2 = "number" === g2 ? `${a2.getStart() + f2}. ` : "check" === g2 ? `- [${l2.getChecked() ? "x" : " "}] ` : "- ";
      d2.push(e2 + g2 + b2(l2));
      f2++;
    }
  return d2.join("\n");
}, la = { dependencies: [B2.HeadingNode], export: (a2, b2) => {
  if (!B2.$isHeadingNode(a2))
    return null;
  const c2 = Number(a2.getTag().slice(1));
  return "#".repeat(c2) + " " + b2(a2);
}, regExp: /^(#{1,6})\s/, replace: ka((a2) => B2.$createHeadingNode("h" + a2[1].length)), type: "element" }, ma = { dependencies: [B2.QuoteNode], export: (a2, b2) => {
  if (!B2.$isQuoteNode(a2))
    return null;
  a2 = b2(a2).split("\n");
  b2 = [];
  for (const c2 of a2)
    b2.push("> " + c2);
  return b2.join("\n");
}, regExp: /^>\s/, replace: (a2, b2, c2, d2) => {
  if (d2 && (c2 = a2.getPreviousSibling(), B2.$isQuoteNode(c2))) {
    c2.splice(c2.getChildrenSize(), 0, [k.$createLineBreakNode(), ...b2]);
    c2.select(0, 0);
    a2.remove();
    return;
  }
  c2 = B2.$createQuoteNode();
  c2.append(...b2);
  a2.replace(c2);
  c2.select(0, 0);
}, type: "element" }, na = { dependencies: [t2.CodeNode], export: (a2) => {
  if (!t2.$isCodeNode(a2))
    return null;
  const b2 = a2.getTextContent();
  return "```" + (a2.getLanguage() || "") + (b2 ? "\n" + b2 : "") + "\n```";
}, regExp: /^```(\w{1,10})?\s/, replace: ka((a2) => t2.$createCodeNode(a2 ? a2[1] : void 0)), type: "element" }, oa = { dependencies: [z.ListNode, z.ListItemNode], export: (a2, b2) => z.$isListNode(a2) ? Y(a2, b2, 0) : null, regExp: /^(\s*)[-*+]\s/, replace: X("bullet"), type: "element" }, pa = { dependencies: [z.ListNode, z.ListItemNode], export: (a2, b2) => z.$isListNode(a2) ? Y(a2, b2, 0) : null, regExp: /^(\s*)(?:-\s)?\s?(\[(\s|x)?\])\s/i, replace: X("check"), type: "element" }, qa = { dependencies: [z.ListNode, z.ListItemNode], export: (a2, b2) => z.$isListNode(a2) ? Y(a2, b2, 0) : null, regExp: /^(\s*)(\d{1,})\.\s/, replace: X("number"), type: "element" }, ra = { format: ["code"], tag: "`", type: "text-format" }, sa = { format: ["highlight"], tag: "==", type: "text-format" }, ta = { format: ["bold", "italic"], tag: "***", type: "text-format" }, va = { format: ["bold", "italic"], intraword: false, tag: "___", type: "text-format" }, wa = {
  format: ["bold"],
  tag: "**",
  type: "text-format"
}, xa = { format: ["bold"], intraword: false, tag: "__", type: "text-format" }, ya = { format: ["strikethrough"], tag: "~~", type: "text-format" }, za = { format: ["italic"], tag: "*", type: "text-format" }, Aa = { format: ["italic"], intraword: false, tag: "_", type: "text-format" }, Ba = { dependencies: [G.LinkNode], export: (a2, b2, c2) => {
  if (!G.$isLinkNode(a2))
    return null;
  b2 = (b2 = a2.getTitle()) ? `[${a2.getTextContent()}](${a2.getURL()} "${b2}")` : `[${a2.getTextContent()}](${a2.getURL()})`;
  const d2 = a2.getFirstChild();
  return 1 === a2.getChildrenSize() && k.$isTextNode(d2) ? c2(d2, b2) : b2;
}, importRegExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))/, regExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))$/, replace: (a2, b2) => {
  const [, c2, d2, e2] = b2;
  b2 = G.$createLinkNode(d2, { title: e2 });
  const f2 = k.$createTextNode(c2);
  f2.setFormat(a2.getFormat());
  b2.append(f2);
  a2.replace(b2);
}, trigger: ")", type: "text-match" }, Ca = [la, ma, na, oa, qa], Da = [ra, ta, va, wa, xa, sa, za, Aa, ya], Ea = [Ba], Z = [...Ca, ...Da, ...Ea];
LexicalMarkdown_prod.$convertFromMarkdownString = function(a2, b2 = Z, c2) {
  return ha(b2)(a2, c2);
};
LexicalMarkdown_prod.$convertToMarkdownString = function(a2 = Z, b2) {
  return ba(a2)(b2);
};
LexicalMarkdown_prod.BOLD_ITALIC_STAR = ta;
LexicalMarkdown_prod.BOLD_ITALIC_UNDERSCORE = va;
LexicalMarkdown_prod.BOLD_STAR = wa;
LexicalMarkdown_prod.BOLD_UNDERSCORE = xa;
LexicalMarkdown_prod.CHECK_LIST = pa;
LexicalMarkdown_prod.CODE = na;
LexicalMarkdown_prod.ELEMENT_TRANSFORMERS = Ca;
LexicalMarkdown_prod.HEADING = la;
LexicalMarkdown_prod.HIGHLIGHT = sa;
LexicalMarkdown_prod.INLINE_CODE = ra;
LexicalMarkdown_prod.ITALIC_STAR = za;
LexicalMarkdown_prod.ITALIC_UNDERSCORE = Aa;
LexicalMarkdown_prod.LINK = Ba;
LexicalMarkdown_prod.ORDERED_LIST = qa;
LexicalMarkdown_prod.QUOTE = ma;
LexicalMarkdown_prod.STRIKETHROUGH = ya;
LexicalMarkdown_prod.TEXT_FORMAT_TRANSFORMERS = Da;
LexicalMarkdown_prod.TEXT_MATCH_TRANSFORMERS = Ea;
LexicalMarkdown_prod.TRANSFORMERS = Z;
LexicalMarkdown_prod.UNORDERED_LIST = oa;
LexicalMarkdown_prod.registerMarkdownShortcuts = function(a2, b2 = Z) {
  let c2 = I(b2), d2 = H2(c2.textFormat, ({ tag: f2 }) => f2[f2.length - 1]), e2 = H2(c2.textMatch, ({ trigger: f2 }) => f2);
  for (let f2 of b2)
    if (b2 = f2.type, "element" === b2 || "text-match" === b2) {
      b2 = f2.dependencies;
      for (let g2 of b2)
        if (!a2.hasNode(g2))
          throw Error(`MarkdownShortcuts: missing dependency ${g2.getType()} for transformer. Ensure node dependency is included in editor initial config.`);
    }
  return a2.registerUpdateListener(({ tags: f2, dirtyLeaves: g2, editorState: l2, prevEditorState: p2 }) => {
    if (!f2.has("historic") && !a2.isComposing()) {
      var r2 = l2.read(k.$getSelection);
      f2 = p2.read(k.$getSelection);
      if (k.$isRangeSelection(f2) && k.$isRangeSelection(r2) && r2.isCollapsed()) {
        p2 = r2.anchor.key;
        var y2 = r2.anchor.offset, q2 = l2._nodeMap.get(p2);
        !k.$isTextNode(q2) || !g2.has(p2) || 1 !== y2 && y2 > f2.anchor.offset + 1 || a2.update(() => {
          if (!q2.hasFormat("code")) {
            var m2 = q2.getParent();
            if (null !== m2 && !t2.$isCodeNode(m2)) {
              var w2 = r2.anchor.offset;
              b: {
                var h2 = c2.element, n2 = m2.getParent();
                if (k.$isRootOrShadowRoot(n2) && m2.getFirstChild() === q2 && (n2 = q2.getTextContent(), " " === n2[w2 - 1])) {
                  for (let {
                    regExp: D2,
                    replace: E2
                  } of h2)
                    if ((h2 = n2.match(D2)) && h2[0].length === w2) {
                      n2 = q2.getNextSiblings();
                      let [F2, ua2] = q2.splitText(w2);
                      F2.remove();
                      n2 = ua2 ? [ua2, ...n2] : n2;
                      E2(m2, n2, h2, false);
                      m2 = true;
                      break b;
                    }
                }
                m2 = false;
              }
              if (!m2) {
                b: {
                  h2 = q2.getTextContent();
                  m2 = e2[h2[w2 - 1]];
                  if (null != m2) {
                    w2 < h2.length && (h2 = h2.slice(0, w2));
                    for (x3 of m2)
                      if (m2 = h2.match(x3.regExp), null !== m2) {
                        h2 = m2.index || 0;
                        n2 = h2 + m2[0].length;
                        var v3 = void 0;
                        0 === h2 ? [v3] = q2.splitText(n2) : [, v3] = q2.splitText(h2, n2);
                        v3.selectNext(0, 0);
                        x3.replace(v3, m2);
                        var x3 = true;
                        break b;
                      }
                  }
                  x3 = false;
                }
                if (!x3)
                  b: {
                    n2 = q2.getTextContent();
                    --w2;
                    var u2 = n2[w2];
                    if (x3 = d2[u2])
                      for (let D2 of x3) {
                        var { tag: C2 } = D2;
                        x3 = C2.length;
                        let E2 = w2 - x3 + 1;
                        if (!(1 < x3 && !W(n2, E2, C2, 0, x3) || " " === n2[E2 - 1]) && (v3 = n2[w2 + 1], false !== D2.intraword || !v3 || J.test(v3))) {
                          m2 = v3 = q2;
                          h2 = V(n2, E2, C2);
                          for (var A2 = m2; 0 > h2 && (A2 = A2.getPreviousSibling()) && !k.$isLineBreakNode(A2); )
                            k.$isTextNode(A2) && (h2 = A2.getTextContent(), m2 = A2, h2 = V(h2, h2.length, C2));
                          if (!(0 > h2 || m2 === v3 && h2 + x3 === E2 || (C2 = m2.getTextContent(), 0 < h2 && C2[h2 - 1] === u2 || (A2 = C2[h2 - 1], false === D2.intraword && A2 && !J.test(A2))))) {
                            n2 = v3.getTextContent();
                            n2 = n2.slice(0, E2) + n2.slice(w2 + 1);
                            v3.setTextContent(n2);
                            n2 = m2 === v3 ? n2 : C2;
                            m2.setTextContent(n2.slice(0, h2) + n2.slice(h2 + x3));
                            n2 = k.$getSelection();
                            u2 = k.$createRangeSelection();
                            k.$setSelection(u2);
                            w2 = w2 - x3 * (m2 === v3 ? 2 : 1) + 1;
                            u2.anchor.set(m2.__key, h2, "text");
                            u2.focus.set(v3.__key, w2, "text");
                            for (let F2 of D2.format)
                              u2.hasFormat(F2) || u2.formatText(F2);
                            u2.anchor.set(u2.focus.key, u2.focus.offset, u2.focus.type);
                            for (let F2 of D2.format)
                              u2.hasFormat(F2) && u2.toggleFormat(F2);
                            k.$isRangeSelection(n2) && (u2.format = n2.format);
                            break b;
                          }
                        }
                      }
                  }
              }
            }
          }
        });
      }
    }
  });
};
const LexicalMarkdown = LexicalMarkdown_prod;
var LexicalMarkdown_1 = LexicalMarkdown;
var LexicalMarkdownShortcutPlugin_prod = {};
var c = LexicalMarkdown_1, d = LexicalComposerContext_1, e = LexicalHorizontalRuleNode_1, f = reactExports;
let g = [{ dependencies: [e.HorizontalRuleNode], export: (a2) => e.$isHorizontalRuleNode(a2) ? "***" : null, regExp: /^(---|\*\*\*|___)\s?$/, replace: (a2, b2, k2, h2) => {
  b2 = e.$createHorizontalRuleNode();
  h2 || null != a2.getNextSibling() ? a2.replace(b2) : a2.insertBefore(b2);
  b2.selectNext();
}, type: "element" }, ...c.TRANSFORMERS];
LexicalMarkdownShortcutPlugin_prod.DEFAULT_TRANSFORMERS = g;
LexicalMarkdownShortcutPlugin_prod.MarkdownShortcutPlugin = function({ transformers: a2 = g }) {
  let [b2] = d.useLexicalComposerContext();
  f.useEffect(() => c.registerMarkdownShortcuts(b2, a2), [b2, a2]);
  return null;
};
const LexicalMarkdownShortcutPlugin = LexicalMarkdownShortcutPlugin_prod;
var LexicalMarkdownShortcutPlugin_1 = LexicalMarkdownShortcutPlugin;
const [markdownShortcutPlugin] = realmPlugin({
  id: "markdown-shortcut",
  dependencies: [],
  systemSpec: system((_) => ({}), [coreSystem]),
  init: (realm2, _, pluginIds) => {
    const allowedHeadingLevels = pluginIds.includes("headings") ? (
      // @ts-expect-error we query the realm for the allowed heading levels
      realm2.getKeyValue("allowedHeadingLevels")
    ) : [];
    const transformers = pickTransformersForActivePlugins(pluginIds, allowedHeadingLevels);
    realm2.pubKey("addComposerChild", () => /* @__PURE__ */ React__default.createElement(LexicalMarkdownShortcutPlugin_1.MarkdownShortcutPlugin, { transformers }));
    realm2.pubKey("addNestedEditorChild", () => /* @__PURE__ */ React__default.createElement(LexicalMarkdownShortcutPlugin_1.MarkdownShortcutPlugin, { transformers }));
  }
});
const createBlockNode = (createNode) => {
  return (parentNode, children, match) => {
    const node2 = createNode(match);
    node2.append(...children);
    parentNode.replace(node2);
    node2.select(0, 0);
  };
};
function pickTransformersForActivePlugins(pluginIds, allowedHeadingLevels) {
  const transformers = [
    LexicalMarkdown_1.BOLD_ITALIC_STAR,
    LexicalMarkdown_1.BOLD_ITALIC_UNDERSCORE,
    LexicalMarkdown_1.BOLD_STAR,
    LexicalMarkdown_1.BOLD_UNDERSCORE,
    LexicalMarkdown_1.INLINE_CODE,
    LexicalMarkdown_1.ITALIC_STAR,
    LexicalMarkdown_1.ITALIC_UNDERSCORE
    // HIGHLIGHT,
    // STRIKETHROUGH
  ];
  if (pluginIds.includes("headings")) {
    const minHeadingLevel = Math.min(...allowedHeadingLevels);
    const maxHeadingLevel = Math.max(...allowedHeadingLevels);
    const headingRegExp = new RegExp(`^(#{${minHeadingLevel},${maxHeadingLevel}})\\s`);
    const HEADING = {
      dependencies: [LexicalRichText_1.HeadingNode],
      export: (node2, exportChildren) => {
        if (!LexicalRichText_1.$isHeadingNode(node2)) {
          return null;
        }
        const level = Number(node2.getTag().slice(1));
        return "#".repeat(level) + " " + exportChildren(node2);
      },
      regExp: headingRegExp,
      replace: createBlockNode((match) => {
        const tag = `h${match[1].length}`;
        return LexicalRichText_1.$createHeadingNode(tag);
      }),
      type: "element"
    };
    transformers.push(HEADING);
  }
  if (pluginIds.includes("quote")) {
    transformers.push(LexicalMarkdown_1.QUOTE);
  }
  if (pluginIds.includes("link")) {
    transformers.push(LexicalMarkdown_1.LINK);
  }
  if (pluginIds.includes("lists")) {
    transformers.push(LexicalMarkdown_1.ORDERED_LIST, LexicalMarkdown_1.UNORDERED_LIST, LexicalMarkdown_1.CHECK_LIST);
  }
  if (pluginIds.includes("codeblock")) {
    const codeTransformerCopy = {
      ...LexicalMarkdown_1.CODE,
      dependencies: [CodeBlockNode],
      replace: (parentNode, _children, match) => {
        const codeBlockNode = $createCodeBlockNode({ code: "", language: match ? match[1] : "", meta: "" });
        parentNode.replace(codeBlockNode);
        setTimeout(() => codeBlockNode.select(), 80);
      }
    };
    transformers.push(codeTransformerCopy);
  }
  return transformers;
}
const autoSavingTime = 3e3;
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string2) {
      return string2.split("");
    }
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator(array[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder2) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder2) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder2) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (value === placeholder2 || value === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string2) {
      return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
    }
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    function trimmedEndIndex(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace.test(string2.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string2) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string2)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root2._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice2 = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index2 = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array[index2];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? undefined$1 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n2) {
        return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value = array[index2], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start2, end) {
        var length = array.length;
        start2 = toInteger(start2);
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end = end === undefined$1 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start2 > end ? 0 : toLength(end);
        while (start2 < end) {
          array[start2++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start2, end) {
        return number >= nativeMin(start2, end) && number < nativeMax(start2, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen2 = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen2 ? cacheHas(seen2, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen2) {
                seen2.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data = matchData[index2];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength2(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index2] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n2) {
        var length = array.length;
        if (!length) {
          return;
        }
        n2 += n2 < 0 ? length : 0;
        return isIndex(n2, length) ? array[n2] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen2 = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen2 = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen2, computed, fromIndex, comparator)) > -1) {
            if (seen2 !== array) {
              splice2.call(seen2, fromIndex, 1);
            }
            splice2.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous2) {
            var previous2 = index2;
            if (isIndex(index2)) {
              splice2.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start2, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start2;
          start2 += step;
        }
        return result2;
      }
      function baseRepeat(string2, n2) {
        var result2 = "";
        if (!string2 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n2 % 2) {
            result2 += string2;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string2 += string2;
          }
        } while (n2);
        return result2;
      }
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n2) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n2, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string2) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start2, end) {
        var index2 = -1, length = array.length;
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start2 > end ? 0 : end - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start2];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed, seen2)) {
            var seen2 = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen2 = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen2 = new SetCache();
        } else {
          seen2 = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen2.length;
              while (seenIndex--) {
                if (seen2[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen2.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen2, computed, comparator)) {
              if (seen2 !== result2) {
                seen2.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined$1;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array, start2, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return !start2 && end >= length ? array : baseSlice(array, start2, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root2.clearTimeout(id2);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString2(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder2 = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder2 && args[length - 1] !== placeholder2 ? [] : replaceHolders(args, placeholder2);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length
            );
          }
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder2 = getHolder(wrapper), holdersCount = countHolders(args, placeholder2);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder2);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root2 && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start2, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
            end = step = undefined$1;
          }
          start2 = toFinite(start2);
          if (end === undefined$1) {
            end = start2;
            start2 = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start2 < end ? 1 : -1 : toFinite(step);
          return baseRange(start2, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder2, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder2;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen2) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen2.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert2 = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert2 || (convert2 = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map3, key) {
        var data = map3.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e2) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start2, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data = transforms[index2], size2 = data.size;
          switch (data.type) {
            case "drop":
              start2 += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start2 + size2);
              break;
            case "takeRight":
              start2 = nativeMax(start2, end - size2);
              break;
          }
        }
        return { "start": start2, "end": end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength2(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index2, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start2, transform2) {
        start2 = nativeMax(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start2 + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index2 < start2) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start2] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root2.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$1 ? length : size2;
        while (++index2 < size2) {
          var rand = baseRandom(index2, lastIndex), value = array[rand];
          array[rand] = array[index2];
          array[index2] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string2) {
        var result2 = [];
        if (string2.charCodeAt(0) === 46) {
          result2.push("");
        }
        string2.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size2);
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function dropRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start2, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
          start2 = 0;
          end = length;
        }
        return baseFill(array, value, start2, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array, value, index2);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join2(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n2) {
        return array && array.length ? baseNth(array, toInteger(n2)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start2, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start2, end)) {
          start2 = 0;
          end = length;
        } else {
          start2 = start2 == null ? 0 : toInteger(start2);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array, start2, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value);
          if (index2 < length && eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n2, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap2(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
          return this.thru(interceptor);
        }
        value = value.slice(start2, +start2 + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined$1;
          if (result2) {
            previous2.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous2 = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous2.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard) {
        if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root2.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard) {
        n2 = guard ? undefined$1 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
      }
      function before(n2, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver2) {
        if (typeof func != "function" || resolver2 != null && typeof resolver2 != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver2 ? resolver2.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger(start2);
        return baseRest(func, start2);
      }
      function spread(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
        return baseRest(function(args) {
          var array = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength2(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger2(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value === undefined$1) {
            index2 = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee2(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start2, end) {
        start2 = toFinite(start2);
        if (end === undefined$1) {
          end = start2;
          start2 = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start2, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize(word) : word);
      });
      function capitalize(string2) {
        return upperFirst(toString2(string2).toLowerCase());
      }
      function deburr(string2) {
        string2 = toString2(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string2, target, position2) {
        string2 = toString2(string2);
        target = baseToString(target);
        var length = string2.length;
        position2 = position2 === undefined$1 ? length : baseClamp(toInteger(position2), 0, length);
        var end = position2;
        position2 -= target.length;
        return position2 >= 0 && string2.slice(position2, end) == target;
      }
      function escape2(string2) {
        string2 = toString2(string2);
        return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
      }
      function escapeRegExp(string2) {
        string2 = toString2(string2);
        return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string2, length, chars) {
        string2 = toString2(string2);
        length = toInteger(length);
        var strLength = length ? stringSize(string2) : 0;
        if (!length || strLength >= length) {
          return string2;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string2, length, chars) {
        string2 = toString2(string2);
        length = toInteger(length);
        var strLength = length ? stringSize(string2) : 0;
        return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
      }
      function padStart(string2, length, chars) {
        string2 = toString2(string2);
        length = toInteger(length);
        var strLength = length ? stringSize(string2) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
      }
      function parseInt2(string2, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string2).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string2, n2, guard) {
        if (guard ? isIterateeCall(string2, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        return baseRepeat(toString2(string2), n2);
      }
      function replace() {
        var args = arguments, string2 = toString2(args[0]);
        return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string2, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string2 = toString2(string2);
        if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string2)) {
            return castSlice(stringToArray(string2), 0, limit);
          }
        }
        return string2.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string2, target, position2) {
        string2 = toString2(string2);
        position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string2.length);
        target = baseToString(target);
        return string2.slice(position2, position2 + target.length) == target;
      }
      function template(string2, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string2, options, guard)) {
          options = undefined$1;
        }
        string2 = toString2(string2);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string2.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim(string2, chars, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars === undefined$1)) {
          return baseTrim(string2);
        }
        if (!string2 || !(chars = baseToString(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end).join("");
      }
      function trimEnd(string2, chars, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars === undefined$1)) {
          return string2.slice(0, trimmedEndIndex(string2) + 1);
        }
        if (!string2 || !(chars = baseToString(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string2, chars, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars === undefined$1)) {
          return string2.replace(reTrimStart, "");
        }
        if (!string2 || !(chars = baseToString(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      function truncate(string2, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string2 = toString2(string2);
        var strLength = string2.length;
        if (hasUnicode(string2)) {
          var strSymbols = stringToArray(string2);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string2;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string2.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string2.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape(string2) {
        string2 = toString2(string2);
        return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string2, pattern, guard) {
        string2 = toString2(string2);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e2) {
          return isError(e2) ? e2 : new Error2(e2);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow2 = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root2._ === this) {
          root2._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n2) {
        n2 = toInteger(n2);
        return baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n2) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
      }
      function uniqueId(prefix) {
        var id2 = ++idCounter;
        return toString2(prefix) + id2;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow2;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap2;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp;
      lodash2.clone = clone;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate;
      lodash2.isElement = isElement;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite;
      lodash2.isFunction = isFunction;
      lodash2.isInteger = isInteger2;
      lodash2.isLength = isLength2;
      lodash2.isMap = isMap;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject;
      lodash2.isRegExp = isRegExp;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString;
      lodash2.isSymbol = isSymbol;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join2;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger(n2), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n2, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end) {
        start2 = toInteger(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _ = runInContext();
    if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root2._ = _;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
const useMarkdownEditor = () => {
  const selectedNote = useAtomValue(selectedNoteAtom);
  const saveNote = useSetAtom(saveNoteAtom);
  const editorRef = reactExports.useRef(null);
  const handleAutoSaving = lodashExports.throttle(
    async (content2) => {
      if (!selectedNote)
        return;
      console.info("Auto saving:", selectedNote.title);
      await saveNote(content2);
    },
    autoSavingTime,
    {
      leading: false,
      trailing: true
    }
  );
  const handleBlur = async () => {
    if (!selectedNote)
      return;
    handleAutoSaving.cancel();
    const content2 = editorRef.current?.getMarkdown();
    if (content2 != null) {
      await saveNote(content2);
    }
  };
  return {
    editorRef,
    selectedNote,
    handleAutoSaving,
    handleBlur
  };
};
const MarkdownEditor = () => {
  const { editorRef, selectedNote, handleAutoSaving, handleBlur } = useMarkdownEditor();
  if (!selectedNote)
    return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MDXEditor,
    {
      ref: editorRef,
      markdown: selectedNote.content,
      onChange: handleAutoSaving,
      onBlur: handleBlur,
      plugins: [headingsPlugin(), listsPlugin(), quotePlugin(), markdownShortcutPlugin()],
      contentEditableClassName: "outline-none min-h-screen max-w-none text-lg px-8 py-5 caret-yellow-500 prose prose-invert prose-p:my-3 prose-p:leading-relaxed prose-headings:my-4 prose-blockquote:my-4 prose-ul:my-2 prose-li:my-0 prose-code:px-1 prose-code:text-red-500 prose-code:before:content-[''] prose-code:after:content-['']"
    },
    selectedNote.title
  );
};
function r(e2) {
  var t3, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2)) {
      var o = e2.length;
      for (t3 = 0; t3 < o; t3++)
        e2[t3] && (f2 = r(e2[t3])) && (n2 && (n2 += " "), n2 += f2);
    } else
      for (f2 in e2)
        e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t3, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++)
    (e2 = arguments[f2]) && (t3 = r(e2)) && (n2 && (n2 += " "), n2 += t3);
  return n2;
}
const dateFormatter = new Intl.DateTimeFormat(window.context.locale, {
  dateStyle: "short",
  timeStyle: "short",
  timeZone: "UTC"
});
const formatDateFromMs = (ms) => dateFormatter.format(ms);
const cn = (...args) => {
  return twMerge(clsx(...args));
};
const NotePreview = ({
  title,
  content: content2,
  lastEditTime,
  isActive = false,
  className,
  ...props
}) => {
  const date = formatDateFromMs(lastEditTime);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: cn(
        "cursor-pointer px-2.5 py-3 rounded-md transition-colors duration-75",
        {
          "bg-zinc-400/75": isActive,
          "hover:bg-zinc-500/75": !isActive
        },
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-1 font-bold truncate", children: title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-block w-full mb-2 text-xs font-light text-left", children: date })
      ]
    }
  );
};
const useNotesList = ({ onSelect }) => {
  const notes = useAtomValue(notesAtom);
  const [selectedNoteIndex, setSelectedNoteIndex] = useAtom(selectedNoteIndexAtom);
  const handleNoteSelect = (index2) => async () => {
    setSelectedNoteIndex(index2);
    if (onSelect) {
      onSelect();
    }
  };
  return {
    notes,
    selectedNoteIndex,
    handleNoteSelect
  };
};
const NotePreviewList = ({ onSelect, className, ...props }) => {
  const { notes, selectedNoteIndex, handleNoteSelect } = useNotesList({ onSelect });
  if (!notes)
    return null;
  if (lodashExports.isEmpty(notes)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: twMerge("text-center pt-4", className), ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "No Notes Yet!" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className, ...props, children: notes.map((note, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    NotePreview,
    {
      isActive: selectedNoteIndex === index2,
      onClick: handleNoteSelect(index2),
      ...note
    },
    note.title + note.lastEditTime
  )) });
};
const App = () => {
  const contentContainerRef = reactExports.useRef(null);
  const resetScroll = () => {
    contentContainerRef.current?.scrollTo(0, 0);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableTopBar, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(RootLayout, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Sidebar, { className: "p-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButtonsRow, { className: "flex justify-between mt-1" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(NotePreviewList, { className: "mt-3 space-y-1", onSelect: resetScroll })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Content, { ref: contentContainerRef, className: "border-l bg-zinc-900/50 border-l-white/20", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingNoteTitle, { className: "pt-2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(MarkdownEditor, {})
      ] })
    ] })
  ] });
};
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React__default.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
);
export {
  React__default as R,
  reactExports as r
};
